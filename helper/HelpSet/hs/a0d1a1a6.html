<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css"></link>
<title>Configuration</title>
</head>
<body class="doc">
<h1>Configuration</h1>

<p>Basically there are two kinds of options, general "Application" options. These can be found under the menu: <br>
File -&gt; extra -&gt; application configuration<br>
There are as of now not many configurations, in general only debugging options (of Vide - not of vectrex).</p>

<p>The second set of options are regarding Vide.<br>
These can be found at:<br>
Tools -&gt; Configuation</p>

<p>All options are now bundled in one class and can as such be easily saved and loaded.</p>

<p>So you can bundle all options to "sensible" names, like:</p>

<p>    "Fastest emulation"     "Default"     "Added Timings"     "Splines"     etc</p>

<p>Upon start allways the option "Default" is loaded!</p>
<h1>Options -  now really!</h1>

<p>Vide is some kind of a Monster!<br>
I know that.<br>
<br>
Due to Vide being 100% pure java and trying to emulate vectrex as precisley as I am knowledgable to - Vide can become slow as hell.</p>

<p>I know that I still am not able to emulate the old brute 100% - but god knows I have put much effort into the emulation - and I am quite certain that at the time beeing - emulation in VIDE is the most exact vectrex emulation around.</p>

<p>Always depending on the options you have chosen. Here some descriptions of what is emulated, and how you may alter emulation with configuration: </p>
<h1>Emulator</h1>
<br><p align="center">
<img src="pics/config1.png" width="557" height="1089"><br>
<em>emulator config</em></p><br>

<p><b> Cycle exact emulation</b><br>
Most of the time you do not need this setting. It costs a little bit of emulation time.<br>
What it does: Hm...<br>
Basically it handles emulation cycle exact, yes I know you gathered that from the name.  With this option switched on analog hardware is emulated EVERY cycle. Not just at the end of each 6809 instruction. An instruction of the CPU can take anything from 2 to dunno 20 cycles? If RAMP, Shift or timers change in the middle of a CPU instruction and this is not handled at exactly the time, the output of the emulator can differ from the real machine - but this is most of the case only true if you try squeezing optimization out of the last pore of vectrex.</p>

<p><b> Enable bankswitching</b><br>
Well just what it says. Emulator may perform a tiny little bit better if switched off, since some testing will be omitted. Barely - if at all noticable.</p>

<p><b> Ringbuffer active</b><br>
You only need that for debugging purposes, this basically saves the state of vecx every CPU instruction and thus enables you to take emulation steps back. Surprisingly this also is not one of the speed eaters. But again - if Vide is to slow and you don't intend to debug - switch this off! (at the moment the size of the ringbuffer is not yet configurable, size is hardcoded to 2000) </p>

<p><b> Use splines for curved vectors </b><br>
Some games/programs do curved vectors on vectrex. "Usual" emulation does not handle that all that well, it allways rather looks edgy. With this option you can switch enhanced emulation with "splines" (Catmull Rom) on.  Drawing splines is not optimized and slows down emulation. Although only very few roms use curved vectors, so you may as well leave it enabled.</p>

<p><b>Use Quads</b><br>
Belongs to spline configuration, this is only active if splines are switched on. Drawing "Quads" is more performant than splines, but some curves look bad... I do not recommend this setting and it is available more for historic reasons than for any real value!</p>

<p><b> Slider nearby </b><br>
The slider configures how many control points are used and how they are "translated" to the drawing routine. </p>

<p><b> Suppress double draw on line sections</b><br>
Is cheating!<br>
With this option you suppress the (normal for vectrex) double drawing at the end / begining of two vectors. Sometimes this speeds things up, sometimes it slows emulation down. Try it...</p>

<p><b>Antialiazing</b><br>
Smoother lines. Suprisingly at my place emulation is a lot faster with antializing switched on. Don't know why - try it!</p>

<p><b> Try autosync</b><br>
Nearly all vectrex programs have a different screen "refresh" rate. If you just emulate with a fixed frame sooner or later the screen flickers like mad. With this option switched on, the emulator trys to sync display with Timer T2 of vectrex, which is usually used to also sync vectrex display (WaitRecal). If Vide thinks this is not working it steps back and syncs to aproximately 50Hz - but this may result in vectrex screen flickering.</p>

<p><b>Volume setting</b><br>
With this you set the sound volume.</p>

<p><b>Line width</b><br>
The thickness of one vector line. The appearence is also dependend on "glow".  The thicker - the slower emulation!</p>

<p><b>Drift</b><br>
Nearly all vectri drift in one way or another. Drift is the slight "movement" of vectors over time without the user or programm actually changing anything. This has to do with electronic laws, old analog hardware, probably temperatur, humidty and so on. The default values represent my "no buz" vectrex.</p>

<p><b>Brightness/glow</b><br>
An option that tries to visually emulate the "glow" of vectors. Results are also dependend on "Line width". Glow really slows emulation, especially higher glow values. But it is so pretty!<br>
<br>
Some emulated "effects" are only visible if glow is switched on. 
<ul><li>
<p>e.g. "dots" are usually drawn using a dot dwell time (time the vector beam resides on one single spot). The higher the dwell time, the brigher the dot. </p>
</li><li>
<p>vectors are drawn with different "strength" values, the strength actually is the speed with which the vector is moving. The higher the speed, the less time the electrons are positioned at "one" location. Thus the higher the speed, the lower the brightness of one vector</p>
</li></ul>
</p>

<p>Both effects (the second only very barely) can only be seen if glow is enable!</p>

<p><b>Efficiency</b><br>
I don't know if this is a "real" thing. In some desperate move to find a faulty behaviour, I implemented this. Basically what it does is "reduce" efficiency of the integrator Sample/Hold value the higher the absolut value of the current integrator already is. This e.g. (extreme example):<br>

<ul><li>
<p>adding SH 100 to an integrator with a value of 0 will result in the integrator having a value of 100</p>
</li><li>
<p>adding SH 100 to an integrator with a value of 10000 will result in the integrator having a value of 10090</p>
</li></ul>
</p>

<p><b>noise factor</b><br>
Experimental! With this I try to emulate the "wobble" effect, if the integrators are not "resetted" often enough.<br>
 <br>
  <b>overflow factor</b><br>
Experimental!  <br>
And I think wrong, this will be gone in the near future</p>

<p><b> Ray Gun </b><br>
Experimental start:<br>
To not "collect" vector data and do a draw when a vector is finished, but to draw on each cycle the current beam position! This was implemented, but probably won't be finalized. The raygun is shot at the display panel, each emulated cycle, with the information:
<ul><li>
<p>old position</p>
</li><li>
<p>new position</p>
</li><li>
<p>speed (or dwell time, however you would like to look at it)</p>
</li><li>
<p>color</p>
</li><li>
<p>isCurved</p>
</li></ul>
</p>

<p>The display routine is responsible to draw the positioning information. The idea was, that color, speed and position can be used to enhance brightness of the display. If a point has its color "full" (255), than it should spill further coloring to neighbouring pixels.</p>

<p>The thing is, doing a "simple" draw right now without any further evaluation and "spilling" is already really slow (which is not really suprising either).</p>

<p><b>Boot Rom</b><br>
Select the Rom you want per default use as your vectrex BIOS. The nearby buttons allow to configure the BIOS settings for each available ROM.</p>
<h1>Delays</h1>
<br><p align="center">
<img src="pics/config2.png" width="560" height="1094"><br>
<em>delay config</em></p><br>

<p>Delays seem to be quite important in exact vectrex emulation. As it seems the analog hardware does not react immediately to changes, but rather a short time span later. All delays that can be handled here are delays to analog hardware items inside vectrex.</p>

<p>To the best of my experiments - all default values represent my "no buz" new vectrex (serial number: 3117403).</p>

<p><b>MUX-SEL</b><br>
A delay in CPU cycles the data written to the VIA bit 1-2 (Mux sel) is taking to reach (trigger) the MUX.  <br>
This setting was introduced while trying to get the same output in the emulator as the real vectrex, while displaying that raster graphics of the "lineart" demo.</p>

<p><b>ZERO</b><br>
A delay in CPU cycles the data "written" to the VIA CA2 is taking to reach (trigger) the ZERO (grounding the integrators).  <br>
This setting was introduced after some other settings and watching the "sd.bin" demo of Christopher Tumber. The shots Christopher is firing set the Zero flag very VERY early (actually while the shot should still be in the "air"). On a real vectrex this works ok, my guess is - because a delay.</p>

<p><b>XSH</b><br>
A delay in CPU cycles the data "written" to the VIA ORA is taking to reach the XSH "analog storage". </p>

<p><b>YSH</b><br>
A delay in CPU cycles the data "written" to the VIA ORA is taking to reach the YSH "analog storage".  <br>
 I noticed, that usually the "sum" of YSH and MUX-SEL should be less than Ramp Off Delay.</p>

<p><b> SSH</b><br>
Implemented, but has no effect whatsoever.</p>

<p><b> RSH</b><br>
Implemented, but has no effect whatsoever.</p>

<p><b>Ramp On/Off Delay</b><br>
These delays seem to be the MOST important delays in exact emulation. I don't know why, and I find it strange that On/Off is different - but experiments showed, that these values DO differ. The ramp delays are 1/10 cycle exact - and believe me, you even see the difference on screen for 1/10 cylce, which is 1/15,000,000 seconds worth of emulation!</p>

<p><b> Blank delay</b><br>
Implemented, but as of yet no use found! But nice effects if you use the slider :-).</p>

<p><b> Blank On Delay </b><br>
(1/10 cycle) Implemented, but as of yet no use found!</p>

<p><b> Integrator Warmup </b><br>
Implemented, but as of yet no use found (1/100 cycle exact)!</p>

<p><b> Integrator Cool down </b><br>
Implemented, but as of yet no use found (1/100 cycle exact)!</p>

<p><b> Vectrex generation </b><br>
To my knowledge there are at least 3 different versions of vectrex hardware. It seems to me, that at least in my two vectri there are different DACs used. This can be seen by sample programs which try cycle exact DAC settings (usually with DAC changes while RAMP is enabled).  Therefor -&gt; the "generation" setting hides in reality a <b>DAC-Delay</b> which seems to be different for these generations.<br>
I have not tested this extensivly, but implemented is a fixed DAC delay of 2 cycles for 3. generation, and 4 cycles for 1-2 generation (and none for "Off"). The volume of generated sound for digitized music seems to be reduced on new vectri.</p>

<p>Also... the generation influences at what value via "stall" when shiftreg is updated befor the magic 18 cycles (off never stalls).</p>
<h2>Thoughts</h2>

<p>I am still not 100% certain, that all these delays are correct emulations or are just a lucky hunch which looks like they works - but rather I should be fiddling with something entirely different. I tried many different things - but nothing else comes close to these results - so take them - or find something better :-)! (end tell me!)</p>
<h1>Disassembler</h1>
<br><p align="center">
<img src="pics/config3.png" width="561" height="577"><br>
<em>disassembler config</em></p><br>

<p><b>Assume vectrex files</b><br>
This option might surprise you in Vide, but fact is - the stand alone version of dissi could probably disasssemble other programs as well... Therefor this option sort of makes sense (nah - it doesn't...).<br>
Anyway if enabled dissi scans it's files for a typical vectrex heading, like the GCE entry and the following string list.</p>

<p><b>build generic labels</b><br>
If disassembling unkown sources, dissi generates lables (in the form of "_XXXX" - where "XXXX" is the actual address) instead of using the address directly.</p>

<p><b>codescan in Vecxi</b><br>
If enabled, vecxi while executing marks addresses as "read", "write", "executed" and gives these information to dissi for use. That way dissi has a better chance to discern data from code. <br>
If everthing else is finished in vide, this might be expanded to a more in depth automatic code analyses.</p>

<p><b>column setup</b><br>
Straight forward - configuration which columns should be displayed in the dissi main table. Changes are applied at once!</p>
<h1>Debug</h1>
<br><p align="center">
<img src="pics/config4.png" width="560" height="295"><br>
<em>debug config</em></p><br>

<p><b>draw Vectors as arrows</b><br>
Just one of those not really useful, but cool options. Lets you see in what direction vectors are drawn.</p>

<p><b>draw movement vectors</b><br>
Not implemented yet - to get a glimps of what this could look like, play with the "blank delay" option. </p>

<p><b>paint integrator position</b><br>
This started as an unneccessary "cool" option - but actually I use it pretty often. With this enabled, vecxi draws a little red circle at the current vector beam postion, this is a great option to help "visualize" debugging (obviously there is a speed impact). </p>

<p><b>MultiStep delay</b><br>
The delay in milliseconds dissi waits between multi step - steps.</p>
<h1>Assembler</h1>
<br><p align="center">
<img src="pics/config5.png" width="559" height="231"><br>
<em>assembler config</em></p><br>

<p><b>automatically expand short branches to long if needed</b><br>
Well - what the option says.<br>
<b>Note</b>:<br>
As of yet assi is a two pass assembler, and I have not changed its architecture all that much (yet). Because of that it is not possible to expand branches (to that point) to unkown locations. Expanding short to long branches therefor only works with branches "backward" not forward. If an expansion forward is necessary assi quits with an error and tells you where the branch should be expanded!</p>

<p><b>opt</b><br>
Tells assi to use optimization (what little is implemented). <br>
<b>Note</b>:<br>
The "opt" pseudo opcode not only overwrites this setting it also SETS this very setting in the config. If you use "opt" in your sources, than the last use of "opt" (or noopt) is the new "config-setting" as well!</p>

<p><b>LST output</b><br>
List output takes (in relation to actually doing the assembly) a little bit of time. Therefor you can switch the generation off.</p>

<p><b>treat undefined in if clause as 0 value</b><br>
This is actually a compatabilty option to AS09.</p>
<h1>Editor</h1>
<br><p align="center">
<img src="pics/config6.png" width="561" height="201"><br>
<em>editor config</em></p><br>

<p><b>invoke Emulator after successfull assembly</b><br>
Well this is realy self explaining - isn't it?</p>

<p><b>scan for defined ...</b><br>
If checked, vedi scans files for the entities, this allows displaying / coloring of defined and undefined variables/macros and allows the "right/doubleclick" on such an entity to jump to its definition.</p>

<p><b>scan for vectorlists ...</b><br>
If checked, vecxi scans while running, whether BIOS vectrex routines draw a vectorlist, if so - vecxi saves the list in XML format, under the cartridge name.</p>
<h1>Keyboard</h1>

<p>All kind of keyboard inputs can be defined/altered here (editor, and vectrex emulator input controls).<br>
</p>

<p>Follow the instructions given on the TAB. <br>
<br>
Note:<br>
For Joytick simulations your have to configure both "Pressed" and "Released" events!</p>
<h1>Theme/Color</h1>

<p>Follow the instructions given on the TAB.</p>
<h1>Input</h1>
<br><p align="center">
<img src="pics/jinput.png" width="582" height="948"><br>
<em>input settings</em></p><br>

<p>Here you can configure additional input settings for different inout "hardware" for use with the emulator. The code is based on the "JInput" library.</p>

<p>The tab is split into two halfs, the upper half representing the vectrex "side" the lower half representing the input device parameters.</p>

<p>There are at the moment two types of vectrex input types:
<ol><li>
<p>Joystick</p>
</li><li>
<p>spinner (like atari driving paddle)</p>
</li></ol>
</p>

<p>Pressing one button on the vectrex half enables "input chosing" - pressing (or moving) the actual hardware of the selected "real" input device - connects the two sides.</p>

<p>Pressing <img src="pics/add.png" alt="add.png"> saves the configuration (after a valid name was entered.</p>

<p>Upon the next start of a vecxi window, the new input settings will be appear in the Joyport selection boxes.</p>

<p>Devices will be remembered for the next vide-sessions, however should the device not be available, it won't appear in the combobox.</p>
<br>

<p><b>Note</b>:<br>
There is a global setting for spinner emulation: "minimum cycles bewteen spinner events". Following an explanaition where this value is derived from, and when you might want to change it:</p>

<p>The driving atari-controller works thus, that the state of two switches form a 2 bit value, the actual spinner "rotates" the switch states 00 01 10 11 (binary).</p>

<p>The direction of rotation is computed via two of such states:<br>

<ul><li>
<p>left direction is computed when following states succeed each other:<br>
 00 -&gt; 01 <br>
 01 -&gt; 11 <br>
 10 -&gt; 00 <br>
 11 -&gt; 10  </p>
</li><li>
<p>right direction is computed when following states succeed each other: <br>
 00 -&gt; 10 <br>
 01 -&gt; 00 <br>
 10 -&gt; 11 <br>
 11 -&gt; 01</p>
</li></ul>
</p>

<p>All other succeeding "pairs" of states are "illegal" or no "movements" and are as such taken as "no movement".</p>

<p>The emulated paddle sets these paddle "button" values (button 1+2 of the used joyport) in the correct order at "fixed" intervalls. The minimum intervall these values are set is the cycle count given in the parameter "minimum cycles bewteen spinner events".<br>
(if you use analog emulation as input, than "slower" spinning is a multiple of that value)</p>

<p>So...<br>
If your vectrex game, refreshes once each 30000 cycles and you call the paddle "read"-routine every 30000 cycles everything is fine (default setting).</p>

<p>But if your game refreshes each 20000 and also reads paddle values each 20000 cylces the above state-order will "hickup" and some states will be read as "no movement".</p>

<p>Same happens if you read more paddle events per update round.</p>

<p>I think for most games the 30000 will be ok, but with the value "minimum cycles bewteen spinner events" you can actually alter the emulation of the paddle to accomodate possible slower games or multiple update readings.</p>
</body>
</html>
