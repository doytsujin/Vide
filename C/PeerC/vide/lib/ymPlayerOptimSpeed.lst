                              1  .module ymplayeroptimspeed.pre.s
                              2  .area .text
                              3 
                              4 ; Note:
                              5 ; this file seems fairly unstructured
                              6 ; the gist is, the current "sorting" of the different unpack sections
                              7 ; allows in many routines to use "short" branches, which:
                              8 ; a) saves space
                              9 ; b) saves cycles 
                             10 ; 
                             11 ; when routines are working correct these opimizations
                             12 ; must be allowed :-)
                             13 ;
                     F256    14 Sound_Byte = 0xF256 
                     F548    15 Clear_x_d = 0xF548 
                     D000    16 VIA_port_b = 0xD000   ;VIA port B data I/O register
                     D001    17 VIA_port_a = 0xD001   ;VIA port A data I/O register (handshaking)
                             18 
                     000B    19 REGS_MAX = 11
                             20 
                     0000    21 INFO_START = 0 
                     0000    22 BYTE_POS = 0 
                     0002    23 BIT_POS = 2 
                     0003    24 CURRENT_DATA_BYTE = 3 
                     0004    25 CURRENT_REG_BYTE = 4 
                     0005    26 CURRENT_RLE_COUNTER = 5 
                     0007    27 REG_PHRASE_MAP = 7 
                     0009    28 CURRENT_IS_PHRASE = 9 
                     000B    29 CURRENT_PLACE_IN_PHRASE = 11 
                     000C    30 PHRASE_DEFINITION_START = 12 
                     000E    31 REG_USED = 14 
                     000F    32 CURRENT_PHRASE_LEN = 15 
                     0010    33 INFO_END = 16 
                     0010    34 STRUCT_LEN = (INFO_END-INFO_START) 
                             35 ; uses 166 byte RAM!
                             36                     .area .bss      
                             37 ; Warning - org line found, my be countering relocatable code!
                             38 ;                    org      ym_ram 
                             39  .globl _cregister
   0000                      40 _cregister: 
   0000                      41                     .blkb       1 
                             42  .globl _temp
   0001                      43 _temp: 
   0001                      44                     .blkb       1 
                             45  .globl _temp2
   0002                      46 _temp2: 
   0002                      47                     .blkb       1 
                             48  .globl _temp3
   0003                      49 _temp3: 
   0003                      50                     .blkb       1 
                             51  .globl _calc_coder
   0004                      52 _calc_coder: 
   0004                      53                     .blkb       1 
                             54  .globl _calc_bits
   0005                      55 _calc_bits: 
   0005                      56                     .blkb       1 
                             57  .globl _ym_len
   0006                      58 _ym_len: 
   0006                      59                     .blkb       2 
                             60  .globl _ym_data_current
   0008                      61 _ym_data_current: 
   0008                      62                     .blkb       2 
                             63  .globl _ym_name
   000A                      64 _ym_name: 
   000A                      65                     .blkb       2 
                             66  .globl _ym_regs_used
   000C                      67 _ym_regs_used:       .blkb       1 
                             68  .globl _ym_regs_count
   000D                      69 _ym_regs_count:      .blkb       1 
                             70  .globl _ym_data_start
   000E                      71 _ym_data_start: 
   000E                      72                     .blkb       REGS_MAX * STRUCT_LEN 
                             73 ; uses X and B
                             74 ; all other registeres stay the same
                             75 
                             76 ; store data in reg a in an
                             77 ; appropriate way to PSG register (here: BIOS working buffer)
                     C83F    78 Vec_Music_Work  =     0xC83F   ;Music work buffer (14 bytes, backwards?)
                             79 
                             80    
                             81                     .area .text     
                             82  .globl _reg_max_data
   0000                      83 _reg_max_data: 
   0000 08 04 08 04 08 04    84                     .byte       8,4,8,4,8,4,5,6,4,4,4,8,8,5,8,8 
        05 06 04 04 04 08
        08 05 08 08
                             85  .globl rleEncodedData
   0010                      86 rleEncodedData: 
                             87 ; non single entity here... must decode RLE
                             88 ; first we look for how many bits the RLE counter spreads
                             89 ; in A will be out bit counter, how many bits our actual counter uses
   0010 4F            [ 2]   90                     clra     
                             91  .globl moreBits
   0011                      92 moreBits: 
   0011 4C            [ 2]   93                     inca     
                             94 ; macro call ->                     read_one_bit_from_data  
                             95 ;;;;;;;;;;;; GET_BIT_START
   0012 E6 42         [ 5]   96                     ldb      BIT_POS,u 
   0014 26 0C         [ 3]   97                     bne      bit_is_ready1 
                             98 ; load a new byte
   0016 AE 40         [ 6]   99                     ldx      BYTE_POS,u 
   0018 E6 80         [ 6]  100                     ldb      ,x+ 
   001A E7 43         [ 5]  101                     stb      CURRENT_DATA_BYTE,u 
   001C AF 40         [ 6]  102                     stx      BYTE_POS,u 
   001E C6 80         [ 2]  103                     ldb      #0x80 
   0020 E7 42         [ 5]  104                     stb      BIT_POS,u 
                            105  .globl bit_is_ready1
   0022                     106 bit_is_ready1: 
                            107 ; bit position correct here
                            108 ;
                            109 ; remember we use one bit now!
   0022 64 42         [ 7]  110                     lsr      BIT_POS,u 
                            111 ; is the bit at the current position set?
   0024 E4 43         [ 5]  112                     andb     CURRENT_DATA_BYTE,u 
                            113 ;;;;;;;;;;;; GET_BIT_END
   0026 26 E9         [ 3]  114                     bne      moreBits 
   0028 1E 89         [ 8]  115                     exg      a,b 
   002A 1F 02         [ 6]  116                     tfr      d,y                          ; in y now our count of bits 
                            117 ; in y is the # of bits for the counter
                            118 ; the following '#y' bits represent the RLE count
                            119 ; MSB first
                            120 ; in a (later d) will be our new RLE count
   002C 4F            [ 2]  121                     clra     
                            122 ; macro call ->                     read_one_bit_from_data  
                            123 ;;;;;;;;;;;; GET_BIT_START
   002D E6 42         [ 5]  124                     ldb      BIT_POS,u 
   002F 26 0C         [ 3]  125                     bne      bit_is_ready2 
                            126 ; load a new byte
   0031 AE 40         [ 6]  127                     ldx      BYTE_POS,u 
   0033 E6 80         [ 6]  128                     ldb      ,x+ 
   0035 E7 43         [ 5]  129                     stb      CURRENT_DATA_BYTE,u 
   0037 AF 40         [ 6]  130                     stx      BYTE_POS,u 
   0039 C6 80         [ 2]  131                     ldb      #0x80 
   003B E7 42         [ 5]  132                     stb      BIT_POS,u 
                            133  .globl bit_is_ready2
   003D                     134 bit_is_ready2: 
                            135 ; bit position correct here
                            136 ;
                            137 ; remember we use one bit now!
   003D 64 42         [ 7]  138                     lsr      BIT_POS,u 
                            139 ; is the bit at the current position set?
   003F E4 43         [ 5]  140                     andb     CURRENT_DATA_BYTE,u 
                            141 ;;;;;;;;;;;; GET_BIT_END
   0041 27 01         [ 3]  142                     beq      rleCounterBit0NotSet 
   0043 4C            [ 2]  143                     inca     
                            144  .globl rleCounterBit0NotSet
   0044                     145 rleCounterBit0NotSet: 
   0044 48            [ 2]  146                     lsla     
                            147 ; macro call ->                     read_one_bit_from_data  
                            148 ;;;;;;;;;;;; GET_BIT_START
   0045 E6 42         [ 5]  149                     ldb      BIT_POS,u 
   0047 26 0C         [ 3]  150                     bne      bit_is_ready3 
                            151 ; load a new byte
   0049 AE 40         [ 6]  152                     ldx      BYTE_POS,u 
   004B E6 80         [ 6]  153                     ldb      ,x+ 
   004D E7 43         [ 5]  154                     stb      CURRENT_DATA_BYTE,u 
   004F AF 40         [ 6]  155                     stx      BYTE_POS,u 
   0051 C6 80         [ 2]  156                     ldb      #0x80 
   0053 E7 42         [ 5]  157                     stb      BIT_POS,u 
                            158  .globl bit_is_ready3
   0055                     159 bit_is_ready3: 
                            160 ; bit position correct here
                            161 ;
                            162 ; remember we use one bit now!
   0055 64 42         [ 7]  163                     lsr      BIT_POS,u 
                            164 ; is the bit at the current position set?
   0057 E4 43         [ 5]  165                     andb     CURRENT_DATA_BYTE,u 
                            166 ;;;;;;;;;;;; GET_BIT_END
   0059 27 01         [ 3]  167                     beq      rleCounterBit1NotSet 
   005B 4C            [ 2]  168                     inca     
                            169  .globl rleCounterBit1NotSet
   005C                     170 rleCounterBit1NotSet: 
   005C 48            [ 2]  171                     lsla     
                            172 ; macro call ->                     read_one_bit_from_data  
                            173 ;;;;;;;;;;;; GET_BIT_START
   005D E6 42         [ 5]  174                     ldb      BIT_POS,u 
   005F 26 0C         [ 3]  175                     bne      bit_is_ready4 
                            176 ; load a new byte
   0061 AE 40         [ 6]  177                     ldx      BYTE_POS,u 
   0063 E6 80         [ 6]  178                     ldb      ,x+ 
   0065 E7 43         [ 5]  179                     stb      CURRENT_DATA_BYTE,u 
   0067 AF 40         [ 6]  180                     stx      BYTE_POS,u 
   0069 C6 80         [ 2]  181                     ldb      #0x80 
   006B E7 42         [ 5]  182                     stb      BIT_POS,u 
                            183  .globl bit_is_ready4
   006D                     184 bit_is_ready4: 
                            185 ; bit position correct here
                            186 ;
                            187 ; remember we use one bit now!
   006D 64 42         [ 7]  188                     lsr      BIT_POS,u 
                            189 ; is the bit at the current position set?
   006F E4 43         [ 5]  190                     andb     CURRENT_DATA_BYTE,u 
                            191 ;;;;;;;;;;;; GET_BIT_END
   0071 27 01         [ 3]  192                     beq      rleCounterBit2NotSet 
   0073 4C            [ 2]  193                     inca     
                            194  .globl rleCounterBit2NotSet
   0074                     195 rleCounterBit2NotSet: 
   0074 31 3F         [ 5]  196                     leay     -1,y 
   0076 10 27 00 B8   [ 6]  197                     lbeq     rle8bitdone 
   007A 48            [ 2]  198                     lsla     
                            199 ; macro call ->                     read_one_bit_from_data  
                            200 ;;;;;;;;;;;; GET_BIT_START
   007B E6 42         [ 5]  201                     ldb      BIT_POS,u 
   007D 26 0C         [ 3]  202                     bne      bit_is_ready5 
                            203 ; load a new byte
   007F AE 40         [ 6]  204                     ldx      BYTE_POS,u 
   0081 E6 80         [ 6]  205                     ldb      ,x+ 
   0083 E7 43         [ 5]  206                     stb      CURRENT_DATA_BYTE,u 
   0085 AF 40         [ 6]  207                     stx      BYTE_POS,u 
   0087 C6 80         [ 2]  208                     ldb      #0x80 
   0089 E7 42         [ 5]  209                     stb      BIT_POS,u 
                            210  .globl bit_is_ready5
   008B                     211 bit_is_ready5: 
                            212 ; bit position correct here
                            213 ;
                            214 ; remember we use one bit now!
   008B 64 42         [ 7]  215                     lsr      BIT_POS,u 
                            216 ; is the bit at the current position set?
   008D E4 43         [ 5]  217                     andb     CURRENT_DATA_BYTE,u 
                            218 ;;;;;;;;;;;; GET_BIT_END
   008F 27 01         [ 3]  219                     beq      rleCounterBit3NotSet 
   0091 4C            [ 2]  220                     inca     
                            221  .globl rleCounterBit3NotSet
   0092                     222 rleCounterBit3NotSet: 
   0092 31 3F         [ 5]  223                     leay     -1,y 
   0094 10 27 00 9A   [ 6]  224                     lbeq     rle8bitdone 
   0098 48            [ 2]  225                     lsla     
                            226 ; macro call ->                     read_one_bit_from_data  
                            227 ;;;;;;;;;;;; GET_BIT_START
   0099 E6 42         [ 5]  228                     ldb      BIT_POS,u 
   009B 26 0C         [ 3]  229                     bne      bit_is_ready6 
                            230 ; load a new byte
   009D AE 40         [ 6]  231                     ldx      BYTE_POS,u 
   009F E6 80         [ 6]  232                     ldb      ,x+ 
   00A1 E7 43         [ 5]  233                     stb      CURRENT_DATA_BYTE,u 
   00A3 AF 40         [ 6]  234                     stx      BYTE_POS,u 
   00A5 C6 80         [ 2]  235                     ldb      #0x80 
   00A7 E7 42         [ 5]  236                     stb      BIT_POS,u 
                            237  .globl bit_is_ready6
   00A9                     238 bit_is_ready6: 
                            239 ; bit position correct here
                            240 ;
                            241 ; remember we use one bit now!
   00A9 64 42         [ 7]  242                     lsr      BIT_POS,u 
                            243 ; is the bit at the current position set?
   00AB E4 43         [ 5]  244                     andb     CURRENT_DATA_BYTE,u 
                            245 ;;;;;;;;;;;; GET_BIT_END
   00AD 27 01         [ 3]  246                     beq      rleCounterBit4NotSet 
   00AF 4C            [ 2]  247                     inca     
                            248  .globl rleCounterBit4NotSet
   00B0                     249 rleCounterBit4NotSet: 
   00B0 31 3F         [ 5]  250                     leay     -1,y 
   00B2 27 7E         [ 3]  251                     beq      rle8bitdone 
   00B4 48            [ 2]  252                     lsla     
                            253 ; macro call ->                     read_one_bit_from_data  
                            254 ;;;;;;;;;;;; GET_BIT_START
   00B5 E6 42         [ 5]  255                     ldb      BIT_POS,u 
   00B7 26 0C         [ 3]  256                     bne      bit_is_ready7 
                            257 ; load a new byte
   00B9 AE 40         [ 6]  258                     ldx      BYTE_POS,u 
   00BB E6 80         [ 6]  259                     ldb      ,x+ 
   00BD E7 43         [ 5]  260                     stb      CURRENT_DATA_BYTE,u 
   00BF AF 40         [ 6]  261                     stx      BYTE_POS,u 
   00C1 C6 80         [ 2]  262                     ldb      #0x80 
   00C3 E7 42         [ 5]  263                     stb      BIT_POS,u 
                            264  .globl bit_is_ready7
   00C5                     265 bit_is_ready7: 
                            266 ; bit position correct here
                            267 ;
                            268 ; remember we use one bit now!
   00C5 64 42         [ 7]  269                     lsr      BIT_POS,u 
                            270 ; is the bit at the current position set?
   00C7 E4 43         [ 5]  271                     andb     CURRENT_DATA_BYTE,u 
                            272 ;;;;;;;;;;;; GET_BIT_END
   00C9 27 01         [ 3]  273                     beq      rleCounterBit5NotSet 
   00CB 4C            [ 2]  274                     inca     
                            275  .globl rleCounterBit5NotSet
   00CC                     276 rleCounterBit5NotSet: 
   00CC 31 3F         [ 5]  277                     leay     -1,y 
   00CE 27 62         [ 3]  278                     beq      rle8bitdone 
   00D0 48            [ 2]  279                     lsla     
                            280 ; macro call ->                     read_one_bit_from_data  
                            281 ;;;;;;;;;;;; GET_BIT_START
   00D1 E6 42         [ 5]  282                     ldb      BIT_POS,u 
   00D3 26 0C         [ 3]  283                     bne      bit_is_ready8 
                            284 ; load a new byte
   00D5 AE 40         [ 6]  285                     ldx      BYTE_POS,u 
   00D7 E6 80         [ 6]  286                     ldb      ,x+ 
   00D9 E7 43         [ 5]  287                     stb      CURRENT_DATA_BYTE,u 
   00DB AF 40         [ 6]  288                     stx      BYTE_POS,u 
   00DD C6 80         [ 2]  289                     ldb      #0x80 
   00DF E7 42         [ 5]  290                     stb      BIT_POS,u 
                            291  .globl bit_is_ready8
   00E1                     292 bit_is_ready8: 
                            293 ; bit position correct here
                            294 ;
                            295 ; remember we use one bit now!
   00E1 64 42         [ 7]  296                     lsr      BIT_POS,u 
                            297 ; is the bit at the current position set?
   00E3 E4 43         [ 5]  298                     andb     CURRENT_DATA_BYTE,u 
                            299 ;;;;;;;;;;;; GET_BIT_END
   00E5 27 01         [ 3]  300                     beq      rleCounterBit6NotSet 
   00E7 4C            [ 2]  301                     inca     
                            302  .globl rleCounterBit6NotSet
   00E8                     303 rleCounterBit6NotSet: 
   00E8 31 3F         [ 5]  304                     leay     -1,y 
   00EA 27 46         [ 3]  305                     beq      rle8bitdone 
   00EC 48            [ 2]  306                     lsla     
                            307 ; macro call ->                     read_one_bit_from_data  
                            308 ;;;;;;;;;;;; GET_BIT_START
   00ED E6 42         [ 5]  309                     ldb      BIT_POS,u 
   00EF 26 0C         [ 3]  310                     bne      bit_is_ready9 
                            311 ; load a new byte
   00F1 AE 40         [ 6]  312                     ldx      BYTE_POS,u 
   00F3 E6 80         [ 6]  313                     ldb      ,x+ 
   00F5 E7 43         [ 5]  314                     stb      CURRENT_DATA_BYTE,u 
   00F7 AF 40         [ 6]  315                     stx      BYTE_POS,u 
   00F9 C6 80         [ 2]  316                     ldb      #0x80 
   00FB E7 42         [ 5]  317                     stb      BIT_POS,u 
                            318  .globl bit_is_ready9
   00FD                     319 bit_is_ready9: 
                            320 ; bit position correct here
                            321 ;
                            322 ; remember we use one bit now!
   00FD 64 42         [ 7]  323                     lsr      BIT_POS,u 
                            324 ; is the bit at the current position set?
   00FF E4 43         [ 5]  325                     andb     CURRENT_DATA_BYTE,u 
                            326 ;;;;;;;;;;;; GET_BIT_END
   0101 27 01         [ 3]  327                     beq      rleCounterBit7NotSet 
   0103 4C            [ 2]  328                     inca     
                            329  .globl rleCounterBit7NotSet
   0104                     330 rleCounterBit7NotSet: 
   0104 31 3F         [ 5]  331                     leay     -1,y 
   0106 27 2A         [ 3]  332                     beq      rle8bitdone 
                            333 ; now the counter has more than 8 bit, gets trickier
   0108 A7 46         [ 5]  334                     sta      CURRENT_RLE_COUNTER+1,u      ; assuming high byte is zero of counter 
                            335  .globl read16bitContinue
   010A                     336 read16bitContinue: 
   010A EC 45         [ 6]  337                     ldd      CURRENT_RLE_COUNTER,u 
                            338 ; this does a LSLD
   010C 48            [ 2]  339                     lsla                                  ; LSL A 
   010D 58            [ 2]  340                     lslb                                  ; LSL B 
   010E 24 02         [ 3]  341                     bcc      no_carry                     ; if no carry, than exit 
   0110 8A 01         [ 2]  342                     ora      #1                           ; otherwise overflow from B to 0bit of A 
                            343  .globl no_carry
   0112                     344 no_carry: 
                            345 ; LSLD finish
   0112 ED 45         [ 6]  346                     std      CURRENT_RLE_COUNTER,u 
                            347 ; macro call ->                     read_one_bit_from_data  
                            348 ;;;;;;;;;;;; GET_BIT_START
   0114 E6 42         [ 5]  349                     ldb      BIT_POS,u 
   0116 26 0C         [ 3]  350                     bne      bit_is_ready10 
                            351 ; load a new byte
   0118 AE 40         [ 6]  352                     ldx      BYTE_POS,u 
   011A E6 80         [ 6]  353                     ldb      ,x+ 
   011C E7 43         [ 5]  354                     stb      CURRENT_DATA_BYTE,u 
   011E AF 40         [ 6]  355                     stx      BYTE_POS,u 
   0120 C6 80         [ 2]  356                     ldb      #0x80 
   0122 E7 42         [ 5]  357                     stb      BIT_POS,u 
                            358  .globl bit_is_ready10
   0124                     359 bit_is_ready10: 
                            360 ; bit position correct here
                            361 ;
                            362 ; remember we use one bit now!
   0124 64 42         [ 7]  363                     lsr      BIT_POS,u 
                            364 ; is the bit at the current position set?
   0126 E4 43         [ 5]  365                     andb     CURRENT_DATA_BYTE,u 
                            366 ;;;;;;;;;;;; GET_BIT_END
   0128 27 02         [ 3]  367                     beq      rleCounterBitXNotSet 
   012A 6C 46         [ 7]  368                     inc      CURRENT_RLE_COUNTER+1,u 
                            369  .globl rleCounterBitXNotSet
   012C                     370 rleCounterBitXNotSet: 
   012C 31 3F         [ 5]  371                     leay     -1,y 
   012E 26 DA         [ 3]  372                     bne      read16bitContinue 
                            373  .globl rle16bitdone
   0130                     374 rle16bitdone: 
                            375 ; now the current counter should be set
                            376 ; we still need to dechifer the following byte...
   0130 20 65         [ 3]  377                     bra      dechifer 
                            378 
                            379  .globl rle8bitdone
   0132                     380 rle8bitdone: 
   0132 A7 46         [ 5]  381                     sta      CURRENT_RLE_COUNTER+1,u      ; assuming high byte is zero of counter 
                            382 ; now the current counter should be set
                            383 ; we still need to dechifer the following byte...
   0134 20 61         [ 3]  384                     bra      dechifer 
                            385 
                            386 ;***************************************************************************
                            387 ;***************************************************************************
                            388  .globl do_ym_sound
   0136                     389 do_ym_sound: 
   0136 FC 00 08      [ 6]  390                     ldd      _ym_data_current              ; load current VBL Counter 
   0139 27 41         [ 3]  391                     beq      ymsodone                     ; if 0, than we are done 
   013B 83 00 01      [ 4]  392                     subd     #1                           ; otherwise remember we are doing one byte now 
   013E FD 00 08      [ 6]  393                     std      _ym_data_current              ; and store it 
   0141 B6 00 0C      [ 5]  394                     lda      _ym_regs_used                 ; get the number of regs we are working on 
   0144 B7 00 0D      [ 5]  395                     sta      _ym_regs_count                ; and remember them as current counter 
   0147 CE 00 0E      [ 3]  396                     ldu      #_ym_data_start               ; load RAM start address of our wokring structure 
                            397  .globl next_reg
   014A                     398 next_reg: 
                            399 ;                    jsr      getCurrentRegByte            ; in relation to RAM structure (U), get the next register byte 
                            400 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; was subroutine, now inlined-start
                            401 ; U pointer to data structure
                            402 ; A number of register
                            403  .globl getCurrentRegByte
   014A                     404 getCurrentRegByte: 
                            405 ; do we have a byte that is valid?
   014A EC 45         [ 6]  406                     ldd      CURRENT_RLE_COUNTER,u        ; if current RLE counter is zero, than we must get a new byte 
   014C 27 2F         [ 3]  407                     beq      noValidByte                  ; jump to get new byte 
                            408 ; yep... use current byte
   014E AE 49         [ 6]  409                     ldx      CURRENT_IS_PHRASE,u          ; otherwise, lets check if we are in a phrase (x = pointer to phrase or zero) 
   0150 27 12         [ 3]  410                     beq      not_in_phrase                ; jump if not 
   0152 E6 4B         [ 5]  411                     ldb      CURRENT_PLACE_IN_PHRASE,u    ; where in our phrase are we? 
   0154 A6 4F         [ 5]  412                     lda      CURRENT_PHRASE_LEN,u         ; length of phrase 
                            413  .globl inPhraseOut
   0156                     414 inPhraseOut: 
   0156 E6 85         [ 5]  415                     ldb      b,x                          ; load the next byte of our phrase 
   0158 E7 44         [ 5]  416                     stb      CURRENT_REG_BYTE,u           ; store that to current output 
   015A 6C 4B         [ 7]  417                     inc      CURRENT_PLACE_IN_PHRASE,u    ; check if we are at the end of the phrase 
   015C A1 4B         [ 5]  418                     cmpa     CURRENT_PLACE_IN_PHRASE,u    ; (in a is phrase len) 
   015E 26 09         [ 3]  419                     bne      currentPharseNotEnded        ; if phrase is not at end - continue 
   0160 6F 4B         [ 7]  420                     clr      CURRENT_PLACE_IN_PHRASE,u    ; other wise we set place to zero 
   0162 EC 45         [ 6]  421                     ldd      CURRENT_RLE_COUNTER,u        ; and decrease out RLE counter 
                            422  .globl not_in_phrase
   0164                     423 not_in_phrase: 
   0164 83 00 01      [ 4]  424                     subd     #1 
   0167 ED 45         [ 6]  425                     std      CURRENT_RLE_COUNTER,u 
                            426  .globl currentPharseNotEnded
   0169                     427 currentPharseNotEnded: 
                            428  .globl done
   0169                     429 done: 
                            430 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; was subroutine, now inlined-end
   0169 E6 44         [ 5]  431                     ldb      CURRENT_REG_BYTE,u 
   016B A6 4E         [ 5]  432                     lda      REG_USED,u                   ; load current register 
                            433                                                           ; A PSG reg 
                            434                                                           ; B data 
                            435 
                            436 
   016D 10 8E C8 4C   [ 4]  437                     ldy     #0xC84C
   0171 40            [ 2]  438  nega
   0172 E7 A6         [ 5]  439 				  stb a,y
                            440 
                            441 
                            442 ;                    ldy      #Vec_Music_Work
                            443 ;				  stb a,y
                            444 ;                    sta      ,u 
                            445 
                            446 ;                    WRITE_PSG  
                            447 
                            448 ;                    jsr      Sound_Byte                   ; and actually output that to the sound chip 
                            449  .globl doNotWriteReg13
   0174                     450 doNotWriteReg13:
   0174 33 C8 10      [ 5]  451                     leau     STRUCT_LEN,u                 ; go to next "register" of sound data 
   0177 7A 00 0D      [ 7]  452                     dec      _ym_regs_count                ; but only if we are not done yet, if counter is zero 
   017A 26 CE         [ 3]  453                     bne      next_reg                     ; we do not branch :-) 
                            454  .globl ymsodone
   017C                     455 ymsodone: 
   017C 39            [ 5]  456                     rts      
                            457 ;***************************************************************************
                            458 ;***************************************************************************
                            459 
                            460  .globl noValidByte
   017D                     461 noValidByte: 
                            462 ; no we must look at the bits
                            463 ; a will be our bit register
                            464 ; macro call ->                     read_one_bit_from_data  
                            465 ;;;;;;;;;;;; GET_BIT_START
   017D E6 42         [ 5]  466                     ldb      BIT_POS,u 
   017F 26 0C         [ 3]  467                     bne      bit_is_ready11 
                            468 ; load a new byte
   0181 AE 40         [ 6]  469                     ldx      BYTE_POS,u 
   0183 E6 80         [ 6]  470                     ldb      ,x+ 
   0185 E7 43         [ 5]  471                     stb      CURRENT_DATA_BYTE,u 
   0187 AF 40         [ 6]  472                     stx      BYTE_POS,u 
   0189 C6 80         [ 2]  473                     ldb      #0x80 
   018B E7 42         [ 5]  474                     stb      BIT_POS,u 
                            475  .globl bit_is_ready11
   018D                     476 bit_is_ready11: 
                            477 ; bit position correct here
                            478 ;
                            479 ; remember we use one bit now!
   018D 64 42         [ 7]  480                     lsr      BIT_POS,u 
                            481 ; is the bit at the current position set?
   018F E4 43         [ 5]  482                     andb     CURRENT_DATA_BYTE,u 
                            483 ;;;;;;;;;;;; GET_BIT_END
                            484 ; check bit, if 1 than RLE encoded
                            485 ; if not - not
   0191 10 26 FE 7B   [ 6]  486                     lbne      rleEncodedData 
                            487                                                           ; must be zero 
                            488                                                           ; 1 is always only 8 bit... 
   0195 6C 46         [ 7]  489                     inc      CURRENT_RLE_COUNTER+1,u 
                            490  .globl dechifer
   0197                     491 dechifer: 
                            492 ; check bit
                            493 ; if 1 than shannon encoded
                            494 ; if 0 - not
                            495 ; macro call ->                     read_one_bit_from_data  
                            496 ;;;;;;;;;;;; GET_BIT_START
   0197 E6 42         [ 5]  497                     ldb      BIT_POS,u 
   0199 26 0C         [ 3]  498                     bne      bit_is_ready12 
                            499 ; load a new byte
   019B AE 40         [ 6]  500                     ldx      BYTE_POS,u 
   019D E6 80         [ 6]  501                     ldb      ,x+ 
   019F E7 43         [ 5]  502                     stb      CURRENT_DATA_BYTE,u 
   01A1 AF 40         [ 6]  503                     stx      BYTE_POS,u 
   01A3 C6 80         [ 2]  504                     ldb      #0x80 
   01A5 E7 42         [ 5]  505                     stb      BIT_POS,u 
                            506  .globl bit_is_ready12
   01A7                     507 bit_is_ready12: 
                            508 ; bit position correct here
                            509 ;
                            510 ; remember we use one bit now!
   01A7 64 42         [ 7]  511                     lsr      BIT_POS,u 
                            512 ; is the bit at the current position set?
   01A9 E4 43         [ 5]  513                     andb     CURRENT_DATA_BYTE,u 
                            514 ;;;;;;;;;;;; GET_BIT_END
   01AB 27 52         [ 3]  515                     beq      directByte                   ; if bit is zero - jump 
   01AD 10 FF 00 01   [ 7]  516                     sts      _temp                         ; save stackpointer 
   01B1 10 EE 47      [ 7]  517                     lds      REG_PHRASE_MAP,u             ; load the starting position of the phrase mappings for this register 
   01B4 10 AE 4C      [ 7]  518                     ldy      PHRASE_DEFINITION_START,u    ; and also the phrase definition address 
   01B7 4F            [ 2]  519                     clra                                  ; was _calc_bits, a contains the number of bits our current shannon code checkings 
   01B8 B7 00 04      [ 5]  520                     sta      _calc_coder                   ; starting with zero for coder also 
                            521  .globl getNextCodeBit
   01BB                     522 getNextCodeBit: 
   01BB 78 00 04      [ 7]  523                     lsl      _calc_coder                   ; prepare load of next coder bit - shift all previous codes one position 
   01BE 4C            [ 2]  524                     inca                                  ; increase used bits 
                            525 ; macro call ->                     read_one_bit_from_data  
                            526 ;;;;;;;;;;;; GET_BIT_START
   01BF E6 42         [ 5]  527                     ldb      BIT_POS,u 
   01C1 26 0C         [ 3]  528                     bne      bit_is_ready13 
                            529 ; load a new byte
   01C3 AE 40         [ 6]  530                     ldx      BYTE_POS,u 
   01C5 E6 80         [ 6]  531                     ldb      ,x+ 
   01C7 E7 43         [ 5]  532                     stb      CURRENT_DATA_BYTE,u 
   01C9 AF 40         [ 6]  533                     stx      BYTE_POS,u 
   01CB C6 80         [ 2]  534                     ldb      #0x80 
   01CD E7 42         [ 5]  535                     stb      BIT_POS,u 
                            536  .globl bit_is_ready13
   01CF                     537 bit_is_ready13: 
                            538 ; bit position correct here
                            539 ;
                            540 ; remember we use one bit now!
   01CF 64 42         [ 7]  541                     lsr      BIT_POS,u 
                            542 ; is the bit at the current position set?
   01D1 E4 43         [ 5]  543                     andb     CURRENT_DATA_BYTE,u 
                            544 ;;;;;;;;;;;; GET_BIT_END
   01D3 27 03         [ 3]  545                     beq      code_bit_notset              ; if bit is zero - jump 
   01D5 7C 00 04      [ 7]  546                     inc      _calc_coder                   ; otherwise set bit in current code 
                            547  .globl code_bit_notset
   01D8                     548 code_bit_notset: 
                            549  .globl testNextPhrase
   01D8                     550 testNextPhrase: 
   01D8 A1 E4         [ 4]  551                     cmpa     ,s                           ; check if it count of currently referenced phrase equals the current shannon bitcount 
   01DA 2D DF         [ 3]  552                     blt      getNextCodeBit               ; if lower, load next bit (and increase shannon bits) 
   01DC 27 08         [ 3]  553                     beq      bitLenFound                  ; if equal, than we must check if codes equal 
                            554 ; if greater, than we advance one in our phrase table, and check the next phrase
                            555  .globl increaseCodeBits
   01DE                     556 increaseCodeBits: 
   01DE E6 62         [ 5]  557                     ldb      2,s                          ; load length of last phase and 
   01E0 31 A5         [ 5]  558                     leay     b,y                          ; add that to our future pointer to phrases 
   01E2 32 63         [ 5]  559                     leas     3,s                          ; advance one phrase in out mapping (one mapping = 3 byte) 
   01E4 20 F2         [ 3]  560                     bra      testNextPhrase               ; and test the next such got phrase 
                            561 
                            562 ; here we come if
                            563 ; shannon bit length of read data == shannon bit length phrase that the maping references
                            564 ; there can be more than one, so we must still seek the one with the
                            565 ; correct code
                            566  .globl bitLenFound
   01E6                     567 bitLenFound: 
   01E6 E6 61         [ 5]  568                     ldb      1,s                          ; load coder-byte, from current phrase 
   01E8 F1 00 04      [ 5]  569                     cmpb     _calc_coder                   ; and compare with current loaded coder-byte from "bitstream" 
   01EB 26 F1         [ 3]  570                     bne      increaseCodeBits             ; if not the same, check next phrase in phrase mapping (jump) 
   01ED A6 62         [ 5]  571                     lda      2,s                          ; otherwise we found the correct phrase, load length of current phrase 
   01EF A7 4F         [ 5]  572                     sta      CURRENT_PHRASE_LEN,u         ; and remember that 
   01F1 10 FE 00 01   [ 7]  573                     lds      _temp                         ; restore stack 
   01F5 1F 21         [ 6]  574                     tfr      y,x                          ; pointer to current found phrase to X (will be resused in out) 
   01F7 5F            [ 2]  575                     clrb                                  ; current position in phrase is at start 0 
   01F8 AF 49         [ 6]  576                     stx      CURRENT_IS_PHRASE,u          ; store the phrase to the structure 
   01FA E7 4B         [ 5]  577                     stb      CURRENT_PLACE_IN_PHRASE,u    ; also the position 
   01FC 7E 01 56      [ 4]  578                     jmp      inPhraseOut                  ; and output the next phrase byte 
                            579 
                            580 ; direct bytes are not shannon encoded 
                            581  .globl directByte
   01FF                     582 directByte: 
                            583                                                           ; get 8 bit 
   01FF EC 45         [ 6]  584                     ldd      CURRENT_RLE_COUNTER,u 
   0201 83 00 01      [ 4]  585                     subd     #1 
   0204 ED 45         [ 6]  586                     std      CURRENT_RLE_COUNTER,u 
   0206 4F            [ 2]  587                     clra     
   0207 A7 49         [ 5]  588                     sta      CURRENT_IS_PHRASE,u 
   0209 A7 4A         [ 5]  589                     sta      CURRENT_IS_PHRASE+1,u 
                            590 ; some sort of loop unrolling
                            591 ; we check for each register how many
                            592 ; relevant bits it uses
                            593 ; and read only so many bits from our "stream"
                            594 ; the coder also provides only that many bits
   020B 8E 00 00      [ 3]  595                     ldx      #_reg_max_data 
   020E E6 4E         [ 5]  596                     ldb      REG_USED,u 
   0210 E6 85         [ 5]  597                     ldb      b,x                          ; number of relevant bits for reg 
   0212 C1 08         [ 2]  598                     cmpb     #8 
   0214 27 0C         [ 3]  599                     beq      reg8Bits 
   0216 C1 06         [ 2]  600                     cmpb     #6 
   0218 27 38         [ 3]  601                     beq      reg6Bits 
   021A C1 05         [ 2]  602                     cmpb     #5 
   021C 27 4C         [ 3]  603                     beq      reg5Bits 
   021E C1 04         [ 2]  604                     cmpb     #4 
   0220 27 60         [ 3]  605                     beq      reg4Bits 
                            606  .globl reg8Bits
   0222                     607 reg8Bits: 
                            608 ; macro call ->                     read_one_bit_from_data  
                            609 ;;;;;;;;;;;; GET_BIT_START
   0222 E6 42         [ 5]  610                     ldb      BIT_POS,u 
   0224 26 0C         [ 3]  611                     bne      bit_is_ready14 
                            612 ; load a new byte
   0226 AE 40         [ 6]  613                     ldx      BYTE_POS,u 
   0228 E6 80         [ 6]  614                     ldb      ,x+ 
   022A E7 43         [ 5]  615                     stb      CURRENT_DATA_BYTE,u 
   022C AF 40         [ 6]  616                     stx      BYTE_POS,u 
   022E C6 80         [ 2]  617                     ldb      #0x80 
   0230 E7 42         [ 5]  618                     stb      BIT_POS,u 
                            619  .globl bit_is_ready14
   0232                     620 bit_is_ready14: 
                            621 ; bit position correct here
                            622 ;
                            623 ; remember we use one bit now!
   0232 64 42         [ 7]  624                     lsr      BIT_POS,u 
                            625 ; is the bit at the current position set?
   0234 E4 43         [ 5]  626                     andb     CURRENT_DATA_BYTE,u 
                            627 ;;;;;;;;;;;; GET_BIT_END
   0236 27 01         [ 3]  628                     beq      noBit1 
   0238 4C            [ 2]  629                     inca     
                            630  .globl noBit1
   0239                     631 noBit1: 
   0239 48            [ 2]  632                     lsla     
                            633 ; macro call ->                     read_one_bit_from_data  
                            634 ;;;;;;;;;;;; GET_BIT_START
   023A E6 42         [ 5]  635                     ldb      BIT_POS,u 
   023C 26 0C         [ 3]  636                     bne      bit_is_ready15 
                            637 ; load a new byte
   023E AE 40         [ 6]  638                     ldx      BYTE_POS,u 
   0240 E6 80         [ 6]  639                     ldb      ,x+ 
   0242 E7 43         [ 5]  640                     stb      CURRENT_DATA_BYTE,u 
   0244 AF 40         [ 6]  641                     stx      BYTE_POS,u 
   0246 C6 80         [ 2]  642                     ldb      #0x80 
   0248 E7 42         [ 5]  643                     stb      BIT_POS,u 
                            644  .globl bit_is_ready15
   024A                     645 bit_is_ready15: 
                            646 ; bit position correct here
                            647 ;
                            648 ; remember we use one bit now!
   024A 64 42         [ 7]  649                     lsr      BIT_POS,u 
                            650 ; is the bit at the current position set?
   024C E4 43         [ 5]  651                     andb     CURRENT_DATA_BYTE,u 
                            652 ;;;;;;;;;;;; GET_BIT_END
   024E 27 01         [ 3]  653                     beq      noBit2 
   0250 4C            [ 2]  654                     inca     
                            655  .globl noBit2
   0251                     656 noBit2: 
   0251 48            [ 2]  657                     lsla     
                            658  .globl reg6Bits
   0252                     659 reg6Bits: 
                            660 ; macro call ->                     read_one_bit_from_data  
                            661 ;;;;;;;;;;;; GET_BIT_START
   0252 E6 42         [ 5]  662                     ldb      BIT_POS,u 
   0254 26 0C         [ 3]  663                     bne      bit_is_ready16 
                            664 ; load a new byte
   0256 AE 40         [ 6]  665                     ldx      BYTE_POS,u 
   0258 E6 80         [ 6]  666                     ldb      ,x+ 
   025A E7 43         [ 5]  667                     stb      CURRENT_DATA_BYTE,u 
   025C AF 40         [ 6]  668                     stx      BYTE_POS,u 
   025E C6 80         [ 2]  669                     ldb      #0x80 
   0260 E7 42         [ 5]  670                     stb      BIT_POS,u 
                            671  .globl bit_is_ready16
   0262                     672 bit_is_ready16: 
                            673 ; bit position correct here
                            674 ;
                            675 ; remember we use one bit now!
   0262 64 42         [ 7]  676                     lsr      BIT_POS,u 
                            677 ; is the bit at the current position set?
   0264 E4 43         [ 5]  678                     andb     CURRENT_DATA_BYTE,u 
                            679 ;;;;;;;;;;;; GET_BIT_END
   0266 27 01         [ 3]  680                     beq      noBit3 
   0268 4C            [ 2]  681                     inca     
                            682  .globl noBit3
   0269                     683 noBit3: 
   0269 48            [ 2]  684                     lsla     
                            685  .globl reg5Bits
   026A                     686 reg5Bits: 
                            687 ; macro call ->                     read_one_bit_from_data  
                            688 ;;;;;;;;;;;; GET_BIT_START
   026A E6 42         [ 5]  689                     ldb      BIT_POS,u 
   026C 26 0C         [ 3]  690                     bne      bit_is_ready17 
                            691 ; load a new byte
   026E AE 40         [ 6]  692                     ldx      BYTE_POS,u 
   0270 E6 80         [ 6]  693                     ldb      ,x+ 
   0272 E7 43         [ 5]  694                     stb      CURRENT_DATA_BYTE,u 
   0274 AF 40         [ 6]  695                     stx      BYTE_POS,u 
   0276 C6 80         [ 2]  696                     ldb      #0x80 
   0278 E7 42         [ 5]  697                     stb      BIT_POS,u 
                            698  .globl bit_is_ready17
   027A                     699 bit_is_ready17: 
                            700 ; bit position correct here
                            701 ;
                            702 ; remember we use one bit now!
   027A 64 42         [ 7]  703                     lsr      BIT_POS,u 
                            704 ; is the bit at the current position set?
   027C E4 43         [ 5]  705                     andb     CURRENT_DATA_BYTE,u 
                            706 ;;;;;;;;;;;; GET_BIT_END
   027E 27 01         [ 3]  707                     beq      noBit4 
   0280 4C            [ 2]  708                     inca     
                            709  .globl noBit4
   0281                     710 noBit4: 
   0281 48            [ 2]  711                     lsla     
                            712  .globl reg4Bits
   0282                     713 reg4Bits: 
                            714 ; macro call ->                     read_one_bit_from_data  
                            715 ;;;;;;;;;;;; GET_BIT_START
   0282 E6 42         [ 5]  716                     ldb      BIT_POS,u 
   0284 26 0C         [ 3]  717                     bne      bit_is_ready18 
                            718 ; load a new byte
   0286 AE 40         [ 6]  719                     ldx      BYTE_POS,u 
   0288 E6 80         [ 6]  720                     ldb      ,x+ 
   028A E7 43         [ 5]  721                     stb      CURRENT_DATA_BYTE,u 
   028C AF 40         [ 6]  722                     stx      BYTE_POS,u 
   028E C6 80         [ 2]  723                     ldb      #0x80 
   0290 E7 42         [ 5]  724                     stb      BIT_POS,u 
                            725  .globl bit_is_ready18
   0292                     726 bit_is_ready18: 
                            727 ; bit position correct here
                            728 ;
                            729 ; remember we use one bit now!
   0292 64 42         [ 7]  730                     lsr      BIT_POS,u 
                            731 ; is the bit at the current position set?
   0294 E4 43         [ 5]  732                     andb     CURRENT_DATA_BYTE,u 
                            733 ;;;;;;;;;;;; GET_BIT_END
   0296 27 01         [ 3]  734                     beq      noBit5 
   0298 4C            [ 2]  735                     inca     
                            736  .globl noBit5
   0299                     737 noBit5: 
   0299 48            [ 2]  738                     lsla     
                            739 ; macro call ->                     read_one_bit_from_data  
                            740 ;;;;;;;;;;;; GET_BIT_START
   029A E6 42         [ 5]  741                     ldb      BIT_POS,u 
   029C 26 0C         [ 3]  742                     bne      bit_is_ready19 
                            743 ; load a new byte
   029E AE 40         [ 6]  744                     ldx      BYTE_POS,u 
   02A0 E6 80         [ 6]  745                     ldb      ,x+ 
   02A2 E7 43         [ 5]  746                     stb      CURRENT_DATA_BYTE,u 
   02A4 AF 40         [ 6]  747                     stx      BYTE_POS,u 
   02A6 C6 80         [ 2]  748                     ldb      #0x80 
   02A8 E7 42         [ 5]  749                     stb      BIT_POS,u 
                            750  .globl bit_is_ready19
   02AA                     751 bit_is_ready19: 
                            752 ; bit position correct here
                            753 ;
                            754 ; remember we use one bit now!
   02AA 64 42         [ 7]  755                     lsr      BIT_POS,u 
                            756 ; is the bit at the current position set?
   02AC E4 43         [ 5]  757                     andb     CURRENT_DATA_BYTE,u 
                            758 ;;;;;;;;;;;; GET_BIT_END
   02AE 27 01         [ 3]  759                     beq      noBit6 
   02B0 4C            [ 2]  760                     inca     
                            761  .globl noBit6
   02B1                     762 noBit6: 
   02B1 48            [ 2]  763                     lsla     
                            764 ; macro call ->                     read_one_bit_from_data  
                            765 ;;;;;;;;;;;; GET_BIT_START
   02B2 E6 42         [ 5]  766                     ldb      BIT_POS,u 
   02B4 26 0C         [ 3]  767                     bne      bit_is_ready20 
                            768 ; load a new byte
   02B6 AE 40         [ 6]  769                     ldx      BYTE_POS,u 
   02B8 E6 80         [ 6]  770                     ldb      ,x+ 
   02BA E7 43         [ 5]  771                     stb      CURRENT_DATA_BYTE,u 
   02BC AF 40         [ 6]  772                     stx      BYTE_POS,u 
   02BE C6 80         [ 2]  773                     ldb      #0x80 
   02C0 E7 42         [ 5]  774                     stb      BIT_POS,u 
                            775  .globl bit_is_ready20
   02C2                     776 bit_is_ready20: 
                            777 ; bit position correct here
                            778 ;
                            779 ; remember we use one bit now!
   02C2 64 42         [ 7]  780                     lsr      BIT_POS,u 
                            781 ; is the bit at the current position set?
   02C4 E4 43         [ 5]  782                     andb     CURRENT_DATA_BYTE,u 
                            783 ;;;;;;;;;;;; GET_BIT_END
   02C6 27 01         [ 3]  784                     beq      noBit7 
   02C8 4C            [ 2]  785                     inca     
                            786  .globl noBit7
   02C9                     787 noBit7: 
   02C9 48            [ 2]  788                     lsla     
                            789 ; macro call ->                     read_one_bit_from_data  
                            790 ;;;;;;;;;;;; GET_BIT_START
   02CA E6 42         [ 5]  791                     ldb      BIT_POS,u 
   02CC 26 0C         [ 3]  792                     bne      bit_is_ready21 
                            793 ; load a new byte
   02CE AE 40         [ 6]  794                     ldx      BYTE_POS,u 
   02D0 E6 80         [ 6]  795                     ldb      ,x+ 
   02D2 E7 43         [ 5]  796                     stb      CURRENT_DATA_BYTE,u 
   02D4 AF 40         [ 6]  797                     stx      BYTE_POS,u 
   02D6 C6 80         [ 2]  798                     ldb      #0x80 
   02D8 E7 42         [ 5]  799                     stb      BIT_POS,u 
                            800  .globl bit_is_ready21
   02DA                     801 bit_is_ready21: 
                            802 ; bit position correct here
                            803 ;
                            804 ; remember we use one bit now!
   02DA 64 42         [ 7]  805                     lsr      BIT_POS,u 
                            806 ; is the bit at the current position set?
   02DC E4 43         [ 5]  807                     andb     CURRENT_DATA_BYTE,u 
                            808 ;;;;;;;;;;;; GET_BIT_END
   02DE 27 01         [ 3]  809                     beq      noBit8 
   02E0 4C            [ 2]  810                     inca     
                            811  .globl noBit8
   02E1                     812 noBit8: 
   02E1 A7 44         [ 5]  813                     sta      CURRENT_REG_BYTE,u 
   02E3 7E 01 69      [ 4]  814                     jmp      done 
                            815 ;***************************************************************************
                            816 ;***************************************************************************
                            817  .globl init_ym_sound
   02E6                     818 init_ym_sound: 
   02E6 8E 00 0E      [ 3]  819                     ldx      #_ym_data_start               ; load start address of ram buffer for YM play 
   02E9 CC 00 B0      [ 3]  820                     ldd      #(STRUCT_LEN*REGS_MAX)             ; load length of buffer 
   02EC BD F5 48      [ 8]  821                     jsr      Clear_x_d                    ; clear buffer 
   02EF 7F 00 0C      [ 7]  822                     clr      _ym_regs_used                 ; count of registers that are used by the player - reset 
   02F2 10 AE C1      [ 9]  823                     ldy      ,u++                         ; first load start of all data to y 
   02F5 EC A4         [ 5]  824                     ldd      ,y                           ; load vbl_len to d 
   02F7 FD 00 06      [ 6]  825                     std      _ym_len                       ; and store it to len reset 
   02FA FD 00 08      [ 6]  826                     std      _ym_data_current              ; and store it to current data pointer 
   02FD E6 C0         [ 6]  827                     ldb      ,u+                          ; load number of next register to work on 
                            828  .globl nreg_init
   02FF                     829 nreg_init: 
   02FF 7C 00 0C      [ 7]  830                     inc      _ym_regs_used                 ; count the registers we actually use 
   0302 E7 0E         [ 5]  831                     stb      REG_USED,x                   ; and store the register of the current data 
   0304 10 AE C1      [ 9]  832                     ldy      ,u++                         ; load location of translation map to y 
   0307 10 AF 07      [ 7]  833                     sty      REG_PHRASE_MAP,x             ; and store it 
   030A 10 AE C1      [ 9]  834                     ldy      ,u++                         ; load location of phrases 
   030D 10 AF 0C      [ 7]  835                     sty      PHRASE_DEFINITION_START,x    ; and store it 
   0310 10 AE C1      [ 9]  836                     ldy      ,u++                         ; load location of RLE data 
   0313 10 AF 00      [ 7]  837                     sty      BYTE_POS,x                   ; and store it 
   0316 30 88 10      [ 5]  838                     leax     STRUCT_LEN,x                 ; add structure length to x 
   0319 E6 C0         [ 6]  839                     ldb      ,u+                          ; load number of next register to work on 
   031B 2A E2         [ 3]  840                     bpl      nreg_init                    ; if negative than we are done 
                            841  .globl regInitDone
   031D                     842 regInitDone: 
   031D FF 00 0A      [ 6]  843                     stu      _ym_name 
   0320 39            [ 5]  844                     rts      
                            845 ;***************************************************************************
                            846 ;***************************************************************************
ASxxxx Assembler V05.00  (Motorola 6809), page 1.
Hexidecimal [16-Bits]

Symbol Table

    .__.$$$.       =   2710 L   |     .__.ABS.       =   0000 G
    .__.CPU.       =   0000 L   |     .__.H$L.       =   0001 L
  2 A$ymPlayerOpti     0018 GR  |   2 A$ymPlayerOpti     001A GR
  2 A$ymPlayerOpti     001C GR  |   2 A$ymPlayerOpti     001E GR
  2 A$ymPlayerOpti     0020 GR  |   2 A$ymPlayerOpti     0022 GR
  2 A$ymPlayerOpti     0024 GR  |   2 A$ymPlayerOpti     0026 GR
  2 A$ymPlayerOpti     0028 GR  |   2 A$ymPlayerOpti     002A GR
  2 A$ymPlayerOpti     002C GR  |   2 A$ymPlayerOpti     002D GR
  2 A$ymPlayerOpti     002F GR  |   2 A$ymPlayerOpti     0031 GR
  2 A$ymPlayerOpti     0033 GR  |   2 A$ymPlayerOpti     0035 GR
  2 A$ymPlayerOpti     0037 GR  |   2 A$ymPlayerOpti     0039 GR
  2 A$ymPlayerOpti     003B GR  |   2 A$ymPlayerOpti     003D GR
  2 A$ymPlayerOpti     003F GR  |   2 A$ymPlayerOpti     0041 GR
  2 A$ymPlayerOpti     0043 GR  |   2 A$ymPlayerOpti     0044 GR
  2 A$ymPlayerOpti     0045 GR  |   2 A$ymPlayerOpti     0047 GR
  2 A$ymPlayerOpti     0049 GR  |   2 A$ymPlayerOpti     004B GR
  2 A$ymPlayerOpti     004D GR  |   2 A$ymPlayerOpti     004F GR
  2 A$ymPlayerOpti     0051 GR  |   2 A$ymPlayerOpti     0053 GR
  2 A$ymPlayerOpti     0055 GR  |   2 A$ymPlayerOpti     0057 GR
  2 A$ymPlayerOpti     0059 GR  |   2 A$ymPlayerOpti     005B GR
  2 A$ymPlayerOpti     005C GR  |   2 A$ymPlayerOpti     005D GR
  2 A$ymPlayerOpti     005F GR  |   2 A$ymPlayerOpti     0061 GR
  2 A$ymPlayerOpti     0063 GR  |   2 A$ymPlayerOpti     0065 GR
  2 A$ymPlayerOpti     0067 GR  |   2 A$ymPlayerOpti     0069 GR
  2 A$ymPlayerOpti     006B GR  |   2 A$ymPlayerOpti     006D GR
  2 A$ymPlayerOpti     006F GR  |   2 A$ymPlayerOpti     0071 GR
  2 A$ymPlayerOpti     0073 GR  |   2 A$ymPlayerOpti     0074 GR
  2 A$ymPlayerOpti     0076 GR  |   2 A$ymPlayerOpti     007A GR
  2 A$ymPlayerOpti     007B GR  |   2 A$ymPlayerOpti     007D GR
  2 A$ymPlayerOpti     007F GR  |   2 A$ymPlayerOpti     0081 GR
  2 A$ymPlayerOpti     0083 GR  |   2 A$ymPlayerOpti     0085 GR
  2 A$ymPlayerOpti     0087 GR  |   2 A$ymPlayerOpti     0089 GR
  2 A$ymPlayerOpti     008B GR  |   2 A$ymPlayerOpti     008D GR
  2 A$ymPlayerOpti     008F GR  |   2 A$ymPlayerOpti     0091 GR
  2 A$ymPlayerOpti     0092 GR  |   2 A$ymPlayerOpti     0094 GR
  2 A$ymPlayerOpti     0098 GR  |   2 A$ymPlayerOpti     0099 GR
  2 A$ymPlayerOpti     009B GR  |   2 A$ymPlayerOpti     009D GR
  2 A$ymPlayerOpti     009F GR  |   2 A$ymPlayerOpti     00A1 GR
  2 A$ymPlayerOpti     00A3 GR  |   2 A$ymPlayerOpti     00A5 GR
  2 A$ymPlayerOpti     00A7 GR  |   2 A$ymPlayerOpti     00A9 GR
  2 A$ymPlayerOpti     00AB GR  |   2 A$ymPlayerOpti     00AD GR
  2 A$ymPlayerOpti     00AF GR  |   2 A$ymPlayerOpti     00B0 GR
  2 A$ymPlayerOpti     00B2 GR  |   2 A$ymPlayerOpti     00B4 GR
  2 A$ymPlayerOpti     00B5 GR  |   2 A$ymPlayerOpti     00B7 GR
  2 A$ymPlayerOpti     00B9 GR  |   2 A$ymPlayerOpti     00BB GR
  2 A$ymPlayerOpti     00BD GR  |   2 A$ymPlayerOpti     00BF GR
  2 A$ymPlayerOpti     00C1 GR  |   2 A$ymPlayerOpti     00C3 GR
  2 A$ymPlayerOpti     00C5 GR  |   2 A$ymPlayerOpti     00C7 GR
  2 A$ymPlayerOpti     00C9 GR  |   2 A$ymPlayerOpti     00CB GR
  2 A$ymPlayerOpti     00CC GR  |   2 A$ymPlayerOpti     00CE GR
  2 A$ymPlayerOpti     00D0 GR  |   2 A$ymPlayerOpti     00D1 GR
  2 A$ymPlayerOpti     00D3 GR  |   2 A$ymPlayerOpti     00D5 GR
  2 A$ymPlayerOpti     00D7 GR  |   2 A$ymPlayerOpti     00D9 GR
  2 A$ymPlayerOpti     00DB GR  |   2 A$ymPlayerOpti     00DD GR
  2 A$ymPlayerOpti     00DF GR  |   2 A$ymPlayerOpti     00E1 GR
  2 A$ymPlayerOpti     00E3 GR  |   2 A$ymPlayerOpti     00E5 GR
  2 A$ymPlayerOpti     00E7 GR  |   2 A$ymPlayerOpti     00E8 GR
  2 A$ymPlayerOpti     00EA GR  |   2 A$ymPlayerOpti     00EC GR
  2 A$ymPlayerOpti     00ED GR  |   2 A$ymPlayerOpti     00EF GR
  2 A$ymPlayerOpti     00F1 GR  |   2 A$ymPlayerOpti     00F3 GR
  2 A$ymPlayerOpti     00F5 GR  |   2 A$ymPlayerOpti     00F7 GR
  2 A$ymPlayerOpti     00F9 GR  |   2 A$ymPlayerOpti     00FB GR
  2 A$ymPlayerOpti     00FD GR  |   2 A$ymPlayerOpti     00FF GR
  2 A$ymPlayerOpti     0101 GR  |   2 A$ymPlayerOpti     0103 GR
  2 A$ymPlayerOpti     0104 GR  |   2 A$ymPlayerOpti     0106 GR
  2 A$ymPlayerOpti     0108 GR  |   2 A$ymPlayerOpti     010A GR
  2 A$ymPlayerOpti     010C GR  |   2 A$ymPlayerOpti     010D GR
  2 A$ymPlayerOpti     010E GR  |   2 A$ymPlayerOpti     0110 GR
  2 A$ymPlayerOpti     0112 GR  |   2 A$ymPlayerOpti     0114 GR
  2 A$ymPlayerOpti     0116 GR  |   2 A$ymPlayerOpti     0118 GR
  2 A$ymPlayerOpti     011A GR  |   2 A$ymPlayerOpti     011C GR
  2 A$ymPlayerOpti     011E GR  |   2 A$ymPlayerOpti     0120 GR
  2 A$ymPlayerOpti     0122 GR  |   2 A$ymPlayerOpti     0124 GR
  2 A$ymPlayerOpti     0126 GR  |   2 A$ymPlayerOpti     0128 GR
  2 A$ymPlayerOpti     012A GR  |   2 A$ymPlayerOpti     012C GR
  2 A$ymPlayerOpti     012E GR  |   2 A$ymPlayerOpti     0130 GR
  2 A$ymPlayerOpti     0132 GR  |   2 A$ymPlayerOpti     0134 GR
  2 A$ymPlayerOpti     0136 GR  |   2 A$ymPlayerOpti     0139 GR
  2 A$ymPlayerOpti     013B GR  |   2 A$ymPlayerOpti     013E GR
  2 A$ymPlayerOpti     0141 GR  |   2 A$ymPlayerOpti     0144 GR
  2 A$ymPlayerOpti     0147 GR  |   2 A$ymPlayerOpti     014A GR
  2 A$ymPlayerOpti     014C GR  |   2 A$ymPlayerOpti     014E GR
  2 A$ymPlayerOpti     0150 GR  |   2 A$ymPlayerOpti     0152 GR
  2 A$ymPlayerOpti     0154 GR  |   2 A$ymPlayerOpti     0156 GR
  2 A$ymPlayerOpti     0158 GR  |   2 A$ymPlayerOpti     015A GR
  2 A$ymPlayerOpti     015C GR  |   2 A$ymPlayerOpti     015E GR
  2 A$ymPlayerOpti     0160 GR  |   2 A$ymPlayerOpti     0162 GR
  2 A$ymPlayerOpti     0164 GR  |   2 A$ymPlayerOpti     0167 GR
  2 A$ymPlayerOpti     0169 GR  |   2 A$ymPlayerOpti     016B GR
  2 A$ymPlayerOpti     016D GR  |   2 A$ymPlayerOpti     0171 GR
  2 A$ymPlayerOpti     0172 GR  |   2 A$ymPlayerOpti     0174 GR
  2 A$ymPlayerOpti     0177 GR  |   2 A$ymPlayerOpti     017A GR
  2 A$ymPlayerOpti     017C GR  |   2 A$ymPlayerOpti     017D GR
  2 A$ymPlayerOpti     017F GR  |   2 A$ymPlayerOpti     0181 GR
  2 A$ymPlayerOpti     0183 GR  |   2 A$ymPlayerOpti     0185 GR
  2 A$ymPlayerOpti     0187 GR  |   2 A$ymPlayerOpti     0189 GR
  2 A$ymPlayerOpti     018B GR  |   2 A$ymPlayerOpti     018D GR
  2 A$ymPlayerOpti     018F GR  |   2 A$ymPlayerOpti     0191 GR
  2 A$ymPlayerOpti     0195 GR  |   2 A$ymPlayerOpti     0197 GR
  2 A$ymPlayerOpti     0199 GR  |   2 A$ymPlayerOpti     019B GR
  2 A$ymPlayerOpti     019D GR  |   2 A$ymPlayerOpti     019F GR
  2 A$ymPlayerOpti     01A1 GR  |   2 A$ymPlayerOpti     01A3 GR
  2 A$ymPlayerOpti     01A5 GR  |   2 A$ymPlayerOpti     01A7 GR
  2 A$ymPlayerOpti     01A9 GR  |   2 A$ymPlayerOpti     01AB GR
  2 A$ymPlayerOpti     01AD GR  |   2 A$ymPlayerOpti     01B1 GR
  2 A$ymPlayerOpti     01B4 GR  |   2 A$ymPlayerOpti     01B7 GR
  2 A$ymPlayerOpti     01B8 GR  |   2 A$ymPlayerOpti     01BB GR
  2 A$ymPlayerOpti     01BE GR  |   2 A$ymPlayerOpti     01BF GR
  2 A$ymPlayerOpti     01C1 GR  |   2 A$ymPlayerOpti     01C3 GR
  2 A$ymPlayerOpti     01C5 GR  |   2 A$ymPlayerOpti     01C7 GR
  2 A$ymPlayerOpti     01C9 GR  |   2 A$ymPlayerOpti     01CB GR
  2 A$ymPlayerOpti     01CD GR  |   2 A$ymPlayerOpti     01CF GR
  2 A$ymPlayerOpti     01D1 GR  |   2 A$ymPlayerOpti     01D3 GR
  2 A$ymPlayerOpti     01D5 GR  |   2 A$ymPlayerOpti     01D8 GR
  2 A$ymPlayerOpti     01DA GR  |   2 A$ymPlayerOpti     01DC GR
  2 A$ymPlayerOpti     01DE GR  |   2 A$ymPlayerOpti     01E0 GR
  2 A$ymPlayerOpti     01E2 GR  |   2 A$ymPlayerOpti     01E4 GR
  2 A$ymPlayerOpti     01E6 GR  |   2 A$ymPlayerOpti     01E8 GR
  2 A$ymPlayerOpti     01EB GR  |   2 A$ymPlayerOpti     01ED GR
  2 A$ymPlayerOpti     01EF GR  |   2 A$ymPlayerOpti     01F1 GR
  2 A$ymPlayerOpti     01F5 GR  |   2 A$ymPlayerOpti     01F7 GR
  2 A$ymPlayerOpti     01F8 GR  |   2 A$ymPlayerOpti     01FA GR
  2 A$ymPlayerOpti     01FC GR  |   2 A$ymPlayerOpti     01FF GR
  2 A$ymPlayerOpti     0201 GR  |   2 A$ymPlayerOpti     0204 GR
  2 A$ymPlayerOpti     0206 GR  |   2 A$ymPlayerOpti     0207 GR
  2 A$ymPlayerOpti     0209 GR  |   2 A$ymPlayerOpti     020B GR
  2 A$ymPlayerOpti     020E GR  |   2 A$ymPlayerOpti     0210 GR
  2 A$ymPlayerOpti     0212 GR  |   2 A$ymPlayerOpti     0214 GR
  2 A$ymPlayerOpti     0216 GR  |   2 A$ymPlayerOpti     0218 GR
  2 A$ymPlayerOpti     021A GR  |   2 A$ymPlayerOpti     021C GR
  2 A$ymPlayerOpti     021E GR  |   2 A$ymPlayerOpti     0220 GR
  2 A$ymPlayerOpti     0222 GR  |   2 A$ymPlayerOpti     0224 GR
  2 A$ymPlayerOpti     0226 GR  |   2 A$ymPlayerOpti     0228 GR
  2 A$ymPlayerOpti     022A GR  |   2 A$ymPlayerOpti     022C GR
  2 A$ymPlayerOpti     022E GR  |   2 A$ymPlayerOpti     0230 GR
  2 A$ymPlayerOpti     0232 GR  |   2 A$ymPlayerOpti     0234 GR
  2 A$ymPlayerOpti     0236 GR  |   2 A$ymPlayerOpti     0238 GR
  2 A$ymPlayerOpti     0239 GR  |   2 A$ymPlayerOpti     023A GR
  2 A$ymPlayerOpti     023C GR  |   2 A$ymPlayerOpti     023E GR
  2 A$ymPlayerOpti     0240 GR  |   2 A$ymPlayerOpti     0242 GR
  2 A$ymPlayerOpti     0244 GR  |   2 A$ymPlayerOpti     0246 GR
  2 A$ymPlayerOpti     0248 GR  |   2 A$ymPlayerOpti     024A GR
  2 A$ymPlayerOpti     024C GR  |   2 A$ymPlayerOpti     024E GR
  2 A$ymPlayerOpti     0250 GR  |   2 A$ymPlayerOpti     0251 GR
  2 A$ymPlayerOpti     0252 GR  |   2 A$ymPlayerOpti     0254 GR
  2 A$ymPlayerOpti     0256 GR  |   2 A$ymPlayerOpti     0258 GR
  2 A$ymPlayerOpti     025A GR  |   2 A$ymPlayerOpti     025C GR
  2 A$ymPlayerOpti     025E GR  |   2 A$ymPlayerOpti     0260 GR
  2 A$ymPlayerOpti     0262 GR  |   2 A$ymPlayerOpti     0264 GR
  2 A$ymPlayerOpti     0266 GR  |   2 A$ymPlayerOpti     0268 GR
  2 A$ymPlayerOpti     0269 GR  |   2 A$ymPlayerOpti     026A GR
  2 A$ymPlayerOpti     026C GR  |   2 A$ymPlayerOpti     026E GR
  2 A$ymPlayerOpti     0270 GR  |   2 A$ymPlayerOpti     0272 GR
  2 A$ymPlayerOpti     0274 GR  |   2 A$ymPlayerOpti     0276 GR
  2 A$ymPlayerOpti     0278 GR  |   2 A$ymPlayerOpti     027A GR
  2 A$ymPlayerOpti     027C GR  |   2 A$ymPlayerOpti     027E GR
  2 A$ymPlayerOpti     0280 GR  |   2 A$ymPlayerOpti     0281 GR
  2 A$ymPlayerOpti     0282 GR  |   2 A$ymPlayerOpti     0284 GR
  2 A$ymPlayerOpti     0286 GR  |   2 A$ymPlayerOpti     0288 GR
  2 A$ymPlayerOpti     028A GR  |   2 A$ymPlayerOpti     028C GR
  2 A$ymPlayerOpti     028E GR  |   2 A$ymPlayerOpti     0290 GR
  2 A$ymPlayerOpti     0292 GR  |   2 A$ymPlayerOpti     0294 GR
  2 A$ymPlayerOpti     0296 GR  |   2 A$ymPlayerOpti     0298 GR
  2 A$ymPlayerOpti     0299 GR  |   2 A$ymPlayerOpti     029A GR
  2 A$ymPlayerOpti     029C GR  |   2 A$ymPlayerOpti     029E GR
  2 A$ymPlayerOpti     02A0 GR  |   2 A$ymPlayerOpti     02A2 GR
  2 A$ymPlayerOpti     02A4 GR  |   2 A$ymPlayerOpti     02A6 GR
  2 A$ymPlayerOpti     02A8 GR  |   2 A$ymPlayerOpti     02AA GR
  2 A$ymPlayerOpti     02AC GR  |   2 A$ymPlayerOpti     02AE GR
  2 A$ymPlayerOpti     02B0 GR  |   2 A$ymPlayerOpti     02B1 GR
  2 A$ymPlayerOpti     02B2 GR  |   2 A$ymPlayerOpti     02B4 GR
  2 A$ymPlayerOpti     02B6 GR  |   2 A$ymPlayerOpti     02B8 GR
  2 A$ymPlayerOpti     02BA GR  |   2 A$ymPlayerOpti     02BC GR
  2 A$ymPlayerOpti     02BE GR  |   2 A$ymPlayerOpti     02C0 GR
  2 A$ymPlayerOpti     02C2 GR  |   2 A$ymPlayerOpti     02C4 GR
  2 A$ymPlayerOpti     02C6 GR  |   2 A$ymPlayerOpti     02C8 GR
  2 A$ymPlayerOpti     02C9 GR  |   2 A$ymPlayerOpti     02CA GR
  2 A$ymPlayerOpti     02CC GR  |   2 A$ymPlayerOpti     02CE GR
  2 A$ymPlayerOpti     02D0 GR  |   2 A$ymPlayerOpti     02D2 GR
  2 A$ymPlayerOpti     02D4 GR  |   2 A$ymPlayerOpti     02D6 GR
  2 A$ymPlayerOpti     02D8 GR  |   2 A$ymPlayerOpti     02DA GR
  2 A$ymPlayerOpti     02DC GR  |   2 A$ymPlayerOpti     02DE GR
  2 A$ymPlayerOpti     02E0 GR  |   2 A$ymPlayerOpti     02E1 GR
  2 A$ymPlayerOpti     02E3 GR  |   2 A$ymPlayerOpti     02E6 GR
  2 A$ymPlayerOpti     02E9 GR  |   2 A$ymPlayerOpti     02EC GR
  2 A$ymPlayerOpti     02EF GR  |   2 A$ymPlayerOpti     02F2 GR
  2 A$ymPlayerOpti     02F5 GR  |   2 A$ymPlayerOpti     02F7 GR
  2 A$ymPlayerOpti     02FA GR  |   2 A$ymPlayerOpti     02FD GR
  2 A$ymPlayerOpti     02FF GR  |   2 A$ymPlayerOpti     0302 GR
  2 A$ymPlayerOpti     0304 GR  |   2 A$ymPlayerOpti     0307 GR
  2 A$ymPlayerOpti     030A GR  |   2 A$ymPlayerOpti     030D GR
  2 A$ymPlayerOpti     0310 GR  |   2 A$ymPlayerOpti     0313 GR
  2 A$ymPlayerOpti     0316 GR  |   2 A$ymPlayerOpti     0319 GR
  2 A$ymPlayerOpti     031B GR  |   2 A$ymPlayerOpti     031D GR
  2 A$ymPlayerOpti     0320 GR  |   2 A$ymPlayerOpti     0010 GR
  2 A$ymPlayerOpti     0011 GR  |   2 A$ymPlayerOpti     0012 GR
  2 A$ymPlayerOpti     0014 GR  |   2 A$ymPlayerOpti     0016 GR
    BIT_POS        =   0002     |     BYTE_POS       =   0000 
    CURRENT_DATA_B =   0003     |     CURRENT_IS_PHR =   0009 
    CURRENT_PHRASE =   000F     |     CURRENT_PLACE_ =   000B 
    CURRENT_REG_BY =   0004     |     CURRENT_RLE_CO =   0005 
    Clear_x_d      =   F548     |     INFO_END       =   0010 
    INFO_START     =   0000     |     PHRASE_DEFINIT =   000C 
    REGS_MAX       =   000B     |     REG_PHRASE_MAP =   0007 
    REG_USED       =   000E     |     STRUCT_LEN     =   0010 
    Sound_Byte     =   F256     |     VIA_port_a     =   D001 
    VIA_port_b     =   D000     |     Vec_Music_Work =   C83F 
  3 _calc_bits         0005 GR  |   3 _calc_coder        0004 GR
  3 _cregister         0000 GR  |   2 _reg_max_data      0000 GR
  3 _temp              0001 GR  |   3 _temp2             0002 GR
  3 _temp3             0003 GR  |   3 _ym_data_curre     0008 GR
  3 _ym_data_start     000E GR  |   3 _ym_len            0006 GR
  3 _ym_name           000A GR  |   3 _ym_regs_count     000D GR
  3 _ym_regs_used      000C GR  |   2 bitLenFound        01E6 GR
  2 bit_is_ready1      0022 GR  |   2 bit_is_ready10     0124 GR
  2 bit_is_ready11     018D GR  |   2 bit_is_ready12     01A7 GR
  2 bit_is_ready13     01CF GR  |   2 bit_is_ready14     0232 GR
  2 bit_is_ready15     024A GR  |   2 bit_is_ready16     0262 GR
  2 bit_is_ready17     027A GR  |   2 bit_is_ready18     0292 GR
  2 bit_is_ready19     02AA GR  |   2 bit_is_ready2      003D GR
  2 bit_is_ready20     02C2 GR  |   2 bit_is_ready21     02DA GR
  2 bit_is_ready3      0055 GR  |   2 bit_is_ready4      006D GR
  2 bit_is_ready5      008B GR  |   2 bit_is_ready6      00A9 GR
  2 bit_is_ready7      00C5 GR  |   2 bit_is_ready8      00E1 GR
  2 bit_is_ready9      00FD GR  |   2 code_bit_notse     01D8 GR
  2 currentPharseN     0169 GR  |   2 dechifer           0197 GR
  2 directByte         01FF GR  |   2 doNotWriteReg1     0174 GR
  2 do_ym_sound        0136 GR  |   2 done               0169 GR
  2 getCurrentRegB     014A GR  |   2 getNextCodeBit     01BB GR
  2 inPhraseOut        0156 GR  |   2 increaseCodeBi     01DE GR
  2 init_ym_sound      02E6 GR  |   2 moreBits           0011 GR
  2 next_reg           014A GR  |   2 noBit1             0239 GR
  2 noBit2             0251 GR  |   2 noBit3             0269 GR
  2 noBit4             0281 GR  |   2 noBit5             0299 GR
  2 noBit6             02B1 GR  |   2 noBit7             02C9 GR
  2 noBit8             02E1 GR  |   2 noValidByte        017D GR
  2 no_carry           0112 GR  |   2 not_in_phrase      0164 GR
  2 nreg_init          02FF GR  |   2 read16bitConti     010A GR
  2 reg4Bits           0282 GR  |   2 reg5Bits           026A GR
  2 reg6Bits           0252 GR  |   2 reg8Bits           0222 GR
  2 regInitDone        031D GR  |   2 rle16bitdone       0130 GR
  2 rle8bitdone        0132 GR  |   2 rleCounterBit0     0044 GR
  2 rleCounterBit1     005C GR  |   2 rleCounterBit2     0074 GR
  2 rleCounterBit3     0092 GR  |   2 rleCounterBit4     00B0 GR
  2 rleCounterBit5     00CC GR  |   2 rleCounterBit6     00E8 GR
  2 rleCounterBit7     0104 GR  |   2 rleCounterBitX     012C GR
  2 rleEncodedData     0010 GR  |   2 testNextPhrase     01D8 GR
  2 ymsodone           017C GR

ASxxxx Assembler V05.00  (Motorola 6809), page 2.
Hexidecimal [16-Bits]

Area Table

[_CSEG]
   0 _CODE            size    0   flags C080
   2 .text            size  321   flags  100
   3 .bss             size   BE   flags    0
[_DSEG]
   1 _DATA            size    0   flags C0C0

