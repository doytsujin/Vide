AS09 Assembler for M6809/H6309 [1.11].  Copyright 1994-96, Frank A. Vorstenbosch                                                                                                              Page    1
---------------------------------------------------------------------------------------------- BIOS.ASM -----------------------------------------------------------------------------------------------

-------------------------------------------------------------------------------------------- Symbol Table ---------------------------------------------------------------------------------------------

              Symbol   Value        Decimal

             Abs_a_b : $f584          62852
               Abs_b : $f58b          62859
         Add_Score_a : $f85e          63582
         Add_Score_d : $f87c          63612
           Bitmask_a : $f57e          62846
           Bit_Masks : $f9dc          63964
          Char_Table : $f9f4          63988
      Char_Table_End : $fbd4          64468
           Check0Ref : $f34f          62287
        Clear_C8_RAM : $f542          62786
         Clear_Score : $f84f          63567
         Clear_Sound : $f272          62066
           Clear_x_b : $f53f          62783
         Clear_x_b_a : $f552          62802
        Clear_x_b_80 : $f550          62800
           Clear_x_d : $f548          62792
         Clear_x_256 : $f545          62789
       Compare_Score : $f8c7          63687
       Copyright_Len : $000b             11
       Copyright_Str : $f101          61697
        Dec_Counters : $f563          62819
      Dec_3_Counters : $f55a          62810
      Dec_6_Counters : $f55e          62814
             Delay_b : $f57a          62842
           Delay_RTS : $f57d          62845
             Delay_0 : $f579          62841
             Delay_1 : $f575          62837
             Delay_2 : $f571          62833
             Delay_3 : $f56d          62829
               DFC2C : $fc2c          64556
               DFC24 : $fc24          64548
               DFC6D : $fc6d          64621
               DFDC3 : $fdc3          64963
               DFDD3 : $fdd3          64979
               DFD1D : $fd1d          64797
               DFD69 : $fd69          64873
               DFD79 : $fd79          64889
               DFD81 : $fd81          64897
               DFEB2 : $feb2          65202
               DFEB6 : $feb6          65206
               DFEC6 : $fec6          65222
               DFEE8 : $fee8          65256
               DFEF8 : $fef8          65272
               DFE28 : $fe28          65064
               DFE38 : $fe38          65080
               DFE66 : $fe66          65126
               DFE76 : $fe76          65142
               DFF16 : $ff16          65302
               DFF26 : $ff26          65318
               DFF44 : $ff44          65348
               DFF62 : $ff62          65378
               DFF7A : $ff7a          65402
               DFF8F : $ff8f          65423
               DF0FD : $f0fd          61693
      Display_Option : $f835          63541
               Dot_d : $f2c3          62147
            Dot_here : $f2c5          62149
              Dot_ix : $f2c1          62145
            Dot_ix_b : $f2be          62142
            Dot_List : $f2d5          62165
      Dot_List_Reset : $f2de          62174
            Do_Sound : $f289          62089
          Do_Sound_x : $f28c          62092
            DP_to_C8 : $f1af          61871
            DP_to_D0 : $f1aa          61866
        Draw_Grid_VL : $ff9f          65439
         Draw_Line_d : $f3df          62431
         Draw_Pat_VL : $f437          62519
       Draw_Pat_VL_a : $f434          62516
       Draw_Pat_VL_d : $f439          62521
             Draw_VL : $f3dd          62429
            Draw_VLc : $f3ce          62414
           Draw_VLcs : $f3d6          62422
            Draw_VLp : $f410          62480
          Draw_VLp_b : $f40e          62478
         Draw_VLp_FF : $f404          62468
      Draw_VLp_scale : $f40c          62476
         Draw_VLp_7F : $f408          62472
           Draw_VL_a : $f3da          62426
          Draw_VL_ab : $f3d8          62424
           Draw_VL_b : $f3d2          62418
        Draw_VL_mode : $f46e          62574
       Explosion_Snd : $f92e          63790
          Freq_Table : $fc8d          64653
            Game_Str : $f79f          63391
        Get_Rise_Idx : $f5d9          62937
         Get_Run_Idx : $f5db          62939
              here__ : $f10c          61708
           INCLUDE_I : $0001              1
          Init_Music : $f68d          63117
      Init_Music_Buf : $f533          62771
      Init_Music_chk : $f687          63111
      Init_Music_dft : $f692          63122
             Init_OS : $f18b          61835
         Init_OS_RAM : $f164          61796
            Init_VIA : $f14c          61772
         Intensity_a : $f2ab          62123
        Intensity_1F : $f29d          62109
        Intensity_3F : $f2a1          62113
        Intensity_5F : $f2a5          62117
        Intensity_7F : $f2a9          62121
         Intro_Boxes : $f0e9          61673
         Intro_Music : $fd0d          64781
          Joy_Analog : $f1f5          61941
         Joy_Digital : $f1f8          61944
               LFFAB : $ffab          65451
               LFFAE : $ffae          65454
               LFFA3 : $ffa3          65443
               LF0A4 : $f0a4          61604
               LF0D2 : $f0d2          61650
               LF01C : $f01c          61468
               LF029 : $f029          61481
               LF052 : $f052          61522
               LF058 : $f058          61528
               LF084 : $f084          61572
               LF09E : $f09e          61598
               LF092 : $f092          61586
               LF097 : $f097          61591
               LF1EA : $f1ea          61930
               LF1FB : $f1fb          61947
               LF1FF : $f1ff          61951
               LF173 : $f173          61811
               LF19E : $f19e          61854
               LF2CC : $f2cc          62156
               LF2D2 : $f2d2          62162
               LF20B : $f20b          61963
               LF213 : $f213          61971
               LF22D : $f22d          61997
               LF23A : $f23a          62010
               LF235 : $f235          62005
               LF236 : $f236          62006
               LF24C : $f24c          62028
               LF240 : $f240          62016
               LF275 : $f275          62069
               LF282 : $f282          62082
               LF291 : $f291          62097
               LF299 : $f299          62105
               LF3A3 : $f3a3          62371
               LF3ED : $f3ed          62445
               LF3F4 : $f3f4          62452
               LF318 : $f318          62232
               LF33B : $f33b          62267
               LF33D : $f33d          62269
               LF341 : $f341          62273
               LF345 : $f345          62277
           LF36A_RTS : $f36a          62314
               LF383 : $f383          62339
               LF4A5 : $f4a5          62629
               LF4CB : $f4cb          62667
               LF4C7 : $f4c7          62663
               LF4EB : $f4eb          62699
               LF425 : $f425          62501
               LF433 : $f433          62515
               LF45C : $f45c          62556
               LF459 : $f459          62553
               LF47E : $f47e          62590
               LF476 : $f476          62582
               LF48D : $f48d          62605
               LF485 : $f485          62597
               LF5B0 : $f5b0          62896
               LF5B2 : $f5b2          62898
               LF5D0 : $f5d0          62928
               LF5D3 : $f5d3          62931
               LF5EC : $f5ec          62956
               LF5E5 : $f5e5          62949
               LF50A : $f50a          62730
               LF51A : $f51a          62746
               LF51D : $f51d          62749
               LF560 : $f560          62816
               LF569 : $f569          62825
               LF592 : $f592          62866
               LF6B3 : $f6b3          63155
               LF6B8 : $f6b8          63160
               LF6CA : $f6ca          63178
               LF6C0 : $f6c0          63168
               LF6D2 : $f6d2          63186
               LF6EA : $f6ea          63210
               LF6EC : $f6ec          63212
               LF6E3 : $f6e3          63203
               LF635 : $f635          63029
               LF637 : $f637          63031
               LF66F : $f66f          63087
               LF665 : $f665          63077
               LF67E : $f67e          63102
               LF676 : $f676          63094
               LF679 : $f679          63097
               LF686 : $f686          63110
               LF7B1 : $f7b1          63409
               LF7B6 : $f7b6          63414
               LF7C5 : $f7c5          63429
               LF7F1 : $f7f1          63473
               LF712 : $f712          63250
               LF735 : $f735          63285
               LF74E : $f74e          63310
               LF748 : $f748          63304
               LF759 : $f759          63321
               LF76D : $f76d          63341
               LF766 : $f766          63334
               LF778 : $f778          63352
               LF78C : $f78c          63372
               LF788 : $f788          63368
           LF793_RTS : $f793          63379
               LF8AE : $f8ae          63662
               LF8A5 : $f8a5          63653
               LF8CA : $f8ca          63690
               LF8C6 : $f8c6          63686
               LF8DE : $f8de          63710
               LF8D5 : $f8d5          63701
               LF8D6 : $f8d6          63702
               LF8EF : $f8ef          63727
               LF8E4 : $f8e4          63716
               LF80C : $f80c          63500
               LF810 : $f810          63504
               LF82A : $f82a          63530
               LF82C : $f82c          63532
               LF821 : $f821          63521
               LF84E : $f84e          63566
               LF86D : $f86d          63597
               LF861 : $f861          63585
               LF878 : $f878          63608
               LF88F : $f88f          63631
               LF882 : $f882          63618
               LF895 : $f895          63637
               LF897 : $f897          63639
               LF9BC : $f9bc          63932
               LF9CA : $f9ca          63946
               LF9CF : $f9cf          63951
               LF9C2 : $f9c2          63938
           LF9C9_RTS : $f9c9          63945
           LF9DB_RTS : $f9db          63963
               LF90F : $f90f          63759
               LF903 : $f903          63747
               LF906 : $f906          63750
               LF91B : $f91b          63771
               LF92A : $f92a          63786
               LF928 : $f928          63784
               LF95B : $f95b          63835
               LF968 : $f968          63848
               LF97B : $f97b          63867
               LF97D : $f97d          63869
               LF98F : $f98f          63887
               LF987 : $f987          63879
               LF99E : $f99e          63902
               LF991 : $f991          63889
               LF997 : $f997          63895
            Moveto_d : $f312          62226
         Moveto_d_7F : $f2fc          62204
           Moveto_ix : $f310          62224
         Moveto_ix_b : $f30e          62222
        Moveto_ix_FF : $f308          62216
        Moveto_ix_7F : $f30c          62220
         Moveto_x_7F : $f2f2          62194
          Move_Mem_a : $f683          63107
        Move_Mem_a_1 : $f67f          63103
         Mov_Draw_VL : $f3bc          62396
       Mov_Draw_VLcs : $f3b5          62389
      Mov_Draw_VLc_a : $f3ad          62381
       Mov_Draw_VL_a : $f3b9          62393
      Mov_Draw_VL_ab : $f3b7          62391
       Mov_Draw_VL_b : $f3b1          62385
       Mov_Draw_VL_d : $f3be          62398
       Music_Table_1 : $f9e4          63972
       Music_Table_2 : $f9ea          63978
      New_High_Score : $f8d8          63704
             Obj_Hit : $f8ff          63743
        Obj_Will_Hit : $f8f3          63731
      Obj_Will_Hit_u : $f8e5          63717
          Player_Str : $f794          63380
          Print_List : $f38a          62346
      Print_List_Chk : $f38c          62348
       Print_List_hw : $f385          62341
         Print_Ships : $f393          62355
       Print_Ships_x : $f391          62353
           Print_Str : $f495          62613
         Print_Str_d : $f37a          62330
      Print_Str_hwyx : $f373          62323
        Print_Str_yx : $f378          62328
              Random : $f517          62743
            Random_3 : $f511          62737
           Read_Btns : $f1ba          61882
      Read_Btns_Mask : $f1b4          61876
         Recalibrate : $f2e6          62182
        Recal_Points : $f9f0          63984
           Reset0Int : $f36b          62315
           Reset0Ref : $f354          62292
        Reset0Ref_D0 : $f34a          62282
           Reset_Pen : $f35b          62299
      Rise_Run_Angle : $f593          62867
        Rise_Run_Idx : $f5ef          62959
        Rise_Run_Len : $f603          62979
          Rise_Run_X : $f5ff          62975
          Rise_Run_Y : $f601          62977
              Rot_VL : $f616          62998
           Rot_VL_ab : $f610          62992
         Rot_VL_Mode : $f61f          63007
        Rot_VL_M_dft : $f62b          63019
         Select_Game : $f7a9          63401
         Set_Refresh : $f1a2          61858
          Sound_Byte : $f256          62038
         Sound_Bytes : $f27d          62077
       Sound_Bytes_x : $f284          62084
      Sound_Byte_raw : $f25b          62043
        Sound_Byte_x : $f259          62041
               Start : $f000          61440
         Strip_Zeros : $f8b7          63671
      Vec_ADSR_Table : $c84f          51279
     Vec_ADSR_Timers : $c85e          51294
           Vec_Angle : $c836          51254
      Vec_Brightness : $c827          51239
       Vec_Btn_State : $c80f          51215
         Vec_Buttons : $c811          51217
      Vec_Button_1_1 : $c812          51218
      Vec_Button_1_2 : $c813          51219
      Vec_Button_1_3 : $c814          51220
      Vec_Button_1_4 : $c815          51221
      Vec_Button_2_1 : $c816          51222
      Vec_Button_2_2 : $c817          51223
      Vec_Button_2_3 : $c818          51224
      Vec_Button_2_4 : $c819          51225
       Vec_Cold_Flag : $cbfe          52222
        Vec_Counters : $c82e          51246
       Vec_Counter_1 : $c82e          51246
       Vec_Counter_2 : $c82f          51247
       Vec_Counter_3 : $c830          51248
       Vec_Counter_4 : $c831          51249
       Vec_Counter_5 : $c832          51250
       Vec_Counter_6 : $c833          51251
     Vec_Default_Stk : $cbea          52202
       Vec_Dot_Dwell : $c828          51240
        Vec_Duration : $c857          51287
       Vec_Expl_Chan : $c85c          51292
      Vec_Expl_ChanA : $c853          51283
      Vec_Expl_ChanB : $c85d          51293
      Vec_Expl_Chans : $c854          51284
       Vec_Expl_Flag : $c867          51303
      Vec_Expl_Timer : $c877          51319
          Vec_Expl_1 : $c858          51288
          Vec_Expl_2 : $c859          51289
          Vec_Expl_3 : $c85a          51290
          Vec_Expl_4 : $c85b          51291
     Vec_FIRQ_Vector : $cbf5          52213
      Vec_Freq_Table : $c84d          51277
      Vec_High_Score : $cbeb          52203
      Vec_IRQ_Vector : $cbf8          52216
         Vec_Joy_Mux : $c81f          51231
     Vec_Joy_Mux_1_X : $c81f          51231
     Vec_Joy_Mux_1_Y : $c820          51232
     Vec_Joy_Mux_2_X : $c821          51233
     Vec_Joy_Mux_2_Y : $c822          51234
      Vec_Joy_Resltn : $c81a          51226
         Vec_Joy_1_X : $c81b          51227
         Vec_Joy_1_Y : $c81c          51228
         Vec_Joy_2_X : $c81d          51229
         Vec_Joy_2_Y : $c81e          51230
      Vec_Loop_Count : $c825          51237
       Vec_Max_Games : $c850          51280
     Vec_Max_Players : $c84f          51279
      Vec_Misc_Count : $c823          51235
      Vec_Music_Chan : $c855          51285
      Vec_Music_Flag : $c856          51286
      Vec_Music_Freq : $c861          51297
       Vec_Music_Ptr : $c853          51283
     Vec_Music_Twang : $c858          51288
      Vec_Music_Wk_A : $c842          51266
      Vec_Music_Wk_1 : $c84b          51275
      Vec_Music_Wk_5 : $c847          51271
      Vec_Music_Wk_6 : $c846          51270
      Vec_Music_Wk_7 : $c845          51269
      Vec_Music_Work : $c83f          51263
      Vec_NMI_Vector : $cbfb          52219
        Vec_Num_Game : $c87a          51322
     Vec_Num_Players : $c879          51321
         Vec_Pattern : $c829          51241
       Vec_Prev_Btns : $c810          51216
     Vec_Random_Seed : $c87d          51325
           Vec_Rfrsh : $c83d          51261
        Vec_Rfrsh_hi : $c83e          51262
        Vec_Rfrsh_lo : $c83d          51261
     Vec_RiseRun_Len : $c83b          51259
     Vec_RiseRun_Tmp : $c834          51252
      Vec_Rise_Index : $c839          51257
       Vec_Run_Index : $c837          51255
        Vec_Seed_Ptr : $c87b          51323
      Vec_Snd_Shadow : $c800          51200
         Vec_Str_Ptr : $c82c          51244
     Vec_SWI2_Vector : $cbf2          52210
     Vec_SWI3_Vector : $cbf2          52210
      Vec_SWI_Vector : $cbfb          52219
     Vec_Text_Height : $c82a          51242
         Vec_Text_HW : $c82a          51242
      Vec_Text_Width : $c82b          51243
           Vec_Title : $f10c          61708
         Vec_Title_2 : $f118          61720
     Vec_Twang_Table : $c851          51281
     Vec_0Ref_Enable : $c824          51236
        VIA_aux_cntl : $d00b          53259
            VIA_cntl : $d00c          53260
           VIA_DDR_a : $d003          53251
           VIA_DDR_b : $d002          53250
      VIA_int_enable : $d00e          53262
       VIA_int_flags : $d00d          53261
          VIA_port_a : $d001          53249
     VIA_port_a_nohs : $d00f          53263
          VIA_port_b : $d000          53248
       VIA_shift_reg : $d00a          53258
       VIA_t1_cnt_hi : $d005          53253
       VIA_t1_cnt_lo : $d004          53252
       VIA_t1_lch_hi : $d007          53255
       VIA_t1_lch_lo : $d006          53254
           VIA_t2_hi : $d009          53257
           VIA_t2_lo : $d008          53256
          Wait_Recal : $f192          61842
          Warm_Start : $f06c          61548
          Xform_Rise : $f663          63075
        Xform_Rise_a : $f661          63073
           Xform_Run : $f65d          63069
         Xform_Run_a : $f65b          63067
            __6809__ : $0001              1

418 labels used

3543 lines read, no errors in pass 1.
AS09 Assembler for M6809/H6309 [1.11].  Copyright 1994-96, Frank A. Vorstenbosch                                                                                                              Page    2
---------------------------------------------------------------------------------------------- BIOS.ASM -----------------------------------------------------------------------------------------------

                             ; 4 KB Bios
                             ; can be assembled correctly now
                             ; corrected and compatibilty added by Malban
                             ;
                             ; assemble with comand line:
                             ; .\ass\as09.exe -w200 -h0 -l -mcti bios.asm >error
                             ;
                             ; used the 6809 assembler:
                             ; as09 [1.11].
                             ; Copyright 1990-1994, Frank A. Vorstenbosch, Kingswood Software.
                             ; Available at:
                             ; http://www.falstaff.demon.co.uk/cross.html
                             ;
                                             CODE
f000 =                                       ORG     $F000
                                             DATA
f000 =                                       ORG     $F000
                                             BSS
f000 =                                       ORG     $F000
                                             CODE
                             ;-----------------------------------------------------------------------;
                             ; This disassembly of the Vectrex ROM was done by Bruce Tomlin          ;
                             ; (btomlin@aol.com), and is based in part on a disassembly done by      ;
                             ; Fred Taft (fred@hp-pcd.cv.hp.com).                                    ;
                             ;-----------------------------------------------------------------------;
                             
                                             INCLUDE "VECTREX.INC"
                                     if INCLUDE_I != 1
                             
                             INCLUDE_I equ 1
                             
                             Vec_Snd_Shadow  EQU     $C800   ;Shadow of sound chip registers (15 bytes)
                             Vec_Btn_State   EQU     $C80F   ;Current state of all joystick buttons
                             Vec_Prev_Btns   EQU     $C810   ;Previous state of all joystick buttons
                             Vec_Buttons     EQU     $C811   ;Current toggle state of all buttons
                             Vec_Button_1_1  EQU     $C812   ;Current toggle state of stick 1 button 1
                             Vec_Button_1_2  EQU     $C813   ;Current toggle state of stick 1 button 2
                             Vec_Button_1_3  EQU     $C814   ;Current toggle state of stick 1 button 3
                             Vec_Button_1_4  EQU     $C815   ;Current toggle state of stick 1 button 4
                             Vec_Button_2_1  EQU     $C816   ;Current toggle state of stick 2 button 1
                             Vec_Button_2_2  EQU     $C817   ;Current toggle state of stick 2 button 2
                             Vec_Button_2_3  EQU     $C818   ;Current toggle state of stick 2 button 3
                             Vec_Button_2_4  EQU     $C819   ;Current toggle state of stick 2 button 4
                             Vec_Joy_Resltn  EQU     $C81A   ;Joystick A/D resolution ($80=min $00=max)
                             Vec_Joy_1_X     EQU     $C81B   ;Joystick 1 left/right
                             Vec_Joy_1_Y     EQU     $C81C   ;Joystick 1 up/down
                             Vec_Joy_2_X     EQU     $C81D   ;Joystick 2 left/right
                             Vec_Joy_2_Y     EQU     $C81E   ;Joystick 2 up/down
                             Vec_Joy_Mux     EQU     $C81F   ;Joystick enable/mux flags (4 bytes)
                             Vec_Joy_Mux_1_X EQU     $C81F   ;Joystick 1 X enable/mux flag (=1)
                             Vec_Joy_Mux_1_Y EQU     $C820   ;Joystick 1 Y enable/mux flag (=3)
                             Vec_Joy_Mux_2_X EQU     $C821   ;Joystick 2 X enable/mux flag (=5)
                             Vec_Joy_Mux_2_Y EQU     $C822   ;Joystick 2 Y enable/mux flag (=7)
                             Vec_Misc_Count  EQU     $C823   ;Misc counter/flag byte, zero when not in use
                             Vec_0Ref_Enable EQU     $C824   ;Check0Ref enable flag
                             Vec_Loop_Count  EQU     $C825   ;Loop counter word (incremented in Wait_Recal)
                             Vec_Brightness  EQU     $C827   ;Default brightness
                             Vec_Dot_Dwell   EQU     $C828   ;Dot dwell time?
                             Vec_Pattern     EQU     $C829   ;Dot pattern (bits)
                             Vec_Text_HW     EQU     $C82A   ;Default text height and width
                             Vec_Text_Height EQU     $C82A   ;Default text height
                             Vec_Text_Width  EQU     $C82B   ;Default text width
                             Vec_Str_Ptr     EQU     $C82C   ;Temporary string pointer for Print_Str
                             Vec_Counters    EQU     $C82E   ;Six bytes of counters
                             Vec_Counter_1   EQU     $C82E   ;First  counter byte
                             Vec_Counter_2   EQU     $C82F   ;Second counter byte
                             Vec_Counter_3   EQU     $C830   ;Third  counter byte
                             Vec_Counter_4   EQU     $C831   ;Fourth counter byte
                             Vec_Counter_5   EQU     $C832   ;Fifth  counter byte
                             Vec_Counter_6   EQU     $C833   ;Sixth  counter byte
                             Vec_RiseRun_Tmp EQU     $C834   ;Temp storage word for rise/run
                             Vec_Angle       EQU     $C836   ;Angle for rise/run and rotation calculations
                             Vec_Run_Index   EQU     $C837   ;Index pair for run
                             *                       $C839   ;Pointer to copyright string during startup
                             Vec_Rise_Index  EQU     $C839   ;Index pair for rise
                             *                       $C83B   ;High score cold-start flag (=0 if valid)
                             Vec_RiseRun_Len EQU     $C83B   ;length for rise/run
                             *                       $C83C   ;temp byte
                             Vec_Rfrsh       EQU     $C83D   ;Refresh time (divided by 1.5MHz)
                             Vec_Rfrsh_lo    EQU     $C83D   ;Refresh time low byte
                             Vec_Rfrsh_hi    EQU     $C83E   ;Refresh time high byte
                             Vec_Music_Work  EQU     $C83F   ;Music work buffer (14 bytes, backwards?)
                             Vec_Music_Wk_A  EQU     $C842   ;        register 10
                             *                       $C843   ;        register 9
                             *                       $C844   ;        register 8
                             Vec_Music_Wk_7  EQU     $C845   ;        register 7
                             Vec_Music_Wk_6  EQU     $C846   ;        register 6
                             Vec_Music_Wk_5  EQU     $C847   ;        register 5
                             *                       $C848   ;        register 4
                             *                       $C849   ;        register 3
                             *                       $C84A   ;        register 2
                             Vec_Music_Wk_1  EQU     $C84B   ;        register 1
                             *                       $C84C   ;        register 0
                             Vec_Freq_Table  EQU     $C84D   ;Pointer to note-to-frequency table (normally $FC8D)
                             Vec_Max_Players EQU     $C84F   ;Maximum number of players for Select_Game
                             Vec_Max_Games   EQU     $C850   ;Maximum number of games for Select_Game
                             Vec_ADSR_Table  EQU     $C84F   ;Storage for first music header word (ADSR table)
                             Vec_Twang_Table EQU     $C851   ;Storage for second music header word ('twang' table)
                             Vec_Music_Ptr   EQU     $C853   ;Music data pointer
                             Vec_Expl_ChanA  EQU     $C853   ;Used by Explosion_Snd - bit for first channel used?
                             Vec_Expl_Chans  EQU     $C854   ;Used by Explosion_Snd - bits for all channels used?
                             Vec_Music_Chan  EQU     $C855   ;Current sound channel number for Init_Music
                             Vec_Music_Flag  EQU     $C856   ;Music active flag ($00=off $01=start $80=on)
                             Vec_Duration    EQU     $C857   ;Duration counter for Init_Music
                             Vec_Music_Twang EQU     $C858   ;3 word 'twang' table used by Init_Music
                             Vec_Expl_1      EQU     $C858   ;Four bytes copied from Explosion_Snd's U-reg parameters
                             Vec_Expl_2      EQU     $C859   ;
                             Vec_Expl_3      EQU     $C85A   ;
                             Vec_Expl_4      EQU     $C85B   ;
                             Vec_Expl_Chan   EQU     $C85C   ;Used by Explosion_Snd - channel number in use?
                             Vec_Expl_ChanB  EQU     $C85D   ;Used by Explosion_Snd - bit for second channel used?
                             Vec_ADSR_Timers EQU     $C85E   ;ADSR timers for each sound channel (3 bytes)
                             Vec_Music_Freq  EQU     $C861   ;Storage for base frequency of each channel (3 words)
                             *                       $C85E   ;Scratch 'score' storage for Display_Option (7 bytes)
                             Vec_Expl_Flag   EQU     $C867   ;Explosion_Snd initialization flag?
                             *               $C868...$C876   ;Unused?
                             Vec_Expl_Timer  EQU     $C877   ;Used by Explosion_Snd
                             *                       $C878   ;Unused?
                             Vec_Num_Players EQU     $C879   ;Number of players selected in Select_Game
                             Vec_Num_Game    EQU     $C87A   ;Game number selected in Select_Game
                             Vec_Seed_Ptr    EQU     $C87B   ;Pointer to 3-byte random number seed (=$C87D)
                             Vec_Random_Seed EQU     $C87D   ;Default 3-byte random number seed
                                                             ;
                             *    $C880 - $CBEA is user RAM  ;
                                                             ;
                             Vec_Default_Stk EQU     $CBEA   ;Default top-of-stack
                             Vec_High_Score  EQU     $CBEB   ;High score storage (7 bytes)
                             Vec_SWI3_Vector EQU     $CBF2   ;SWI2/SWI3 interrupt vector (3 bytes)
                             Vec_SWI2_Vector EQU     $CBF2   ;SWI2/SWI3 interrupt vector (3 bytes)
                             Vec_FIRQ_Vector EQU     $CBF5   ;FIRQ interrupt vector (3 bytes)
                             Vec_IRQ_Vector  EQU     $CBF8   ;IRQ interrupt vector (3 bytes)
                             Vec_SWI_Vector  EQU     $CBFB   ;SWI/NMI interrupt vector (3 bytes)
                             Vec_NMI_Vector  EQU     $CBFB   ;SWI/NMI interrupt vector (3 bytes)
                             Vec_Cold_Flag   EQU     $CBFE   ;Cold start flag (warm start if = $7321)
                                                             ;
                             VIA_port_b      EQU     $D000   ;VIA port B data I/O register
                             *       0 sample/hold (0=enable  mux 1=disable mux)
                             *       1 mux sel 0
                             *       2 mux sel 1
                             *       3 sound BC1
                             *       4 sound BDIR
                             *       5 comparator input
                             *       6 external device (slot pin 35) initialized to input
                             *       7 /RAMP
                             VIA_port_a      EQU     $D001   ;VIA port A data I/O register (handshaking)
                             VIA_DDR_b       EQU     $D002   ;VIA port B data direction register (0=input 1=output)
                             VIA_DDR_a       EQU     $D003   ;VIA port A data direction register (0=input 1=output)
                             VIA_t1_cnt_lo   EQU     $D004   ;VIA timer 1 count register lo (scale factor)
                             VIA_t1_cnt_hi   EQU     $D005   ;VIA timer 1 count register hi
                             VIA_t1_lch_lo   EQU     $D006   ;VIA timer 1 latch register lo
                             VIA_t1_lch_hi   EQU     $D007   ;VIA timer 1 latch register hi
                             VIA_t2_lo       EQU     $D008   ;VIA timer 2 count/latch register lo (refresh)
                             VIA_t2_hi       EQU     $D009   ;VIA timer 2 count/latch register hi
                             VIA_shift_reg   EQU     $D00A   ;VIA shift register
                             VIA_aux_cntl    EQU     $D00B   ;VIA auxiliary control register
                             *       0 PA latch enable
                             *       1 PB latch enable
                             *       2 \                     110=output to CB2 under control of phase 2 clock
                             *       3  > shift register control     (110 is the only mode used by the Vectrex ROM)
                             *       4 /
                             *       5 0=t2 one shot                 1=t2 free running
                             *       6 0=t1 one shot                 1=t1 free running
                             *       7 0=t1 disable PB7 output       1=t1 enable PB7 output
                             VIA_cntl        EQU     $D00C   ;VIA control register
                             *       0 CA1 control     CA1 -> SW7    0=IRQ on low 1=IRQ on high
                             *       1 \
                             *       2  > CA2 control  CA2 -> /ZERO  110=low 111=high
                             *       3 /
                             *       4 CB1 control     CB1 -> NC     0=IRQ on low 1=IRQ on high
                             *       5 \
                             *       6  > CB2 control  CB2 -> /BLANK 110=low 111=high
                             *       7 /
                             VIA_int_flags   EQU     $D00D   ;VIA interrupt flags register
                             *               bit                             cleared by
                             *       0 CA2 interrupt flag            reading or writing port A I/O
                             *       1 CA1 interrupt flag            reading or writing port A I/O
                             *       2 shift register interrupt flag reading or writing shift register
                             *       3 CB2 interrupt flag            reading or writing port B I/O
                             *       4 CB1 interrupt flag            reading or writing port A I/O
                             *       5 timer 2 interrupt flag        read t2 low or write t2 high
                             *       6 timer 1 interrupt flag        read t1 count low or write t1 high
                             *       7 IRQ status flag               write logic 0 to IER or IFR bit
                             VIA_int_enable  EQU     $D00E   ;VIA interrupt enable register
                             *       0 CA2 interrupt enable
                             *       1 CA1 interrupt enable
                             *       2 shift register interrupt enable
                             *       3 CB2 interrupt enable
                             *       4 CB1 interrupt enable
                             *       5 timer 2 interrupt enable
                             *       6 timer 1 interrupt enable
                             *       7 IER set/clear control
                             VIA_port_a_nohs EQU     $D00F   ;VIA port A data I/O register (no handshaking)
                             
                             
                                     endif
                             
                             ;-----------------------------------------------------------------------;
                             ;       F000    Start                                                   ;
                             ;                                                                       ;
                             ; Jump here to restart the Vectrex and re-initialize the OS.  If the    ;
                             ; cold start flag is correct (it should be unless you just turned the   ;
                             ; Vectrex on), the cold start code is skipped.                          ;
                             ;                                                                       ;
                             ; On cold start, the high score is cleared, and the power-on screen     ;
                             ; is displayed with the power-on music.                                 ;
                             ;-----------------------------------------------------------------------;
                             
f000 : 10cecbea         [ 4] Start:          LDS     #Vec_Default_Stk ;Set up stack pointer
f004 : bdf18b           [ 9]                 JSR     Init_OS         ;Initialize system
f007 : cc7321           [ 3]                 LDD     #$7321          ;Check cold start flag
f00a : 10b3cbfe         [ 8]                 CMPD    Vec_Cold_Flag
f00e : 275c             [ 3]                 BEQ     Warm_Start      ;Branch if warm start
f010 : fdcbfe           [ 6]                 STD     Vec_Cold_Flag   ;Initialize cold start flag
f013 : 7cc83b           [ 7]                 INC     $C83B           ;Set high score invalid flag
f016 : 8ecbeb           [ 3]                 LDX     #Vec_High_Score ;Clear high score
f019 : bdf84f           [ 9]                 JSR     Clear_Score
                             
                             ;       First power-up loop.  This prints the "VECTREX"
                             ;       power-on screen and plays the power-on music.
                             
f01c : bdf1af           [ 9] LF01C:          JSR     DP_to_C8        ;DP to RAM
f01f : dc25             [ 5]                 LDD     <Vec_Loop_Count ;When we have looped 257 times,
f021 : 10830101         [ 5]                 CMPD    #$0101
f025 : 2602             [ 3]                 BNE     LF029
f027 : d756             [ 4]                 STB     <Vec_Music_Flag ;start the intro music
                             
                             ;       Get the line pattern for the boundary box lines
                             
f029 : 57               [ 2] LF029:          ASRB                    ;Get line pattern from table
f02a : c403             [ 2]                 ANDB    #$03
f02c : 8ef0fd           [ 3]                 LDX     #DF0FD
f02f : e685             [ 5]                 LDB     B,X
f031 : d729             [ 4]                 STB     <Vec_Pattern    ;Store pattern
                             
f033 : c602             [ 2]                 LDB     #$02            ;Set up counter for two boxes
f035 : d724             [ 4]                 STB     <$C824
                             
                             ;       Play the intro music
                             
f037 : cefd0d           [ 3]                 LDU     #Intro_Music    ;Get address of music
f03a : bdf687           [ 9]                 JSR     Init_Music_chk  ;Initialize the music
f03d : bdf192           [ 9]                 JSR     Wait_Recal      ;Wait for next frame
f040 : bdf289           [ 9]                 JSR     Do_Sound        ;Play music if active
                             
                             ;       Display power-up message
                             
f043 : bdf2a9           [ 9]                 JSR     Intensity_7F    ;Normal brightness
f046 : b6c826           [ 5]                 LDA     $C826           ;Alternate size every 32 loops
f049 : cef10c           [ 3]                 LDU     #Vec_Title     ;Load address of double high text
f04c : 8520             [ 2]                 BITA    #$20
f04e : 2702             [ 3]                 BEQ     LF052
f050 : 334c             [ 5]                 LEAU    <<(Vec_Title_2-Vec_Title),U  ;Skip double high text
f052 : bdf385           [ 9] LF052:          JSR     Print_List_hw   ;Print startup text
                             
                             ;       Draw the frame boxes
                             
f055 : 8ef0e9           [ 3]                 LDX     #Intro_Boxes
f058 : bdf308           [ 9] LF058:          JSR     Moveto_ix_FF    ;Move to start of line
f05b : 8603             [ 2]                 LDA     #$03            ;Draw 4 lines
f05d : bdf434           [ 9]                 JSR     Draw_Pat_VL_a
f060 : 7ac824           [ 7]                 DEC     $C824           ;Go back for next box
f063 : 26f3             [ 3]                 BNE     LF058
f065 : b6c825           [ 5]                 LDA     Vec_Loop_Count
f068 : 8101             [ 2]                 CMPA    #$01            ;Repeat for 512 counts
f06a : 23b0             [ 3]                 BLS     LF01C
                             
                             ;-----------------------------------------------------------------------;
                             ;       F06C    Warm_Start                                              ;
                             ;                                                                       ;
                             ; Jump here to restart the Vectrex without re-initializing the OS.      ;
                             ;-----------------------------------------------------------------------;
                             
                             ;       Prepare for ROM check
                             
f06c : bdf1af           [ 9] Warm_Start:     JSR     DP_to_C8        ;DP to RAM
f06f : 86cc             [ 2]                 LDA     #$CC            ;Set new line pattern
f071 : 9729             [ 4]                 STA     <Vec_Pattern
f073 : ccf101           [ 3]                 LDD     #Copyright_Str  ;Save copyright string addr
f076 : dd39             [ 5]                 STD     <$C839
f078 : 0f25             [ 6]                 CLR     <Vec_Loop_Count ;Clear loop counter
f07a : 0f26             [ 6]                 CLR     <Vec_Loop_Count+1
                             
                             ;       Check for valid cartridge ROM
                             
f07c : ce0000           [ 3]                 LDU     #$0000          ;Look at address zero
f07f : 8ef101           [ 3]                 LDX     #Copyright_Str
f082 : c60b             [ 2]                 LDB     #$0B            ;11 bytes long
f084 : a6c0             [ 6] LF084:          LDA     ,U+             ;Compare next byte
f086 : a180             [ 6]                 CMPA    ,X+
f088 : 270d             [ 3]                 BEQ     LF097           ;Okay if match
f08a : c101             [ 2]                 CMPB    #$01            ;Not okay if last byte wrong
f08c : 2704             [ 3]                 BEQ     LF092
f08e : c105             [ 2]                 CMPB    #$05            ;Okay if date wrong
f090 : 2305             [ 3]                 BLS     LF097
f092 : cee000           [ 3] LF092:          LDU     #$E000          ;Bad cart; load Mine Storm addr
f095 : 2007             [ 3]                 BRA     LF09E
                             
f097 : 5a               [ 2] LF097:          DECB                    ;Go back for next byte
f098 : 26ea             [ 3]                 BNE     LF084
f09a : d739             [ 4]                 STB     <$C839          ;Store zero as address of
f09c : d73a             [ 4]                 STB     <$C83A          ;copyright string
                             
                             ;       Prepare to play game start-up music
                             
f09e : 0c56             [ 6] LF09E:          INC     <Vec_Music_Flag ;Set music enable flag
f0a0 : df37             [ 5]                 STU     <Vec_Run_Index  ;Save address of header
f0a2 : eec4             [ 5]                 LDU     ,U              ;Get address of music
                             
                             ;       Second power-up loop.  This prints the name of the
                             ;       game, the copyright, and plays the start-up music
                             
f0a4 : bdf1af           [ 9] LF0A4:          JSR     DP_to_C8        ;DP to RAM
f0a7 : ccf848           [ 3]                 LDD     #$F848          ;???
f0aa : dd2a             [ 5]                 STD     <Vec_Text_HW
f0ac : bdf687           [ 9]                 JSR     Init_Music_chk  ;Initialize the music
f0af : bdf192           [ 9]                 JSR     Wait_Recal      ;Wait for next frame
f0b2 : bdf289           [ 9]                 JSR     Do_Sound        ;Play the music if active
                             
                             ;       Display cartridge GCE copyright string
                             
f0b5 : bdf2a9           [ 9]                 JSR     Intensity_7F    ;Normal brightness
f0b8 : ccc0c0           [ 3]                 LDD     #$C0C0          ;Print copyright string
f0bb : fec839           [ 6]                 LDU     $C839
f0be : bdf37a           [ 9]                 JSR     Print_Str_d
                             
                             ;       Display current high score if any
                             
f0c1 : b6c83b           [ 5]                 LDA     $C83B           ;Skip if no high score
f0c4 : 260c             [ 3]                 BNE     LF0D2
f0c6 : 4a               [ 2]                 DECA
f0c7 : cecbeb           [ 3]                 LDU     #Vec_High_Score
f0ca : a746             [ 5]                 STA     6,U
f0cc : cc68d0           [ 3]                 LDD     #$68D0
f0cf : bdf37a           [ 9]                 JSR     Print_Str_d
                             
                             ;       Display cartridge name
                             
f0d2 : fec837           [ 6] LF0D2:          LDU     Vec_Run_Index   ;Get cartridge header addr
f0d5 : 3342             [ 5]                 LEAU    2,U             ;Skip music addr
f0d7 : bdf385           [ 9]                 JSR     Print_List_hw   ;Print it
f0da : b6c856           [ 5]                 LDA     Vec_Music_Flag  ;Go back if music still playing
f0dd : 26c5             [ 3]                 BNE     LF0A4
f0df : bec825           [ 6]                 LDX     Vec_Loop_Count  ;Go back if count less than 126
f0e2 : 8c007d           [ 4]                 CMPX    #$007D
f0e5 : 23bd             [ 3]                 BLS     LF0A4
f0e7 : 6e41             [ 4]                 JMP     1,U             ;Jump into cartridge
                             
                             ;       Outer box (y,x)
                             
f0e9 : 40d6                  Intro_Boxes:    FCB     $40,$D6
f0eb : 0056                                  FCB     $00,$56
f0ed : 8100                                  FCB     $81,$00
f0ef : 00a9                                  FCB     $00,$A9
f0f1 : 7e00                                  FCB     $7E,$00
                             
                             ;       Inner box (y,x)
                             
f0f3 : 39dc                                  FCB     $39,$DC
f0f5 : 8e00                                  FCB     $8E,$00
f0f7 : 004a                                  FCB     $00,$4A
f0f9 : 7200                                  FCB     $72,$00
f0fb : 00b6                                  FCB     $00,$B6
                             
                             ;       Line patterns for boundary boxes
                             
f0fd : e0                    DF0FD:          FCB     %11100000
f0fe : 38                                    FCB     %00111000
f0ff : 0e                                    FCB     %00001110
f100 : 03                                    FCB     %00000011
                             
                             ;       Copyright string
                             
f101 : 67204743452031..      Copyright_Str:  FCC     "g GCE 1982"
f10b : 80                                    FCB     $80
f10c :                       here__:
000b =                       Copyright_Len   EQU     here__-Copyright_Str
                             
                             ;       Title strings
                             
f10c : f160                  Vec_Title:      FCB     $F1,$60         ;Height, width
f10e : 27cf                                  FCB     $27,$CF         ;Y,X
f110 : 56454354524558                        FCC     "VECTREX"
f117 : 80                                    FCB     $80
                             
f118 : f360                  Vec_Title_2:    FCB     $F3,$60         ;Height, width
f11a : 26cf                                  FCB     $26,$CF         ;Y,X
f11c : 56454354524558                        FCC     "VECTREX"
f123 : 80                                    FCB     $80
                             
f124 : fc60                                  FCB     $FC,$60         ;Height, width
f126 : dfe9                                  FCB     $DF,$E9         ;Y,X
f128 : 474345                                FCC     "GCE"
f12b : 80                                    FCB     $80
                             
f12c : fc38                                  FCB     $FC,$38         ;Height, width
f12e : ccd1                                  FCB     $CC,$D1         ;Y,X
f130 : 454e5445525441..                      FCC     "ENTERTAINING"
f13c : 80                                    FCB     $80
                             
f13d : fc38                                  FCB     $FC,$38         ;Height, width
f13f : bcdc                                  FCB     $BC,$DC         ;Y,X
f141 : 4e455720494445..                      FCC     "NEW IDEAS"
f14a : 80                                    FCB     $80
                             
f14b : 00                                    FCB     $00
                             
                             ;-----------------------------------------------------------------------;
                             ;       F14C    Init_VIA                                                ;
                             ;                                                                       ;
                             ; This routine is invoked during powerup, to initialize the VIA chip.   ;
                             ; Among other things, it initializes the scale factor to 0x7F, and      ;
                             ; sets up the direction for the port A and B data lines.                ;
                             ;                                                                       ;
                             ; EXIT: DP = $D0                                                        ;
                             ;                                                                       ;
                             ;       D-reg, X-reg trashed                                            ;
                             ;-----------------------------------------------------------------------;
                             
f14c : 8d5c             [ 7] Init_VIA:       BSR     DP_to_D0
f14e : cc9fff           [ 3]                 LDD     #$9FFF          ;Port A=all output
f151 : dd02             [ 5]                 STD     <VIA_DDR_b      ;Port B=OIIOOOOO
f153 : cc0100           [ 3]                 LDD     #$0100          ;Port B sound BDIR=1
f156 : dd00             [ 5]                 STD     <VIA_port_b
f158 : cc987f           [ 3]                 LDD     #$987F          ;ACR=$98 T1->PB7 enabled
f15b : 970b             [ 4]                 STA     <VIA_aux_cntl   ;auxiliary control register
f15d : d704             [ 4]                 STB     <VIA_t1_cnt_lo  ;T1CL=$7F scale factor?
f15f : bdf354           [ 9]                 JSR     Reset0Ref
f162 : 203e             [ 3]                 BRA     Set_Refresh
                             
                             ;-----------------------------------------------------------------------;
                             ;       F164    Init_OS_RAM                                             ;
                             ;                                                                       ;
                             ; This routine first clears the block of RAM in the range $C800 to      ;
                             ; $C87A, and then it initializes the dot dwell time, the refresh time,  ;
                             ; and the joystick enable flags.                                        ;
                             ;                                                                       ;
                             ; EXIT: DP = $C8                                                        ;
                             ;                                                                       ;
                             ;       D-reg, X-reg trashed                                            ;
                             ;-----------------------------------------------------------------------;
                             
f164 : 8d49             [ 7] Init_OS_RAM:    BSR     DP_to_C8        ;DP to RAM
f166 : c67a             [ 2]                 LDB     #$7A            ;Clear $C800-$C87A
f168 : 8ec800           [ 3]                 LDX     #$C800
f16b : bdf53f           [ 9]                 JSR     Clear_x_b
f16e : ccc87d           [ 3]                 LDD     #Vec_Random_Seed;Point $C87B to $C87D
f171 : dd7b             [ 5]                 STD     <Vec_Seed_Ptr
f173 : 0c7d             [ 6] LF173:          INC     <Vec_Random_Seed;Make sure random number
f175 : 27fc             [ 3]                 BEQ     LF173           ;seed is non-zero!
f177 : 8605             [ 2]                 LDA     #$05            ;Init dot dwell (brightness)
f179 : 9728             [ 4]                 STA     <Vec_Dot_Dwell
f17b : cc3075           [ 3]                 LDD     #$3075          ;Init refresh time to $7530
f17e : dd3d             [ 5]                 STD     <$C83D
f180 : cc0103           [ 3]                 LDD     #$0103          ;Init joystick enable flags
f183 : dd1f             [ 5]                 STD     <Vec_Joy_Mux_1_X
f185 : cc0507           [ 3]                 LDD     #$0507
f188 : dd21             [ 5]                 STD     <Vec_Joy_Mux_2_X
f18a : 39               [ 5]                 RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F18B    Init_OS                                                 ;
                             ;                                                                       ;
                             ; This routine is responsible for setting up the initial system state,  ;
                             ; each time the system is either reset or powered up.  It will          ;
                             ; initialize the OS RAM area, initialize the VIA chip, and then clear   ;
                             ; all the registers on the sound chip.                                  ;
                             ;                                                                       ;
                             ; EXIT: DP = $D0                                                        ;
                             ;                                                                       ;
                             ;       D-reg, X-reg trashed                                            ;
                             ;-----------------------------------------------------------------------;
                             
f18b : 8dd7             [ 7] Init_OS:        BSR     Init_OS_RAM
f18d : 8dbd             [ 7]                 BSR     Init_VIA
f18f : 7ef272           [ 4]                 JMP     Clear_Sound
                             
                             ;-----------------------------------------------------------------------;
                             ;       F192    Wait_Recal                                              ;
                             ;                                                                       ;
                             ; Wait for t2 (the refresh timer) to timeout, then restart it using     ;
                             ; the value in $C83D.  then, recalibrate the vector generators to the   ;
                             ; origin (0,0).  This routine MUST be called once every refresh         ;
                             ; cycle, or your vectors will get out of whack.  This routine calls     ;
                             ; Reset0Ref, so the integrators are left in zero mode.                  ;
                             ;                                                                       ;
                             ; EXIT: DP = $D0                                                        ;
                             ;                                                                       ;
                             ;       D-reg, X-reg trashed                                            ;
                             ;-----------------------------------------------------------------------;
                             
f192 : bec825           [ 6] Wait_Recal:     LDX     Vec_Loop_Count  ;Increment loop counter
f195 : 3001             [ 5]                 LEAX    1,X
f197 : bfc825           [ 6]                 STX     Vec_Loop_Count
f19a : 8d0e             [ 7]                 BSR     DP_to_D0        ;DP to I/O
f19c : 8620             [ 2]                 LDA     #$20
f19e : 950d             [ 4] LF19E:          BITA    <VIA_int_flags  ;Wait for timer t2
f1a0 : 27fc             [ 3]                 BEQ     LF19E
                             
                             ;-----------------------------------------------------------------------;
                             ;       F1A2    Set_Refresh                                             ;
                             ;                                                                       ;
                             ; This routine loads the refresh timer (t2) with the value in $C83D-    ;
                             ; $C83E, and recalibrates the vector generators, thus causing the pen   ;
                             ; to be left at the origin (0,0).  The high order byte for the timer    ;
                             ; is loaded from $C83E, and the low order byte is loaded from $C83D.    ;
                             ; The refresh rate is calculated as follows:                            ;
                             ;                                                                       ;
                             ;   rate = (C83E)(C83D) / 1.5 mhz                                       ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;                                                                       ;
                             ;       D-reg trashed                                           ;
                             ;-----------------------------------------------------------------------;
                             
f1a2 : fcc83d           [ 6] Set_Refresh:    LDD     $C83D           ;Store refresh value
f1a5 : dd08             [ 5]                 STD     <VIA_t2_lo      ;into timer t2
f1a7 : 7ef2e6           [ 4]                 JMP     Recalibrate
                             
                             ;-----------------------------------------------------------------------;
                             ;       F1AA    DP_to_D0                                                ;
                             ;                                                                       ;
                             ; Sets the DP register to $D0, so that all direct page addressing will  ;
                             ; start at $D000 (the hardware I/O area).                               ;
                             ;                                                                       ;
                             ; EXIT: DP = $D0                                                        ;
                             ;       A-reg = $D0                                                     ;
                             ;-----------------------------------------------------------------------;
                             
f1aa : 86d0             [ 2] DP_to_D0:       LDA     #$D0
f1ac : 1f8b             [ 6]                 TFR     A,DP
f1ae : 39               [ 5]                 RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F1AF    DP_to_C8                                                ;
                             ;                                                                       ;
                             ; Sets the DP register to $C8, so that all direct page addressing will  ;
                             ; start at $C800 (OS RAM area).                                         ;
                             ;                                                                       ;
                             ;                                                                       ;
                             ; EXIT: DP = $C8                                                        ;
                             ;       A-reg = $C8                                                     ;
                             ;-----------------------------------------------------------------------;
                             
f1af : 86c8             [ 2] DP_to_C8:       LDA     #$C8
f1b1 : 1f8b             [ 6]                 TFR     A,DP
f1b3 : 39               [ 5]                 RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F1B4    Read_Btns_Mask                                          ;
                             ;       F1BA    Read_Btns                                               ;
                             ;                                                                       ;
                             ; Both of these routines read the button states on the two joysticks,   ;
                             ; and return their state in the following RAM locations:                ;
                             ;                                                                       ;
                             ;       joystick 1, button 1:  $C812 = $01                              ;
                             ;                   button 2:  $C813 = $02                              ;
                             ;                   button 3:  $C814 = $04                              ;
                             ;                   button 4:  $C815 = $08                              ;
                             ;       joystick 2, button 1:  $C816 = $10                              ;
                             ;                   button 2:  $C817 = $20                              ;
                             ;                   button 3:  $C818 = $40                              ;
                             ;                   button 4:  $C819 = $80                              ;
                             ;                                                                       ;
                             ;       C80F: Contains current state of all buttons;                    ;
                             ;             1 = depressed, 0 = not depressed                          ;
                             ;                                                                       ;
                             ;       C810: Contains state of all buttons from LAST time these        ;
                             ;             routines were called; if Read_Btns_Mask was called,       ;
                             ;             then this is AND'ed with the passed in mask.              ;
                             ;                                                                       ;
                             ;       C811: Contains the same information as $C812-$C819              ;
                             ;                                                                       ;
                             ;        Bit 7                                     Bit 0                ;
                             ;       +-----+-----+-----+-----+-----+-----+-----+-----+               ;
                             ;       | 2.4 | 2.3 | 2.2 | 2.1 | 1.4 | 2.3 | 1.2 | 1.1 |               ;
                             ;       +-----+-----+-----+-----+-----+-----+-----+-----+               ;
                             ;                                                                       ;
                             ; If Read_Btns is called, the result will be the same as Read_Btns_Mask ;
                             ; with a mask of $FF, and a 1 will only be returned if the button       ;
                             ; has transitioned to being pressed.                                    ;
                             ;                                                                       ;
                             ; If Read_Btns_Mask is called, then a mask, passed in in the A-reg      ;
                             ; will be used to determine how the button state info is returned:      ;
                             ;                                                                       ;
                             ; If a bit is 0, then the current state of the button is to be returned ;
                             ; in the appropriate RAM location; 0 = not pressed, and 1 = pressed.    ;
                             ;                                                                       ;
                             ; If a bit is 1, then the appropriate RAM location is set to 1 only     ;
                             ; on the depression transition of the button; additional calls will     ;
                             ; return 0, until the button is released and then depressed again.      ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       A-reg = mask (for Read_Btns_Mask only)                          ;
                             ;                                                                       ;
                             ; Exit: A-reg = button transition state (same as $C811)                 ;
                             ;                                                                       ;
                             ;       B-reg, X-reg trashed                                            ;
                             ;-----------------------------------------------------------------------;
                             
f1b4 : b4c80f           [ 5] Read_Btns_Mask: ANDA    Vec_Btn_State   ;Mask out "always" buttons
f1b7 : b7c80f           [ 5]                 STA     Vec_Btn_State
f1ba : 8ec812           [ 3] Read_Btns:      LDX     #Vec_Button_1_1 ;Point to button flags
f1bd : a61d             [ 5]                 LDA     -3,X            ;Save previous state
f1bf : a71e             [ 5]                 STA     -2,X
f1c1 : 860e             [ 2]                 LDA     #$0E            ;Sound chip register 0E to port A
f1c3 : 9701             [ 4]                 STA     <VIA_port_a
f1c5 : cc1901           [ 3]                 LDD     #$1901          ;sound BDIR on, BC1 on, mux off
f1c8 : 9700             [ 4]                 STA     <VIA_port_b
f1ca : 12               [ 2]                 NOP                     ;pause
f1cb : d700             [ 4]                 STB     <VIA_port_b     ;sound BDIR off, BC1 off, mux off
f1cd : 0f03             [ 6]                 CLR     <VIA_DDR_a      ;DDR A to input
f1cf : cc0901           [ 3]                 LDD     #$0901          ;sound BDIR off, BC1 on, mux off
f1d2 : 9700             [ 4]                 STA     <VIA_port_b
f1d4 : 12               [ 2]                 NOP                     ;pause
f1d5 : 9601             [ 4]                 LDA     <VIA_port_a     ;Read buttons
f1d7 : 43               [ 2]                 COMA                    ;Convert to active high
f1d8 : a71d             [ 5]                 STA     -3,X            ;Save buttons
f1da : d700             [ 4]                 STB     <VIA_port_b     ;sound BDIR off, BC1 off, mux off
f1dc : c6ff             [ 2]                 LDB     #$FF
f1de : d703             [ 4]                 STB     <VIA_DDR_a      ;DDR A to output
f1e0 : 43               [ 2]                 COMA                    ;Check for transitions
f1e1 : aa1e             [ 5]                 ORA     -2,X
f1e3 : 43               [ 2]                 COMA
f1e4 : a71f             [ 5]                 STA     -1,X            ;Store transition result
f1e6 : 3402             [ 6]                 PSHS    A               ;Save result for return value
f1e8 : c601             [ 2]                 LDB     #$01            ;Initialize bit position
f1ea : 1f98             [ 6] LF1EA:          TFR     B,A             ;Mask out bit
f1ec : a4e4             [ 4]                 ANDA    ,S
f1ee : a780             [ 6]                 STA     ,X+             ;Store masked bit
f1f0 : 58               [ 2]                 ASLB                    ;Go back for next bit
f1f1 : 26f7             [ 3]                 BNE     LF1EA
f1f3 : 3582             [ 8]                 PULS    A,PC            ;Get back transition bits and return
                             
                             ;-----------------------------------------------------------------------;
                             ;       F1F5    Joy_Analog                                              ;
                             ;       F1F8    Joy_Digital                                             ;
                             ;                                                                       ;
                             ; These routines read the current positions of the two joysticks.       ;
                             ;                                                                       ;
                             ; The joystick enable flags (C81F-C822) must be initialized to one of   ;
                             ; the following values:                                                 ;
                             ;                                                                       ;
                             ;       0 - ignore; return no value.                                    ;
                             ;       1 - return state of console 1 left/right position.              ;
                             ;       3 - return state of console 1 up/down position.                 ;
                             ;       5 - return state of console 2 left/right position.              ;
                             ;       7 - return state of console 2 up/down position.                 ;
                             ;                                                                       ;
                             ; The joystick values are returned in $C81B-$C81E, where the value      ;
                             ; returned in $C81B corresponds to the mask set in in $C81F, and so     ;
                             ; on and so forth.                                                      ;
                             ;                                                                       ;
                             ; The joystick conversion is dependent on which routine is called.      ;
                             ; Results for each routine are:                                         ;
                             ;                                                                       ;
                             ;       Joy_Digital:                                                    ;
                             ;               The return value will be:                               ;
                             ;                 < 0 if joystick is left of down of center.            ;
                             ;                 = 0 if joystick is centered.                          ;
                             ;                 > 0 if joystick is right or up of center.             ;
                             ;                                                                       ;
                             ;       Joy_Analog:                                                     ;
                             ;               A successive approximation algorithm is used to read    ;
                             ;               the actual value of the joystick pot, a signed value.   ;
                             ;               In this case, $C81A must be set to a power of 2, to     ;
                             ;               to control conversion resolution; 0x80 is least         ;
                             ;               accurate, and 0x00is most accurate.                     ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;                                                                       ;
                             ;       D-reg, X-reg trashed                                            ;
                             ;-----------------------------------------------------------------------;
                             
f1f5 : 7ac823           [ 7] Joy_Analog:     DEC     $C823           ;Set analog mode flag
f1f8 : 8ec81f           [ 3] Joy_Digital:    LDX     #Vec_Joy_Mux_1_X;Point to first pot
f1fb : a680             [ 6] LF1FB:          LDA     ,X+             ;Read it if enabled
f1fd : 260c             [ 3]                 BNE     LF20B
f1ff : 8cc823           [ 4] LF1FF:          CMPX    #$C823          ;Go back untl all pots read
f202 : 26f7             [ 3]                 BNE     LF1FB
f204 : 6f84             [ 6]                 CLR     ,X              ;X points to $C823, clear it
f206 : 8601             [ 2]                 LDA     #$01
f208 : 9700             [ 4]                 STA     <VIA_port_b     ;disable mux
f20a : 39               [ 5]                 RTS
                             
f20b : 9700             [ 4] LF20B:          STA     <VIA_port_b     ;enable mux and select pot
f20d : 0f01             [ 6]                 CLR     <VIA_port_a     ;output $00 to D/A
f20f : 0a00             [ 6]                 DEC     <VIA_port_b     ;disable mux
f211 : c660             [ 2]                 LDB     #$60            ;delay and end up with B=$80
f213 : 5c               [ 2] LF213:          INCB
f214 : 2afd             [ 3]                 BPL     LF213
f216 : b6c823           [ 5]                 LDA     $C823           ;check analog flag
f219 : 2b25             [ 3]                 BMI     LF240           ;branch if analog pot
f21b : 8620             [ 2]                 LDA     #$20
f21d : 0c00             [ 6]                 INC     <VIA_port_b     ;enable mux
f21f : 9500             [ 4]                 BITA    <VIA_port_b     ;test comparator
f221 : 270a             [ 3]                 BEQ     LF22D
f223 : c640             [ 2]                 LDB     #$40            ;output $40 to D/A
f225 : d701             [ 4]                 STB     <VIA_port_a
f227 : 9500             [ 4]                 BITA    <VIA_port_b     ;test comparator
f229 : 260b             [ 3]                 BNE     LF236
f22b : 2008             [ 3]                 BRA     LF235
                             
f22d : c6c0             [ 2] LF22D:          LDB     #$C0            ;output $C0 to D/A
f22f : d701             [ 4]                 STB     <VIA_port_a
f231 : 9500             [ 4]                 BITA    <VIA_port_b     ;test comparator
f233 : 2701             [ 3]                 BEQ     LF236
f235 : 5f               [ 2] LF235:          CLRB
f236 : e71b             [ 5] LF236:          STB     -5,X            ;store A/D result
f238 : 20c5             [ 3]                 BRA     LF1FF           ;go back for next pot
                             
f23a : 1f98             [ 6] LF23A:          TFR     B,A
f23c : 9a01             [ 4]                 ORA     <VIA_port_a
f23e : 9701             [ 4]                 STA     <VIA_port_a
f240 : 8620             [ 2] LF240:          LDA     #$20            ;test comparator
f242 : 9500             [ 4]                 BITA    <VIA_port_b
f244 : 2606             [ 3]                 BNE     LF24C           ;branch to go lower?
f246 : 1f98             [ 6]                 TFR     B,A
f248 : 9801             [ 4]                 EORA    <VIA_port_a
f24a : 9701             [ 4]                 STA     <VIA_port_a
f24c : 54               [ 2] LF24C:          LSRB                    ;try next bit position
f24d : f1c81a           [ 5]                 CMPB    Vec_Joy_Resltn  ;check for accuracy threshold
f250 : 26e8             [ 3]                 BNE     LF23A           ;go back if not finished
f252 : d601             [ 4]                 LDB     <VIA_port_a     ;read D/A value
f254 : 20e0             [ 3]                 BRA     LF236           ;go back to store it
                             
                             ;-----------------------------------------------------------------------;
                             ;       F256    Sound_Byte                                              ;
                             ;       F259    Sound_Byte_x                                            ;
                             ;       F25B    Sound_Byte_raw                                          ;
                             ;                                                                       ;
                             ; All of these routines cause a byte of music data to be written to     ;
                             ; the music chip.  Sound_Byte stores a shadow copy of the data into     ;
                             ; $C800-$C80E, and Sound_Byte_x stores a shadow copy into a 15 byte     ;
                             ; area pointed to by the X register.  Sound_Byte_raw does not store a   ;
                             ; shadow copy of the data at all.                                       ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       A-reg = which of the 15 sound chip registers to modify          ;
                             ;       B-reg = the byte of sound data                                  ;
                             ;       X-reg = 15 byte shadow area (Sound_Byte_x only)                 ;
                             ;                                                                       ;
                             ; EXIT: X-reg = $C800 (Sound_Byte only)                                 ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f256 : 8ec800           [ 3] Sound_Byte:     LDX     #Vec_Snd_Shadow ;point to shadow memory
f259 : e786             [ 5] Sound_Byte_x:   STB     A,X
f25b : 9701             [ 4] Sound_Byte_raw: STA     <VIA_port_a     ;store register select byte
f25d : 8619             [ 2]                 LDA     #$19            ;sound BDIR on, BC1 on, mux off
f25f : 9700             [ 4]                 STA     <VIA_port_b
f261 : 8601             [ 2]                 LDA     #$01            ;sound BDIR off, BC1 off, mux off
f263 : 9700             [ 4]                 STA     <VIA_port_b
f265 : 9601             [ 4]                 LDA     <VIA_port_a     ;read sound chip status (?)
f267 : d701             [ 4]                 STB     <VIA_port_a     ;store data byte
f269 : c611             [ 2]                 LDB     #$11            ;sound BDIR on, BC1 off, mux off
f26b : d700             [ 4]                 STB     <VIA_port_b
f26d : c601             [ 2]                 LDB     #$01            ;sound BDIR off, BC1 off, mux off
f26f : d700             [ 4]                 STB     <VIA_port_b
f271 : 39               [ 5]                 RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F272    Clear_Sound                                             ;
                             ;                                                                       ;
                             ; This routine clears the 15 registers on the music chip and the soft   ;
                             ; copy of their values (C800-C80E), by writing a byte of 0 to each      ;
                             ; register.  This causes the sound chip to not make any sounds.         ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;                                                                       ;
                             ;       D-reg, X-reg trashed                                            ;
                             ;-----------------------------------------------------------------------;
                             
f272 : cc0e00           [ 3] Clear_Sound:    LDD     #$0E00
f275 : 8ddf             [ 7] LF275:          BSR     Sound_Byte
f277 : 4a               [ 2]                 DECA
f278 : 2afb             [ 3]                 BPL     LF275
f27a : 7ef533           [ 4]                 JMP     Init_Music_Buf
                             
                             ;-----------------------------------------------------------------------;
                             ;       F27D    Sound_Bytes                                             ;
                             ;       F284    Sound_Bytes_x? (apparently never used)                  ;
                             ;                                                                       ;
                             ; This routine copies a block of sound information into the sound       ;
                             ; chip buffer (at $C800-$C80E) and into the registers on the music      ;
                             ; chip.  The format for the block of sound data is as follows:          ;
                             ;                                                                       ;
                             ;   (register number), (music data),                                    ;
                             ;   (register number), (music data),                                    ;
                             ;         .                  .                                          ;
                             ;         .                  .                                          ;
                             ;       0xFF                                                            ;
                             ;                                                                       ;
                             ; As long as the register number is >= 0, then the music data will be   ;
                             ; copied; however, as soon as a register number < 0 is encountered,     ;
                             ; the copy will stop.                                                   ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       U-reg = pointer to the block of sound data                      ;
                             ;                                                                       ;
                             ;       D-reg, X-reg, U-reg trashed                                     ;
                             ;-----------------------------------------------------------------------;
                             
f27d : 8ec800           [ 3] Sound_Bytes:    LDX     #Vec_Snd_Shadow ;Point to shadow memory
f280 : 2002             [ 3]                 BRA     Sound_Bytes_x
                             
f282 : 8dd5             [ 7] LF282:          BSR     Sound_Byte_x    ;Update the sound register
f284 : ecc1             [ 8] Sound_Bytes_x:  LDD     ,U++            ;Get next next pair of bytes
f286 : 2afa             [ 3]                 BPL     LF282           ;Go back if not end of list
f288 : 39               [ 5]                 RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F289    Do_Sound                                                ;
                             ;       F28C    Do_Sound_x? (apparently never used)                     ;
                             ;                                                                       ;
                             ; This routine will start/continue making the sound which was first     ;
                             ; set up by your call to Init_Music.  This routine should normally      ;
                             ; be called right after your call to Wait_Recal.  It takes the next     ;
                             ; music information, contained in the music buffer $C83F-$C84C, and     ;
                             ; updates only those registers which differ from the last data written  ;
                             ; to the sound chip.                                                    ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;                                                                       ;
                             ;       D-reg, X-reg, U-reg trashed                                     ;
                             ;-----------------------------------------------------------------------;
                             
f289 : 8ec800           [ 3] Do_Sound:       LDX     #Vec_Snd_Shadow ;point to shadow memory
f28c : cec83f           [ 3] Do_Sound_x:     LDU     #Vec_Music_Work ;point to sound buffer
f28f : 860d             [ 2]                 LDA     #$0D            ;init count for 14 registers
f291 : e6c0             [ 6] LF291:          LDB     ,U+             ;get next register
f293 : e186             [ 5]                 CMPB    A,X             ;skip if unchanged
f295 : 2702             [ 3]                 BEQ     LF299
f297 : 8dc0             [ 7]                 BSR     Sound_Byte_x    ;else update register
f299 : 4a               [ 2] LF299:          DECA                    ;go back for next register
f29a : 2af5             [ 3]                 BPL     LF291
f29c : 39               [ 5]                 RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F29D    Intensity_1F                                            ;
                             ;       F2A1    Intensity_3F                                            ;
                             ;       F2A5    Intensity_5F                                            ;
                             ;       F2A9    Intensity_7F                                            ;
                             ;       F2AB    Intensity_a                                             ;
                             ;                                                                       ;
                             ; Each of these routines are responsible for setting the vector/dot     ;
                             ; intensity (commonly used to denote the z axis) to a specific value.   ;
                             ; 0x00 is the lowest intensity, and 0xFF is the brightest intensity.    ;
                             ; The intensity must be reset to the desired value after each call      ;
                             ; to Wait_Recal; however, it can also be changed at any other time.     ;
                             ; A copy of the new intensity value is saved in $C827.                  ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       A-reg = intensity (Intensity_a only)                            ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f29d : 861f             [ 2] Intensity_1F:   LDA     #$1F
f29f : 200a             [ 3]                 BRA     Intensity_a
                             
f2a1 : 863f             [ 2] Intensity_3F:   LDA     #$3F
f2a3 : 2006             [ 3]                 BRA     Intensity_a
                             
f2a5 : 865f             [ 2] Intensity_5F:   LDA     #$5F
f2a7 : 2002             [ 3]                 BRA     Intensity_a
                             
f2a9 : 867f             [ 2] Intensity_7F:   LDA     #$7F
f2ab : 9701             [ 4] Intensity_a:    STA     <VIA_port_a     ;Store intensity in D/A
f2ad : b7c827           [ 5]                 STA     Vec_Brightness  ;Save intensity in $C827
f2b0 : cc0504           [ 3]                 LDD     #$0504          ;mux disabled channel 2
f2b3 : 9700             [ 4]                 STA     <VIA_port_b
f2b5 : d700             [ 4]                 STB     <VIA_port_b     ;mux enabled channel 2
f2b7 : d700             [ 4]                 STB     <VIA_port_b     ;do it again just because
f2b9 : c601             [ 2]                 LDB     #$01
f2bb : d700             [ 4]                 STB     <VIA_port_b     ;turn off mux
f2bd : 39               [ 5]                 RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F2BE    Dot_ix_b                                                ;
                             ;       F2C1    Dot_ix                                                  ;
                             ;                                                                       ;
                             ; These routines draw a dot at the relative y and relative x            ;
                             ; position pointed to by the X register.  Afterwards, the X register    ;
                             ; is incremented by 2.                                                  ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       X-reg points to the (y,x) coordinate pair                       ;
                             ;       B-reg contains the intensity (Dot_ix_b only)                    ;
                             ;       $C828 contains the intensity (Dot_ix only)                      ;
                             ;                                                                       ;
                             ; EXIT  X-reg incremented by 2                                          ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f2be : f7c828           [ 5] Dot_ix_b:       STB     Vec_Dot_Dwell
f2c1 : ec81             [ 8] Dot_ix:         LDD     ,X++
                             
                             ;-----------------------------------------------------------------------;
                             ;       F2C3    Dot_d                                                   ;
                             ;                                                                       ;
                             ; This routine draws a dot at the relative y and relative x position    ;
                             ; contained in the D register.  The intensity used is the value         ;
                             ; already stored in $C828.                                              ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       A-reg = relative Y coordinate                                   ;
                             ;       B-reg = relative X coordinate                                   ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f2c3 : 8d4d             [ 7] Dot_d:          BSR     Moveto_d
                             
                             ;-----------------------------------------------------------------------;
                             ;       F2C5    Dot_here                                                ;
                             ;                                                                       ;
                             ; This routine draws a dot at the current pen position.                 ;
                             ; The intensity used is the value already stored in $C828.              ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f2c5 : 86ff             [ 2] Dot_here:       LDA     #$FF            ;Set pattern to all 1's
f2c7 : 970a             [ 4]                 STA     <VIA_shift_reg  ;Store in VIA shift register
f2c9 : f6c828           [ 5]                 LDB     Vec_Dot_Dwell   ;Get dot dwell (brightness)
f2cc : 5a               [ 2] LF2CC:          DECB                    ;Delay leaving beam in place
f2cd : 26fd             [ 3]                 BNE     LF2CC
f2cf : 0f0a             [ 6]                 CLR     <VIA_shift_reg  ;Blank beam in VIA shift register
f2d1 : 39               [ 5]                 RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F2D5    Dot_List                                                ;
                             ;                                                                       ;
                             ; This routine draws a series of dots, using the intensity already      ;
                             ; set up in $C828.  The format for the dot list, which is pointed to    ;
                             ; by the X register, is:                                                ;
                             ;                                                                       ;
                             ;     ( rel y, rel x), (rel y, rel x), .....                            ;
                             ;                                                                       ;
                             ; The number of dots to draw is specified in $C823.                     ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       X-reg points to the list of dot coordinates                     ;
                             ;       $C823 specifies the number of dots to draw                      ;
                             ;                                                                       ;
                             ; EXIT: X-reg points to next byte after list                            ;
                             ;       $C823 cleared                                                   ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f2d2 : 7ac823           [ 7] LF2D2:          DEC     $C823           ;Decrement counter
f2d5 : 8dea             [ 7] Dot_List:       BSR     Dot_ix          ;Draw next dot
f2d7 : b6c823           [ 5]                 LDA     $C823           ;Check counter
f2da : 26f6             [ 3]                 BNE     LF2D2           ;Go back until finished
f2dc : 2076             [ 3]                 BRA     Reset0Ref       ;Go to Reset0Ref
                             
                             ;-----------------------------------------------------------------------;
                             ;       F2DE    Dot_List_Reset                                          ;
                             ;                                                                       ;
                             ; This routine draws a series of dots, specified by the list pointed    ;
                             ; to by the X register.  The list has the following format:             ;
                             ;                                                                       ;
                             ;     mode, relative y, relative x,                                     ;
                             ;     mode, relative y, relative x,                                     ;
                             ;       .      .           .                                            ;
                             ;       .      .           .                                            ;
                             ;     mode, relative y, relative x                                      ;
                             ;     0x01                                                              ;
                             ;                                                                       ;
                             ; This routine will continue to traverse the list, until a mode > 0     ;
                             ; is encountered; at that point, it will reset the zero reference       ;
                             ; (the integrators).                                                    ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       X-reg points to the dot list                                    ;
                             ;                                                                       ;
                             ; EXIT: X-reg points to next byte after the terminator                  ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f2de : a680             [ 6] Dot_List_Reset: LDA     ,X+             ;get mode byte
f2e0 : 2e72             [ 3]                 BGT     Reset0Ref       ;if >0 go to Reset0Ref
f2e2 : 8ddd             [ 7]                 BSR     Dot_ix          ;plot the dot
f2e4 : 20f8             [ 3]                 BRA     Dot_List_Reset  ;dot_list@x_&_reset
                             
                             ;-----------------------------------------------------------------------;
                             ;       F2E6    Recalibrate                                             ;
                             ;                                                                       ;
                             ;       Recalibrate the vector generators.                              ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;                                                                       ;
                             ;       D-reg, X-reg trashed                                            ;
                             ;-----------------------------------------------------------------------;
                             
f2e6 : 8ef9f0           [ 3] Recalibrate:    LDX     #Recal_Points   ;$7F7F
f2e9 : 8d1d             [ 7]                 BSR     Moveto_ix_FF
f2eb : bdf36b           [ 9]                 JSR     Reset0Int
f2ee : 8d20             [ 7]                 BSR     Moveto_ix       ;$8080
f2f0 : 2062             [ 3]                 BRA     Reset0Ref
                             
                             ;-----------------------------------------------------------------------;
                             ;       F2F2    Moveto_x_7F                                             ;
                             ;                                                                       ;
                             ; This routine forces the scale factor to 0x7F, and then moves the      ;
                             ; pen to the location pointed to by the X register.  The relative y     ;
                             ; and relative x coordinates are both 2 byte quantities; however,       ;
                             ; only the most signicant byte of each is of any interest.  The values  ;
                             ; pointed to by the X register have the following format:               ;
                             ;                                                                       ;
                             ;     X => (rel y hi),(rel y lo), (rel x hi), (rel x lo)                ;
                             ;                                                                       ;
                             ; The position moved to is obtained by y=(0,x) & x=(2,x).               ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       X-reg points to double-sized coordinate pair                    ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f2f2 : c67f             [ 2] Moveto_x_7F:    LDB     #$7F            ;Set scale factor to $7F
f2f4 : d704             [ 4]                 STB     <VIA_t1_cnt_lo
f2f6 : a684             [ 4]                 LDA     ,X              ;Get y high
f2f8 : e602             [ 5]                 LDB     2,X             ;Get x high
f2fa : 2016             [ 3]                 BRA     Moveto_d
                             
                             ;-----------------------------------------------------------------------;
                             ;       F2FC    Moveto_d_7F                                             ;
                             ;                                                                       ;
                             ; This routine forces the scale factor to 0x7F, and then moves the      ;
                             ; pen to the position specified in the D register.                      ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       A-reg = relative Y coordinate                                   ;
                             ;       B-reg = relative X coordinate                                   ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f2fc : 9701             [ 4] Moveto_d_7F:    STA     <VIA_port_a     ;Store Y in D/A register
f2fe : 3406             [ 7]                 PSHS    D               ;Save D-register on stack
f300 : 867f             [ 2]                 LDA     #$7F            ;Set scale factor to $7F
f302 : 9704             [ 4]                 STA     <VIA_t1_cnt_lo
f304 : 0f00             [ 6]                 CLR     <VIA_port_b     ;Enable mux
f306 : 2010             [ 3]                 BRA     LF318
                             
                             ;-----------------------------------------------------------------------;
                             ;       F308    Moveto_ix_FF                                            ;
                             ;       F30C    Moveto_ix_7F                                            ;
                             ;       F30E    Moveto_ix_b                                             ;
                             ;                                                                       ;
                             ; These routines force the scale factor to 0xFF, 0X7F, or the           ;
                             ; A register, and then move the pen to the (y,x) position pointed to    ;
                             ; by the X-register.  The X-register is then incremented by 2.          ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       X-reg points to the (y,x) coordinate pair                       ;
                             ;       B-reg contains the scale factor (Moveto_ix_b only)              ;
                             ;                                                                       ;
                             ; EXIT: X-reg has been incremented by 2                                 ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f308 : c6ff             [ 2] Moveto_ix_FF:   LDB     #$FF
f30a : 2002             [ 3]                 BRA     Moveto_ix_b
                             
f30c : c67f             [ 2] Moveto_ix_7F:   LDB     #$7F
f30e : d704             [ 4] Moveto_ix_b:    STB     <VIA_t1_cnt_lo  ;Set scale factor
                             
                             ;-----------------------------------------------------------------------;
                             ;       F310    Moveto_ix                                               ;
                             ;                                                                       ;
                             ; This routine uses the current scale factor, and moves the pen to the  ;
                             ; (y,x) position pointed to by the X register.  The X register is then  ;
                             ; incremented by 2.                                                     ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       X-reg points to the (y,x) coordinate pair                       ;
                             ;                                                                       ;
                             ; EXIT: X-reg has been incremented by 2                                 ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f310 : ec81             [ 8] Moveto_ix:      LDD     ,X++
                             
                             ;-----------------------------------------------------------------------;
                             ;       F312    Moveto_d                                                ;
                             ;                                                                       ;
                             ; This routine uses the current scale factor, and moves the pen to the  ;
                             ; (y,x) position specified in D register.                               ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       A-reg = Y coordinate                                            ;
                             ;       B-reg = X coordinate                                            ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f312 : 9701             [ 4] Moveto_d:       STA     <VIA_port_a     ;Store Y in D/A register
f314 : 0f00             [ 6]                 CLR     <VIA_port_b     ;Enable mux
f316 : 3406             [ 7]                 PSHS    D               ;Save D-register on stack
f318 : 86ce             [ 2] LF318:          LDA     #$CE            ;Blank low, zero high?
f31a : 970c             [ 4]                 STA     <VIA_cntl
f31c : 0f0a             [ 6]                 CLR     <VIA_shift_reg  ;Clear shift regigster
f31e : 0c00             [ 6]                 INC     <VIA_port_b     ;Disable mux
f320 : d701             [ 4]                 STB     <VIA_port_a     ;Store X in D/A register
f322 : 0f05             [ 6]                 CLR     <VIA_t1_cnt_hi  ;timer 1 count high
f324 : 3506             [ 7]                 PULS    D               ;Get back D-reg
f326 : bdf584           [ 9]                 JSR     Abs_a_b
f329 : e77f             [ 5]                 STB     -1,S
f32b : aa7f             [ 5]                 ORA     -1,S
f32d : c640             [ 2]                 LDB     #$40
f32f : 8140             [ 2]                 CMPA    #$40
f331 : 2312             [ 3]                 BLS     LF345
f333 : 8164             [ 2]                 CMPA    #$64
f335 : 2304             [ 3]                 BLS     LF33B
f337 : 8608             [ 2]                 LDA     #$08
f339 : 2002             [ 3]                 BRA     LF33D
                             
f33b : 8604             [ 2] LF33B:          LDA     #$04            ;Wait for timer 1
f33d : d50d             [ 4] LF33D:          BITB    <VIA_int_flags
f33f : 27fc             [ 3]                 BEQ     LF33D
f341 : 4a               [ 2] LF341:          DECA                    ;Delay a moment
f342 : 26fd             [ 3]                 BNE     LF341
f344 : 39               [ 5]                 RTS
                             
f345 : d50d             [ 4] LF345:          BITB    <VIA_int_flags  ;Wait for timer 1
f347 : 27fc             [ 3]                 BEQ     LF345
f349 : 39               [ 5]                 RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F34A    Reset0Ref_D0                                            ;
                             ;                                                                       ;
                             ; This routine sets the DP register to D0, and then resets the          ;
                             ; integrators.                                                          ;
                             ;                                                                       ;
                             ; EXIT: DP = $D0                                                        ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f34a : bdf1aa           [ 9] Reset0Ref_D0:   JSR     DP_to_D0
f34d : 2005             [ 3]                 BRA     Reset0Ref
                             
                             ;-----------------------------------------------------------------------;
                             ;       F34F    Check0Ref                                               ;
                             ;                                                                       ;
                             ; This routine will check to see if the Reset0Ref enable flag ($C824)   ;
                             ; is set, and if it is, then it will reset the integrators by calling   ;
                             ; Reset0Ref.                                                            ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       $C824 = enable flag                                             ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f34f : b6c824           [ 5] Check0Ref:      LDA     Vec_0Ref_Enable
f352 : 2716             [ 3]                 BEQ     LF36A_RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F354    Reset0Ref                                               ;
                             ;                                                                       ;
                             ; This routine zeros the integrators, and resets the pen back to the    ;
                             ; origin.  It leaves the integrators in zero mode, so nothing can be    ;
                             ; drawn until a move is done, or $D00C is set to 0xCE to bring /ZERO    ;
                             ; high.  This routine must be called every so often, to prevent your    ;
                             ; vectors from getting out of whack.                                    ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f354 : cc00cc           [ 3] Reset0Ref:      LDD     #$00CC
f357 : d70c             [ 4]                 STB     <VIA_cntl       ;/BLANK low and /ZERO low
f359 : 970a             [ 4]                 STA     <VIA_shift_reg  ;clear shift register
                             ;-----------------------------------------------------------------------;
                             ;       F35B    Reset_Pen                                               ;
                             ;                                                                       ;
                             ;       Reset the pen to the origin.                                    ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f35b : cc0302           [ 3] Reset_Pen:      LDD     #$0302
f35e : 0f01             [ 6]                 CLR     <VIA_port_a     ;clear D/A register
f360 : 9700             [ 4]                 STA     <VIA_port_b     ;mux=1, disable mux
f362 : d700             [ 4]                 STB     <VIA_port_b     ;mux=1, enable mux
f364 : d700             [ 4]                 STB     <VIA_port_b     ;do it again
f366 : c601             [ 2]                 LDB     #$01
f368 : d700             [ 4]                 STB     <VIA_port_b     ;disable mux
f36a : 39               [ 5] LF36A_RTS:      RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F36B    Reset0Int                                               ;
                             ;                                                                       ;
                             ; This routine resets the integrators to zero.  It leaves the           ;
                             ; integrators in zero mode, so nothing can be drawn until a move is     ;
                             ; done, or D00C is set to 0xCE.                                         ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f36b : cc00cc           [ 3] Reset0Int:      LDD     #$00CC
f36e : d70c             [ 4]                 STB     <VIA_cntl       ;blank low and zero low
f370 : 970a             [ 4]                 STA     <VIA_shift_reg  ;clear shift register
f372 : 39               [ 5]                 RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F373    Print_Str_hwyx                                          ;
                             ;                                                                       ;
                             ; This routine prints a single string (up to an 0x80).  The parameter   ;
                             ; block describing the string is pointed to by the U register.  The     ;
                             ; format for the parameter block is as follows:                         ;
                             ;                                                                       ;
                             ;       height, width, rel y, rel x, string, 0x80                       ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       U-reg points to the string list                                 ;
                             ;                                                                       ;
                             ; EXIT: U-reg points to the byte after the terminating 0x80             ;
                             ;                                                                       ;
                             ;       D-reg, X-reg trashed                                            ;
                             ;-----------------------------------------------------------------------;
                             
f373 : ecc1             [ 8] Print_Str_hwyx: LDD     ,U++
f375 : fdc82a           [ 6]                 STD     Vec_Text_HW
                             
                             ;-----------------------------------------------------------------------;
                             ;       F378    Print_Str_yx                                            ;
                             ;                                                                       ;
                             ; This routine prints a single string (up to an 0x80), using the        ;
                             ; default height and width, as stored in $C82A.  The parameter block    ;
                             ; describing the string is pointed to by the U register.  The format    ;
                             ; for the parameter block is as follows:                                ;
                             ;                                                                       ;
                             ;       rel y, rel x, string, 0x80                                      ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       U-reg points to the string list                                 ;
                             ;                                                                       ;
                             ; EXIT: U-reg points to the byte after the terminating 0x80             ;
                             ;                                                                       ;
                             ;       D-reg, X-reg trashed                                            ;
                             ;-----------------------------------------------------------------------;
                             
f378 : ecc1             [ 8] Print_Str_yx:   LDD     ,U++
                             
                             ;-----------------------------------------------------------------------;
                             ;       F37A    Print_Str_d                                             ;
                             ;                                                                       ;
                             ; This routine prints a single string (up to an 0x80), using the        ;
                             ; default height and width, as stored in $C82A, and at the pen position ;
                             ; specified in the D register.  The parameter block describing the      ;
                             ; string is pointed to by the U register.  The format for the           ;
                             ; parameter block is as follows:                                        ;
                             ;                                                                       ;
                             ;     string, 0x80                                                      ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       U-reg points to string list                                     ;
                             ;       A-reg = relative Y position                                     ;
                             ;       B-reg = relative X position                                     ;
                             ;                                                                       ;
                             ; EXIT: U-reg points to the byte after the terminating 0x80             ;
                             ;                                                                       ;
                             ;       D-reg, X-reg trashed                                            ;
                             ;-----------------------------------------------------------------------;
                                noopt        ; neccessary for assembling, this jsr is allways
                                             ; optimized to a short branch otherwise
f37a : bdf2fc           [ 8] Print_Str_d:    JSR     >Moveto_d_7F
                                opt
f37d : bdf575           [ 9]                 JSR     Delay_1
f380 : 7ef495           [ 4]                 JMP     Print_Str
                             
                             ;-----------------------------------------------------------------------;
                             ;       F385    Print_List_hw                                           ;
                             ;                                                                       ;
                             ; This displays the group of strings described by the parameter block   ;
                             ; which is pointed to by the U register.  The string parameter block    ;
                             ; has the following format:                                             ;
                             ;                                                                       ;
                             ;     height, width, rel y, rel x, string, 0x80,                        ;
                             ;     height, width, rel y, rel x, string, 0x80,                        ;
                             ;     0x00                                                              ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       U-reg points to string list                                     ;
                             ;                                                                       ;
                             ; EXIT: U-reg points to null terminator byte                            ;
                             ;                                                                       ;
                             ;       D-reg, X-reg trashed                                            ;
                             ;-----------------------------------------------------------------------;
                             
f383 : 8dee             [ 7] LF383:          BSR     Print_Str_hwyx
f385 : a6c4             [ 4] Print_List_hw:  LDA     ,U
f387 : 26fa             [ 3]                 BNE     LF383
f389 : 39               [ 5]                 RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F38A    Print_List                                              ;
                             ;       F38C    Print_List_chk                                          ;
                             ;                                                                       ;
                             ; This displays the group of strings described by the parameter block   ;
                             ; which is pointed to by the U register.  The string parameter block    ;
                             ; has the following format:                                             ;
                             ;                                                                       ;
                             ;       rel y, rel x, string, 0x80,                                     ;
                             ;       rel y, rel x, string, 0x80,                                     ;
                             ;       0x00                                                            ;
                             ;                                                                       ;
                             ; The current string height and width to which the hardware is set will ;
                             ; be used.                                                              ;
                             ;                                                                       ;
                             ; Print_List routine will first print the passed-in string, and THEN    ;
                             ; check for the end of the string list.  Print_List_Chk will check for  ;
                             ; the end of the string list first.                                     ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       U-reg points to string list                                     ;
                             ;                                                                       ;
                             ; EXIT: U-reg points to null terminator byte                            ;
                             ;                                                                       ;
                             ;       D-reg, X-reg trashed                                            ;
                             ;-----------------------------------------------------------------------;
                             
f38a : 8dec             [ 7] Print_List:     BSR     Print_Str_yx
f38c : a6c4             [ 4] Print_List_Chk: LDA     ,U
f38e : 26fa             [ 3]                 BNE     Print_List
f390 : 39               [ 5]                 RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F391    Print_Ships_x                                           ;
                             ;       F393    Print_Ships                                             ;
                             ;                                                                       ;
                             ; This routine displays the number of ships passed in the B register    ;
                             ; followed by a minus sign and the ship icon character passed in the    ;
                             ; A register at the (y,x) coordinates passed in the X register.  If     ;
                             ; the B-register > 9, then the infinity symbol is displayed.            ;
                             ;                                                                       ;
                             ; Note: This routine uses bytes at a negative offset from the stack as  ;
                             ;       temporary storage, so hopefully an IRQ won't happen until the   ;
                             ;       string is finished bring printed!                               ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       A-reg = ship icon character                                     ;
                             ;       B-reg = number of ships                                         ;
                             ;       X-reg = (y,x) coordinates (Print_Ships only)                    ;
                             ;       X-reg points to (y,x) coordinates (Print_Ships_x only)          ;
                             ;                                                                       ;
                             ;       D-reg, X-reg, U-reg trashed                                     ;
                             ;-----------------------------------------------------------------------;
                             
f391 : ae84             [ 5] Print_Ships_x:  LDX     ,X
f393 : 3404             [ 6] Print_Ships:    PSHS    B               ;Save B-reg
f395 : c680             [ 2]                 LDB     #$80
f397 : 3378             [ 5]                 LEAU    -8,S            ;Point U into the stack
f399 : 3606             [ 7]                 PSHU    D               ;Save A-reg and a terminator
f39b : 3502             [ 6]                 PULS    A               ;Get back B-reg
f39d : 8109             [ 2]                 CMPA    #$09            ;If B-reg >9 then
f39f : 2302             [ 3]                 BLS     LF3A3
f3a1 : 863c             [ 2]                 LDA     #$6C-$30        ;load $6C = infinty symbol
f3a3 : 8b30             [ 2] LF3A3:          ADDA    #$30
f3a5 : c62d             [ 2]                 LDB     #'-'
f3a7 : 3606             [ 7]                 PSHU    D               ;Push digit and minus sign
f3a9 : 3610             [ 7]                 PSHU    X               ;Push (y,x) coordinates
f3ab : 20cb             [ 3]                 BRA     Print_Str_yx    ;Print it
                             
                             ;-----------------------------------------------------------------------;
                             ;       F3AD    Mov_Draw_VLc_a                                          ;
                             ;                                                                       ;
                             ; This routine moves to the first location specified in vector list,    ;
                             ; and then draws lines between the rest of coordinates in the list.     ;
                             ; The number of vectors to draw is specified as the first byte in the   ;
                             ; vector list.  The current scale factor is used.  The vector list has  ;
                             ; the following format:                                                 ;
                             ;                                                                       ;
                             ;       count, rel y, rel x, rel y, rel x, ...                          ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       X-reg points to the vector list                                 ;
                             ;                                                                       ;
                             ; EXIT: X-reg points to next byte after list                            ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f3ad : a680             [ 6] Mov_Draw_VLc_a: LDA     ,X+
f3af : 2008             [ 3]                 BRA     Mov_Draw_VL_a
                             
                             ;-----------------------------------------------------------------------;
                             ;       F3B1    Mov_Draw_VL_b                                           ;
                             ;                                                                       ;
                             ; This routine moves to the first location specified in vector list,    ;
                             ; and then draws lines between the rest of coordinates in the list.     ;
                             ; The vector list has the following format:                             ;
                             ;                                                                       ;
                             ;       rel y, rel x, rel y, rel x, ...                                 ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       B-reg = scale factor                                            ;
                             ;       $C823 = number of vectors to draw                               ;
                             ;       X-reg points to the vector list                                 ;
                             ;                                                                       ;
                             ; EXIT: $C823 is cleared                                                ;
                             ;                                                                       ;
                             ; EXIT: X-reg points to next byte after list                            ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f3b1 : d704             [ 4] Mov_Draw_VL_b:  STB     <VIA_t1_cnt_lo  ;Set scale factor
f3b3 : 2007             [ 3]                 BRA     Mov_Draw_VL
                             
                             ;-----------------------------------------------------------------------;
                             ;       F3B5    Mov_Draw_VLcs                                           ;
                             ;                                                                       ;
                             ; This routine moves to the first location specified in vector list,    ;
                             ; and then draws lines between the rest of coordinates in the list.     ;
                             ; The number of vectors to draw is specified as the first byte in the   ;
                             ; vector list, and the scale factor is the second byte in the vector    ;
                             ; list.  The vector list has the following format:                      ;
                             ;                                                                       ;
                             ;       count, scale, rel y, rel x, rel y, rel x, ...                   ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       X-reg points to the vector list                                 ;
                             ;                                                                       ;
                             ; EXIT: X-reg points to next byte after list                            ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f3b5 : ec81             [ 8] Mov_Draw_VLcs:  LDD     ,X++
                             
                             ;-----------------------------------------------------------------------;
                             ;       F3B7    Mov_Draw_VL_ab                                          ;
                             ;       F3B9    Mov_Draw_VL_a                                           ;
                             ;                                                                       ;
                             ; This routine moves to the first location specified in vector list,    ;
                             ; and then draws lines between the rest of coordinates in the list.     ;
                             ; The vector list has the  following format:                            ;
                             ;                                                                       ;
                             ;       rel y, rel x, rel y, rel x, ...                                 ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       A-reg = number of vectors to draw                               ;
                             ;       B-reg = scale factor to use (Draw_VL_ab only)                   ;
                             ;       X-reg points to the vector list                                 ;
                             ;                                                                       ;
                             ; EXIT: X-reg points to next byte after list                            ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f3b7 : d704             [ 4] Mov_Draw_VL_ab: STB     <VIA_t1_cnt_lo  ;Set scale factor
f3b9 : b7c823           [ 5] Mov_Draw_VL_a:  STA     $C823
                             
                             ;-----------------------------------------------------------------------;
                             ;       F3BC    Mov_Draw_VL                                             ;
                             ;       F3BE    Mov_Draw_VL_d                                           ;
                             ;                                                                       ;
                             ; This routine moves to the first location specified in vector list,    ;
                             ; and then draws lines between the rest of coordinates in the list.     ;
                             ; The vector list has the following format:                             ;
                             ;                                                                       ;
                             ;       rel y, rel x, rel y, rel x, ...                                 ;
                             ;                                                                       ;
                             ; Draw_VL_d starts at the (y,x) coordinates specified in the D register ;
                             ; and ignores the first pair of coordinates in the vector list.         ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       $C823 = number of vectors to draw                               ;
                             ;       D-reg = start coordinate (Draw_VL_d only)                       ;
                             ;       X-reg points to the vector list (2,X for Mov_Draw_VL_d)         ;
                             ;                                                                       ;
                             ; EXIT: $C823 is cleared                                                ;
                             ;                                                                       ;
                             ; EXIT: X-reg points to next byte after list                            ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f3bc : ec84             [ 5] Mov_Draw_VL:    LDD     ,X              ;Get next coordinate pair
f3be : 9701             [ 4] Mov_Draw_VL_d:  STA     <VIA_port_a     ;Send Y to A/D
f3c0 : 0f00             [ 6]                 CLR     <VIA_port_b     ;Enable mux
f3c2 : 3002             [ 5]                 LEAX    2,X             ;Point to next coordinate pair
f3c4 : 12               [ 2]                 NOP                     ;Wait a moment
f3c5 : 0c00             [ 6]                 INC     <VIA_port_b     ;Disable mux
f3c7 : d701             [ 4]                 STB     <VIA_port_a     ;Send X to A/D
f3c9 : cc0000           [ 3]                 LDD     #$0000          ;Shift reg=0 (no draw), T1H=0
f3cc : 201f             [ 3]                 BRA     LF3ED           ;A->D00A, B->D005
                             
                             ;-----------------------------------------------------------------------;
                             ;       F3CE    Draw_VLc                                                ;
                             ;                                                                       ;
                             ; This routine draws vectors between the set of (y,x) points pointed    ;
                             ; to by the X register.  The number of vectors to draw is specified     ;
                             ; as the first byte in the vector list.  The current scale factor is    ;
                             ; used.  The vector list has the following format:                      ;
                             ;                                                                       ;
                             ;       count, rel y, rel x, rel y, rel x, ...                          ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       X-reg points to the vector list                                 ;
                             ;                                                                       ;
                             ; EXIT: X-reg points to next byte after list                            ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f3ce : a680             [ 6] Draw_VLc:       LDA     ,X+
f3d0 : 2008             [ 3]                 BRA     Draw_VL_a
                             
                             ;-----------------------------------------------------------------------;
                             ;       F3D2    Draw_VL_b                                               ;
                             ;                                                                       ;
                             ; This routine draws vectors between the set of (y,x) points pointed to ;
                             ; by the X register.  The vector list has the following format:         ;
                             ;                                                                       ;
                             ;       rel y, rel x, rel y, rel x, ...                                 ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       B-reg = the scale factor                                        ;
                             ;       X-reg points to the vector list                                 ;
                             ;                                                                       ;
                             ; EXIT: X-reg points to next byte after list                            ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f3d2 : d704             [ 4] Draw_VL_b:      STB     <VIA_t1_cnt_lo  ;Set scale factor
f3d4 : 2007             [ 3]                 BRA     Draw_VL
                             
                             ;-----------------------------------------------------------------------;
                             ;       F3D6    Draw_VLcs                                               ;
                             ;                                                                       ;
                             ; This routine draws vectors between the set of (y,x) points pointed    ;
                             ; to by the X register.  The number of vectors to draw is specified     ;
                             ; as the first byte in the vector list.  The scale factor is specified  ;
                             ; as the second byte in the vector list. The vector list has the        ;
                             ; following format:                                                     ;
                             ;                                                                       ;
                             ;       count, scale, rel y, rel x, rel y, rel x, ...                   ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       X-reg points to the vector list                                 ;
                             ;                                                                       ;
                             ; EXIT: X-reg points to next byte after list                            ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f3d6 : ec81             [ 8] Draw_VLcs:      LDD     ,X++
                             
                             ;-----------------------------------------------------------------------;
                             ;       F3D8    Draw_VL_ab                                              ;
                             ;                                                                       ;
                             ; This routine draws vectors between the set of (y,x) points pointed    ;
                             ; to by the X register.  The vector list has the following format:      ;
                             ;                                                                       ;
                             ;       rel y, rel x, rel y, rel x, ...                                 ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       A-reg = the number of vectors to draw                           ;
                             ;       B-reg = the scale factor                                        ;
                             ;       X-reg points to the vector list                                 ;
                             ;                                                                       ;
                             ; EXIT: X-reg points to next byte after list                            ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f3d8 : d704             [ 4] Draw_VL_ab:     STB     <VIA_t1_cnt_lo
                             
                             ;-----------------------------------------------------------------------;
                             ;       F3DA    Draw_VL_a                                               ;
                             ;                                                                       ;
                             ; This routine draws vectors between the set of (y,x) points pointed    ;
                             ; to by the register.  The current scale factor is used.  The vector    ;
                             ; list has the following format:                                        ;
                             ;                                                                       ;
                             ;       rel y, rel x, rel y, rel x, ...                                 ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       A-reg = the number of vectors to draw                           ;
                             ;       X-reg points to the vector list                                 ;
                             ;                                                                       ;
                             ; EXIT: X-reg points to next byte after list                            ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f3da : b7c823           [ 5] Draw_VL_a:      STA     $C823
                             
                             ;-----------------------------------------------------------------------;
                             ;       F3DD    Draw_VL                                                 ;
                             ;                                                                       ;
                             ; This routine draws vectors between the set of (y,x) points pointed    ;
                             ; to by the X register.  The number of vectors to draw must already be  ;
                             ; specified in $C823.  The current scale factor is used.  The vector    ;
                             ; list has the following format:                                        ;
                             ;                                                                       ;
                             ;       rel y, rel x, rel y, rel x, ...                                 ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       X-reg points to the vector list                                 ;
                             ;                                                                       ;
                             ; EXIT: X-reg points to next byte after list                            ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f3dd : ec84             [ 5] Draw_VL:        LDD     ,X
                             
                             ;-----------------------------------------------------------------------;
                             ;       F3DF    Draw_Line_d                                             ;
                             ;                                                                       ;
                             ; This routine will draw a line from the current pen position, to the   ;
                             ; point specified by the (y,x) pair specified in the D register.  The   ;
                             ; current scale factor is used.  Before calling this routine, $C823     ;
                             ; should be = 0, so that only the one vector will be drawn.             ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       A-reg = relative y position                                     ;
                             ;       B-reg = relative x position                                     ;
                             ;                                                                       ;
                             ; EXIT: X-reg is incremented by 2                                       ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f3df : 9701             [ 4] Draw_Line_d     STA     <VIA_port_a     ;Send Y to A/D
f3e1 : 0f00             [ 6]                 CLR     <VIA_port_b     ;Enable mux
f3e3 : 3002             [ 5]                 LEAX    2,X             ;Point to next coordinate pair
f3e5 : 12               [ 2]                 NOP                     ;Wait a moment
f3e6 : 0c00             [ 6]                 INC     <VIA_port_b     ;Disable mux
f3e8 : d701             [ 4]                 STB     <VIA_port_a     ;Send X to A/D
f3ea : ccff00           [ 3]                 LDD     #$FF00          ;Shift reg=$FF (solid line), T1H=0
f3ed : 970a             [ 4] LF3ED:          STA     <VIA_shift_reg  ;Put pattern in shift register
f3ef : d705             [ 4]                 STB     <VIA_t1_cnt_hi  ;Set T1H (scale factor?)
f3f1 : cc0040           [ 3]                 LDD     #$0040          ;B-reg = T1 interrupt bit
f3f4 : d50d             [ 4] LF3F4:          BITB    <VIA_int_flags  ;Wait for T1 to time out
f3f6 : 27fc             [ 3]                 BEQ     LF3F4
f3f8 : 12               [ 2]                 NOP                     ;Wait a moment more
f3f9 : 970a             [ 4]                 STA     <VIA_shift_reg  ;Clear shift register (blank output)
f3fb : b6c823           [ 5]                 LDA     $C823           ;Decrement line count
f3fe : 4a               [ 2]                 DECA
f3ff : 2ad9             [ 3]                 BPL     Draw_VL_a       ;Go back for more points
f401 : 7ef34f           [ 4]                 JMP     Check0Ref       ;Reset zero reference if necessary
                             
                             ;-----------------------------------------------------------------------;
                             ;       F404    Draw_VLp_FF                                             ;
                             ;       F408    Draw_VLp_7F                                             ;
                             ;                                                                       ;
                             ; These routines force the scale factor to 0xFF or 0x7F, and then       ;
                             ; process the vector list pointed to by the X register.  The vector     ;
                             ; list has the following format:                                        ;
                             ;                                                                       ;
                             ;       pattern, rel y, rel x                                           ;
                             ;       pattern, rel y, rel x                                           ;
                             ;          .      .      .                                              ;
                             ;          .      .      .                                              ;
                             ;       pattern, rel y, rel x                                           ;
                             ;       0x01                                                            ;
                             ;                                                                       ;
                             ; The list is terminated by a pattern byte with the high bit cleared.   ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       X-reg points to the vector list                                 ;
                             ;                                                                       ;
                             ; EXIT: X-reg points to the terminator byte                             ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f404 : c6ff             [ 2] Draw_VLp_FF:    LDB     #$FF
f406 : 2006             [ 3]                 BRA     Draw_VLp_b
                             
f408 : c67f             [ 2] Draw_VLp_7F:    LDB     #$7F
f40a : 2002             [ 3]                 BRA     Draw_VLp_b
                             
                             ;-----------------------------------------------------------------------;
                             ;       F40C    Draw_VLp_scale                                          ;
                             ;                                                                       ;
                             ; This routine processes the vector list pointed to by the X register.  ;
                             ; The first byte in the vector list is the scale factor.  The vector    ;
                             ; list has the following format:                                        ;
                             ;                                                                       ;
                             ;       scale                                                           ;
                             ;       pattern, rel y, rel x                                           ;
                             ;       pattern, rel y, rel x                                           ;
                             ;          .      .      .                                              ;
                             ;          .      .      .                                              ;
                             ;       pattern, rel y, rel x                                           ;
                             ;       0x01                                                            ;
                             ;                                                                       ;
                             ; The list is terminated by a pattern byte with the high bit cleared.   ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       X-reg points to the vector list                                 ;
                             ;                                                                       ;
                             ; EXIT: X-reg points to the terminator byte                             ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f40c : e680             [ 6] Draw_VLp_scale: LDB     ,X+
                             
                             ;-----------------------------------------------------------------------;
                             ;       F40E    Draw_VLp_b                                              ;
                             ;                                                                       ;
                             ; This routine draws patterned lines using the vector list pointed to   ;
                             ; by the X register.  The vector list has the following format:         ;
                             ;                                                                       ;
                             ;       pattern, rel y, rel x                                           ;
                             ;       pattern, rel y, rel x                                           ;
                             ;          .      .      .                                              ;
                             ;          .      .      .                                              ;
                             ;       pattern, rel y, rel x                                           ;
                             ;       0x01                                                            ;
                             ;                                                                       ;
                             ; The list is terminated by a pattern byte with the high bit cleared.   ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       B-reg = the scale factor                                        ;
                             ;       X-reg points to the vector list                                 ;
                             ;                                                                       ;
                             ; EXIT: X-reg points to the terminator byte                             ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f40e : d704             [ 4] Draw_VLp_b:     STB     <VIA_t1_cnt_lo  ;Set scale factor
                             
                             ;-----------------------------------------------------------------------;
                             ;       F410    Draw_VLp                                                ;
                             ;                                                                       ;
                             ; This routine draws patterned lines using the vector list pointed to   ;
                             ; by the X-register.  The current scale factor is used.  The vector     ;
                             ; list has the following format:                                        ;
                             ;                                                                       ;
                             ;       pattern, rel y, rel x                                           ;
                             ;       pattern, rel y, rel x                                           ;
                             ;          .      .      .                                              ;
                             ;          .      .      .                                              ;
                             ;       pattern, rel y, rel x                                           ;
                             ;       0x01                                                            ;
                             ;                                                                       ;
                             ; The list is terminated by a pattern byte with the high bit cleared.   ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       X-reg points to the vector list                                 ;
                             ;                                                                       ;
                             ; EXIT: X-reg points to the terminator byte                             ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f410 : ec01             [ 6] Draw_VLp:       LDD     1,X             ;Get next coordinate pair
f412 : 9701             [ 4]                 STA     <VIA_port_a     ;Send Y to A/D
f414 : 0f00             [ 6]                 CLR     <VIA_port_b     ;Enable mux
f416 : a684             [ 4]                 LDA     ,X              ;Get pattern byte?
f418 : 3003             [ 5]                 LEAX    3,X             ;Advance to next point in list
f41a : 0c00             [ 6]                 INC     <VIA_port_b     ;Disable mux
f41c : d701             [ 4]                 STB     <VIA_port_a     ;Send X to A/D
f41e : 970a             [ 4]                 STA     <VIA_shift_reg  ;Store pattern in shift register
f420 : 0f05             [ 6]                 CLR     <VIA_t1_cnt_hi  ;Clear T1H
f422 : cc0040           [ 3]                 LDD     #$0040          ;B-reg = T1 interrupt bit
f425 : d50d             [ 4] LF425:          BITB    <VIA_int_flags  ;Wait for T1 to time out
f427 : 27fc             [ 3]                 BEQ     LF425
f429 : 12               [ 2]                 NOP                     ;Wait a moment more
f42a : 970a             [ 4]                 STA     <VIA_shift_reg  ;Clear shift register (blank output)
f42c : a684             [ 4]                 LDA     ,X              ;Get next pattern byte
f42e : 2fe0             [ 3]                 BLE     Draw_VLp        ;Go back if high bit of pattern is set
f430 : 7ef34f           [ 4]                 JMP     Check0Ref
                             
                             ;-----------------------------------------------------------------------;
                             ;       F434    Draw_Pat_VL_a                                           ;
                             ;       F437    Draw_Pat_VL                                             ;
                             ;       F439    Draw_Pat_VL_d                                           ;
                             ;                                                                       ;
                             ; All of these routines draw a series of patterned vectors.  The        ;
                             ; pattern to use must already be specified in $C829.  When using        ;
                             ; Draw_Pat_VL or Draw_Pat_VL_d, the number of vectors to draw minus 1   ;
                             ; must be specified in $C823; when using Draw_Pat_VL_a, the number of   ;
                             ; vectors to draw minus 1 must be passed in in the A register.          ;
                             ; The vector list, pointed to by the X register, has the following      ;
                             ; format:                                                               ;
                             ;                                                                       ;
                             ;       rel y, rel x, rel y, rel x, ...                                 ;
                             ;                                                                       ;
                             ; Draw_Pat_VL_d starts at the (y,x) coordinates specified in the        ;
                             ; D register and ignores the first pair of coordinates in the vector    ;
                             ; list.                                                                 ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       X-reg points to the vector list                                 ;
                             ;       A-reg = the number of vectors to draw (Draw_Pat_VL_a only)      ;
                             ;       D-reg = start (Y,X) coordinate (Draw_Pat_VL_d only)             ;
                             ;       $C829 contains the line pattern.                                ;
                             ;                                                                       ;
                             ; EXIT: X-reg points to next byte after list                            ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f433 : 4a               [ 2] LF433:          DECA
f434 : b7c823           [ 5] Draw_Pat_VL_a:  STA     $C823
f437 : ec84             [ 5] Draw_Pat_VL:    LDD     ,X              ;Get next coordinate pair
f439 : 9701             [ 4] Draw_Pat_VL_d:  STA     <VIA_port_a     ;Send Y to A/D
f43b : 0f00             [ 6]                 CLR     <VIA_port_b     ;Enable mux
f43d : 3002             [ 5]                 LEAX    2,X             ;Point to next coordinate pair
f43f : 0c00             [ 6]                 INC     <VIA_port_b     ;Disable mux
f441 : d701             [ 4]                 STB     <VIA_port_a     ;Send X to A/D
f443 : b6c829           [ 5]                 LDA     Vec_Pattern     ;Get default pattern
f446 : c640             [ 2]                 LDB     #$40            ;B-reg = T1 interrupt bit
f448 : 970a             [ 4]                 STA     <VIA_shift_reg  ;Put pattern in shift register
f44a : 0f05             [ 6]                 CLR     <VIA_t1_cnt_hi  ;Clear T1H (scale factor?)
f44c : f5d00d           [ 5]                 BITB    VIA_int_flags   ;Check if T1 timed out (note wasted byte)
f44f : 270b             [ 3]                 BEQ     LF45C           ;Update pattern if not
                             
                             ;               Don't reset the zero reference if last line is really short?
                             
f451 : 0f0a             [ 6]                 CLR     <VIA_shift_reg  ;Clear shift register (blank output)
f453 : b6c823           [ 5]                 LDA     $C823           ;Get line counter
f456 : 26db             [ 3]                 BNE     LF433           ;Go back for more points
f458 : 39               [ 5]                 RTS
                             
                             ;               This code is for lines that are not really short lines
                             
f459 : b6c829           [ 5] LF459:          LDA     Vec_Pattern     ;Get default pattern
f45c : 970a             [ 4] LF45C:          STA     <VIA_shift_reg  ;Update pattern register
f45e : 12               [ 2]                 NOP                     ;Wait a moment
f45f : d50d             [ 4]                 BITB    <VIA_int_flags  ;Check if T1 timed out
f461 : 27f6             [ 3]                 BEQ     LF459           ;Update pattern again if not
f463 : b6c823           [ 5]                 LDA     $C823           ;Get line counter
f466 : 0f0a             [ 6]                 CLR     <VIA_shift_reg  ;Clear shift register (blank output)
f468 : 4d               [ 2]                 TSTA                    ;Go back if more lines to draw
f469 : 26c8             [ 3]                 BNE     LF433
f46b : 7ef34f           [ 4]                 JMP     Check0Ref       ;Reset zero reference if necessary
                             
                             ;-----------------------------------------------------------------------;
                             ;       F46E    Draw_VL_mode                                            ;
                             ;                                                                       ;
                             ; This routine processes the vector list pointed to by the X register.  ;
                             ; The current scale factor is used.  The vector list has the following  ;
                             ; format:                                                               ;
                             ;                                                                       ;
                             ;       mode, rel y, rel x,                                             ;
                             ;       mode, rel y, rel x,                                             ;
                             ;        .      .      .                                                ;
                             ;        .      .      .                                                ;
                             ;       mode, rel y, rel x,                                             ;
                             ;       0x01                                                            ;
                             ;                                                                       ;
                             ; where mode has the following meaning:                                 ;
                             ;                                                                       ;
                             ;       < 0  use the pattern in $C829                                   ;
                             ;       = 0  move to specified endpoint                                 ;
                             ;       = 1  end of list, so return                                     ;
                             ;       > 1  draw to specified endpoint                                 ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       X-reg points to the vector list                                 ;
                             ;       $C829 contains the line pattern.                                ;
                             ;                                                                       ;
                             ; EXIT: X-reg points to next byte after terminator                      ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f46e : b6c824           [ 5] Draw_VL_mode:   LDA     Vec_0Ref_Enable ;Save old Check0Ref flag
f471 : 3402             [ 6]                 PSHS    A
f473 : 7fc824           [ 7]                 CLR     Vec_0Ref_Enable ;Don't reset the zero reference yet
f476 : a680             [ 6] LF476:          LDA     ,X+             ;Get the next mode byte
f478 : 2a04             [ 3]                 BPL     LF47E
f47a : 8dbb             [ 7]                 BSR     Draw_Pat_VL     ;If <0, draw a patterned line
f47c : 20f8             [ 3]                 BRA     LF476
                             
f47e : 2605             [ 3] LF47E:          BNE     LF485
f480 : bdf3bc           [ 9]                 JSR     Mov_Draw_VL     ;If =0, move to the next point
f483 : 20f1             [ 3]                 BRA     LF476
                             
f485 : 4a               [ 2] LF485:          DECA
f486 : 2705             [ 3]                 BEQ     LF48D
f488 : bdf3dd           [ 9]                 JSR     Draw_VL         ;If <>1, draw a solid line
f48b : 20e9             [ 3]                 BRA     LF476
                             
f48d : 3502             [ 6] LF48D:          PULS    A               ;If =1, exit
f48f : b7c824           [ 5]                 STA     Vec_0Ref_Enable ;Restore old Check0Ref flag
f492 : 7ef34f           [ 4]                 JMP     Check0Ref       ;Reset zero reference if necessary
                             
                             ;-----------------------------------------------------------------------;
                             ;       F495    Print_Str                                               ;
                             ;                                                                       ;
                             ; This is the routine which does the actual printing of a string.  The  ;
                             ; U register points to the start of the string, while $C82A contains    ;
                             ; the height of the character, cell, and $C82B contains the width of    ;
                             ; the character cell.  The string is terminated with an 0x80.           ;
                             ;                                                                       ;
                             ; The string is displayed by drawing 7 horizontal rows of dots.  The    ;
                             ; first row is drawn for each character, then the second, etc.  The     ;
                             ; character generation table is located at ($F9D4 + $20).  Only         ;
                             ; characters 0x20-0x6F (upper case) are defined; the lower case         ;
                             ; characters a-o produce special icons.                                 ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       U-reg points to the start of the string                         ;
                             ;                                                                       ;
                             ; EXIT: U-reg points to next byte after terminator                      ;
                             ;                                                                       ;
                             ;       D-reg, X-reg trashed                                            ;
                             ;-----------------------------------------------------------------------;
                             
f495 : ffc82c           [ 6] Print_Str:      STU     Vec_Str_Ptr     ;Save string pointer
f498 : 8ef9d4           [ 3]                 LDX     #Char_Table-$20 ;Point to start of chargen bitmaps
f49b : cc1883           [ 3]                 LDD     #$1883          ;$8x = enable RAMP?
f49e : 0f01             [ 6]                 CLR     <VIA_port_a     ;Clear D/A output
f4a0 : 970b             [ 4]                 STA     <VIA_aux_cntl   ;Shift reg mode = 110, T1 PB7 enabled
f4a2 : 8ef9d4           [ 3]                 LDX     #Char_Table-$20 ;Point to start of chargen bitmaps
f4a5 : d700             [ 4] LF4A5:          STB     <VIA_port_b     ;Update RAMP, set mux to channel 1
f4a7 : 0a00             [ 6]                 DEC     <VIA_port_b     ;Enable mux
f4a9 : cc8081           [ 3]                 LDD     #$8081
f4ac : 12               [ 2]                 NOP                     ;Wait a moment
f4ad : 0c00             [ 6]                 INC     <VIA_port_b     ;Disable mux
f4af : d700             [ 4]                 STB     <VIA_port_b     ;Enable RAMP, set mux to channel 0
f4b1 : 9700             [ 4]                 STA     <VIA_port_b     ;Enable mux
f4b3 : 7dc800           [ 7]                 TST     $C800           ;I think this is a delay only
f4b6 : 0c00             [ 6]                 INC     <VIA_port_b     ;Enable RAMP, disable mux
f4b8 : b6c82b           [ 5]                 LDA     Vec_Text_Width  ;Get text width
f4bb : 9701             [ 4]                 STA     <VIA_port_a     ;Send it to the D/A
f4bd : cc0100           [ 3]                 LDD     #$0100
f4c0 : fec82c           [ 6]                 LDU     Vec_Str_Ptr     ;Point to start of text string
f4c3 : 9700             [ 4]                 STA     <VIA_port_b     ;Disable RAMP, disable mux
f4c5 : 2004             [ 3]                 BRA     LF4CB
                             
f4c7 : a686             [ 5] LF4C7:          LDA     A,X             ;Get bitmap from chargen table
f4c9 : 970a             [ 4]                 STA     <VIA_shift_reg  ;Save in shift register
f4cb : a6c0             [ 6] LF4CB:          LDA     ,U+             ;Get next character
f4cd : 2af8             [ 3]                 BPL     LF4C7           ;Go back if not terminator
f4cf : 8681             [ 2]                 LDA     #$81
f4d1 : 9700             [ 4]                 STA     <VIA_port_b     ;Enable RAMP, disable mux
f4d3 : 0001             [ 6]                 NEG     <VIA_port_a     ;Negate text width to D/A
f4d5 : 8601             [ 2]                 LDA     #$01
f4d7 : 9700             [ 4]                 STA     <VIA_port_b     ;Disable RAMP, disable mux
f4d9 : 8cfbb4           [ 4]                 CMPX    #Char_Table_End-$20;     Check for last row
f4dc : 272c             [ 3]                 BEQ     LF50A           ;Branch if last row
f4de : 308850           [ 5]                 LEAX    $50,X           ;Point to next chargen row
f4e1 : 1f30             [ 6]                 TFR     U,D             ;Get string length
f4e3 : b3c82c           [ 7]                 SUBD    Vec_Str_Ptr
f4e6 : c002             [ 2]                 SUBB    #$02            ; -  2
f4e8 : 58               [ 2]                 ASLB                    ; *  2
f4e9 : 2100             [ 3]                 BRN     LF4EB           ;Delay a moment
f4eb : 8681             [ 2] LF4EB:          LDA     #$81
f4ed : 12               [ 2]                 NOP
f4ee : 5a               [ 2]                 DECB
f4ef : 26fa             [ 3]                 BNE     LF4EB           ;Delay some more in a loop
f4f1 : 9700             [ 4]                 STA     <VIA_port_b     ;Enable RAMP, disable mux
f4f3 : f6c82a           [ 5]                 LDB     Vec_Text_Height ;Get text height
f4f6 : d701             [ 4]                 STB     <VIA_port_a     ;Store text height in D/A
f4f8 : 0a00             [ 6]                 DEC     <VIA_port_b     ;Enable mux
f4fa : cc8101           [ 3]                 LDD     #$8101
f4fd : 12               [ 2]                 NOP                     ;Wait a moment
f4fe : 9700             [ 4]                 STA     <VIA_port_b     ;Enable RAMP, disable mux
f500 : 0f01             [ 6]                 CLR     <VIA_port_a     ;Clear D/A
f502 : d700             [ 4]                 STB     <VIA_port_b     ;Disable RAMP, disable mux
f504 : 9700             [ 4]                 STA     <VIA_port_b     ;Enable RAMP, disable mux
f506 : c603             [ 2]                 LDB     #$03            ;$0x = disable RAMP?
f508 : 209b             [ 3]                 BRA     LF4A5           ;Go back for next scan line
                             
f50a : 8698             [ 2] LF50A:          LDA     #$98
f50c : 970b             [ 4]                 STA     <VIA_aux_cntl   ;T1->PB7 enabled
f50e : 7ef354           [ 4]                 JMP     Reset0Ref       ;Reset the zero reference
                             
                             ;-----------------------------------------------------------------------;
                             ;       F511    Random_3                                                ;
                             ;       F517    Random                                                  ;
                             ;                                                                       ;
                             ; This routine generates a random 1-byte number, and places it in the   ;
                             ; A register.  Random_3 runs through the random number generator        ;
                             ; algorithm three times.  The random number seed is stored in the       ;
                             ; three bytes pointed to by $C87B.                                      ;
                             ;                                                                       ;
                             ; EXIT: A-reg contains the generated random number                      ;
                             ;                                                                       ;
                             ;       All other registers are preserved.                              ;
                             ;-----------------------------------------------------------------------;
                             
f511 : 3414             [ 8] Random_3:       PSHS    B,X
f513 : c602             [ 2]                 LDB     #$02
f515 : 2003             [ 3]                 BRA     LF51A
                             
f517 : 3414             [ 8] Random:         PSHS    B,X
f519 : 5f               [ 2]                 CLRB
f51a : bec87b           [ 6] LF51A:          LDX     Vec_Seed_Ptr
f51d : a601             [ 5] LF51D:          LDA     1,X
f51f : 49               [ 2]                 ROLA
f520 : 49               [ 2]                 ROLA
f521 : 49               [ 2]                 ROLA
f522 : 49               [ 2]                 ROLA
f523 : a802             [ 5]                 EORA    2,X
f525 : 46               [ 2]                 RORA
f526 : 6984             [ 6]                 ROL     ,X
f528 : 6901             [ 7]                 ROL     1,X
f52a : 6902             [ 7]                 ROL     2,X
f52c : 5a               [ 2]                 DECB
f52d : 2aee             [ 3]                 BPL     LF51D
f52f : a684             [ 4]                 LDA     ,X
f531 : 3594             [10]                 PULS    B,X,PC
                             
                             ;-----------------------------------------------------------------------;
                             ;       F533    Init_Music_Buf                                          ;
                             ;                                                                       ;
                             ; This routine clears out the music work buffer, located at             ;
                             ; $C83F-$C84C.                                                          ;
                             ;                                                                       ;
                             ;       X-reg, D-reg trashed                                            ;
                             ;-----------------------------------------------------------------------;
                             
f533 : c60d             [ 2] Init_Music_Buf: LDB     #$0D
f535 : 8ec83f           [ 3]                 LDX     #Vec_Music_Work
f538 : 8d05             [ 7]                 BSR     Clear_x_b
f53a : 863f             [ 2]                 LDA     #$3F
f53c : a706             [ 5]                 STA     6,X
f53e : 39               [ 5]                 RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F53F    Clear_x_b                                               ;
                             ;                                                                       ;
                             ; This routine clears to 0 the block of memory starting at the          ;
                             ; address contained in the X register, and continuing for the number    ;
                             ; of bytes specified by B+1.                                            ;
                             ;                                                                       ;
                             ; ENTRY X-reg points to the start of the RAM to be cleared.             ;
                             ;       B-reg = number of bytes minus 1 to clear.                       ;
                             ;                                                                       ;
                             ; EXIT: D-reg = $FFFF                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f53f : 4f               [ 2] Clear_x_b:      CLRA
f540 : 2006             [ 3]                 BRA     Clear_x_d
                             
                             ;-----------------------------------------------------------------------;
                             ;       F542    Clear_C8_RAM    (never used by GCE carts?)              ;
                             ;                                                                       ;
                             ; This routine clears to 0 the block of memory in the range             ;
                             ; $C800-$C8FF.                                                          ;
                             ;                                                                       ;
                             ; EXIT: X-reg = $C800                                                   ;
                             ;       D-reg = $FFFF                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f542 : 8ec800           [ 3] Clear_C8_RAM:   LDX     #$C800
                             
                             ;-----------------------------------------------------------------------;
                             ;       F545    Clear_x_256                                             ;
                             ;       F548    Clear_x_d                                               ;
                             ;                                                                       ;
                             ; This routine clears the block of memory starting at the contained     ;
                             ; in the X register to zero.                                            ;
                             ;                                                                       ;
                             ; ENTRY X-reg points to the start of RAM to be cleared                  ;
                             ;       D-reg = number of bytes to clear minus 1 (Clear_x_d only)       ;
                             ;                                                                       ;
                             ; EXIT: D-reg = $FFFF                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f545 : cc00ff           [ 3] Clear_x_256:    LDD     #$00FF
f548 : 6f8b             [10] Clear_x_d:      CLR     D,X
f54a : 830001           [ 4]                 SUBD    #$0001
f54d : 2af9             [ 3]                 BPL     Clear_x_d
f54f : 39               [ 5]                 RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F550    Clear_x_b_80                                            ;
                             ;       F552    Clear_x_b_a                                             ;
                             ;                                                                       ;
                             ; This routine sets the block of memory pointed to by the X register    ;
                             ; to $80 or the A register.  The B register specifies the number of     ;
                             ; bytes to be cleared.                                                  ;
                             ;                                                                       ;
                             ; ENTRY A-reg = byte to be stored (Clear_x_b_a only)                    ;
                             ;       B-reg = number of bytes to clear ($00 = 256)                    ;
                             ;       X-reg points to start of memory block to clear                  ;
                             ;                                                                       ;
                             ; EXIT: A-reg = $80 (Clear_x_b_80 only)                                 ;
                             ;       B-reg = $00                                                     ;
                             ;                                                                       ;
                             ;       All other registers preserved.                                  ;
                             ;-----------------------------------------------------------------------;
                             
f550 : 8680             [ 2] Clear_x_b_80:   LDA     #$80
f552 : a785             [ 5] Clear_x_b_a:    STA     B,X
f554 : 5a               [ 2]                 DECB
f555 : 26fb             [ 3]                 BNE     Clear_x_b_a
f557 : a784             [ 4]                 STA     ,X
f559 : 39               [ 5]                 RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F55A    Dec_3_Counters                                          ;
                             ;       F55E    Dec_6_Counters                                          ;
                             ;                                                                       ;
                             ; These routines check either the first three or all six of the         ;
                             ; default counters at $C82E-$C833 and decrements those which are not    ;
                             ; already zero.                                                         ;
                             ;                                                                       ;
                             ; EXIT: X-reg points to the default counters at $C82E                   ;
                             ;       B-reg = $FF                                                     ;
                             ;                                                                       ;
                             ;       All other registers preserved.                                  ;
                             ;-----------------------------------------------------------------------;
                             
f55a : c602             [ 2] Dec_3_Counters: LDB     #$02
f55c : 2002             [ 3]                 BRA     LF560
                             
f55e : c605             [ 2] Dec_6_Counters: LDB     #$05
f560 : 8ec82e           [ 3] LF560:          LDX     #Vec_Counters
                             
                             ;-----------------------------------------------------------------------;
                             ;       F563    Dec_Counters                                            ;
                             ;                                                                       ;
                             ; This routine checks the counters pointed to by the X register and     ;
                             ; decrements those which are not already zero.                          ;
                             ;                                                                       ;
                             ; ENTRY B-reg = number of counters minus 1                              ;
                             ;       X-reg points to counter bytes                                   ;
                             ;                                                                       ;
                             ; EXIT: B-reg = $FF                                                     ;
                             ;                                                                       ;
                             ;       All other registers preserved.                                  ;
                             ;-----------------------------------------------------------------------;
                             
f563 : 6d85             [ 7] Dec_Counters:   TST     B,X
f565 : 2702             [ 3]                 BEQ     LF569
f567 : 6a85             [ 7]                 DEC     B,X
f569 : 5a               [ 2] LF569:          DECB
f56a : 2af7             [ 3]                 BPL     Dec_Counters
f56c : 39               [ 5]                 RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F56D    Delay_3         30 cycles                               ;
                             ;       F571    Delay_2         25 cycles                               ;
                             ;       F575    Delay_1         20 cycles                               ;
                             ;       F579    Delay_0         12 cycles                               ;
                             ;       F57A    Delay_b         5;B + 10 cycles                         ;
                             ;       F57D    Delay_RTS       5 cycles                                ;
                             ;                                                                       ;
                             ; Each of these routines loads the B-register with the indicated        ;
                             ; value, and then loops until the B register value has decremented      ;
                             ; below zero.  Delay_RTS is just an RTS instruction, but at least       ;
                             ; one GCE cartridge calls it.                                           ;
                             ;                                                                       ;
                             ; Cycle counts do not include timing of the instructions used to        ;
                             ; call the delay routines.                                              ;
                             ;                                                                       ;
                             ; ENTRY B-reg = delay count (Delay_b only)                              ;
                             ;                                                                       ;
                             ; EXIT: B-reg = $FF (except Delay_RTS)                                  ;
                             ;-----------------------------------------------------------------------;
                             
f56d : c603             [ 2] Delay_3:        LDB     #$03            ;2 cycles
f56f : 2009             [ 3]                 BRA     Delay_b         ;3 cycles
                             
f571 : c602             [ 2] Delay_2:        LDB     #$02            ;2 cycles
f573 : 2005             [ 3]                 BRA     Delay_b         ;3 cycles
                             
f575 : c601             [ 2] Delay_1:        LDB     #$01            ;2 cycles
f577 : 2001             [ 3]                 BRA     Delay_b         ;3 cycles
                             
f579 : 5f               [ 2] Delay_0:        CLRB                    ;2 cycles
f57a : 5a               [ 2] Delay_b:        DECB                    ;2 cycles
f57b : 2afd             [ 3]                 BPL     Delay_b         ;3 cycles
f57d : 39               [ 5] Delay_RTS:      RTS                     ;5 cycles
                             
                             ;-----------------------------------------------------------------------;
                             ;       F57E    Bitmask_a                                               ;
                             ;                                                                       ;
                             ; This routine takes a bit number, specified in the A register, and     ;
                             ; returns a bit mask with only the specified bit set.                   ;
                             ;                                                                       ;
                             ; ENTRY A-reg contains the bit number                                   ;
                             ;                                                                       ;
                             ; EXIT: A-reg contains the bit mask                                     ;
                             ;                                                                       ;
                             ;       X-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f57e : 8ef9dc           [ 3] Bitmask_a:      LDX     #Bit_Masks
f581 : a686             [ 5]                 LDA     A,X
f583 : 39               [ 5]                 RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F584    Abs_a_b                                                 ;
                             ;       F58B    Abs_b                                                   ;
                             ;                                                                       ;
                             ; This routine returns the absolute value of the two single byte        ;
                             ; numbers passed in in the A and B registers.  Abs_b only uses the B    ;
                             ; register.  There is a special case: 0x80 is returned as 0x7F.         ;
                             ;                                                                       ;
                             ; ENTRY A-reg contains first value                                      ;
                             ;       B-reg contains second value (Abs_a_b only)                      ;
                             ;                                                                       ;
                             ; EXIT: A-reg contains absolute value of first value                    ;
                             ;       B-reg contains absolute value of second value (Abs_a_b only)    ;
                             ;                                                                       ;
                             ;       All other registers preserved.                                  ;
                             ;-----------------------------------------------------------------------;
                             
f584 : 4d               [ 2] Abs_a_b:        TSTA
f585 : 2a04             [ 3]                 BPL     Abs_b
f587 : 40               [ 2]                 NEGA
f588 : 2801             [ 3]                 BVC     Abs_b
f58a : 4a               [ 2]                 DECA
f58b : 5d               [ 2] Abs_b:          TSTB
f58c : 2a04             [ 3]                 BPL     LF592
f58e : 50               [ 2]                 NEGB
f58f : 2801             [ 3]                 BVC     LF592
f591 : 5a               [ 2]                 DECB
f592 : 39               [ 5] LF592:          RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F593    Rise_Run_Angle                                          ;
                             ;                                                                       ;
                             ; Given a (rise,run) pair, this routine calculates the angle which      ;
                             ; corresponds to that (rise,run) pair.  The returned angle is relative  ;
                             ; to the x-axis (+ is CCW), so to convert it to a Vectrex angle         ;
                             ; (relative to the y-axis, + is CCW), you must subtract the number 0x10 ;
                             ; (90 degrees) from the returned value.                                 ;
                             ;                                                                       ;
                             ; ENTRY DP = $C8                                                        ;
                             ;       A-reg = rise value                                              ;
                             ;       B-reg = run value                                               ;
                             ;                                                                       ;
                             ; EXIT: A-reg = the angle from the x-axis                               ;
                             ;       B-reg = the angle from the x-axis                               ;
                             ;                                                                       ;
                             ;       All other registers preserved.                                  ;
                             ;-----------------------------------------------------------------------;
                             
f593 : 3410             [ 7] Rise_Run_Angle: PSHS    X
f595 : dd34             [ 5]                 STD     <Vec_RiseRun_Tmp
f597 : 59               [ 2]                 ROLB
f598 : c600             [ 2]                 LDB     #$00
f59a : 59               [ 2]                 ROLB
f59b : 49               [ 2]                 ROLA
f59c : 59               [ 2]                 ROLB
f59d : 58               [ 2]                 ASLB
f59e : d736             [ 4]                 STB     <Vec_Angle
f5a0 : dc34             [ 5]                 LDD     <Vec_RiseRun_Tmp
f5a2 : 8de0             [ 7]                 BSR     Abs_a_b
f5a4 : 9734             [ 4]                 STA     <Vec_RiseRun_Tmp
f5a6 : d134             [ 4]                 CMPB    <Vec_RiseRun_Tmp
f5a8 : 2308             [ 3]                 BLS     LF5B2
f5aa : 0c36             [ 6]                 INC     <Vec_Angle
f5ac : 1e89             [ 8]                 EXG     A,B
f5ae : 2002             [ 3]                 BRA     LF5B2
                             
f5b0 : 44               [ 2] LF5B0:          LSRA
f5b1 : 54               [ 2]                 LSRB
f5b2 : 8109             [ 2] LF5B2:          CMPA    #$09
f5b4 : 22fa             [ 3]                 BHI     LF5B0
f5b6 : dd34             [ 5]                 STD     <Vec_RiseRun_Tmp
f5b8 : d636             [ 4]                 LDB     <Vec_Angle
f5ba : 8efc24           [ 3]                 LDX     #DFC24
f5bd : e685             [ 5]                 LDB     B,X
f5bf : 8efc2c           [ 3]                 LDX     #DFC2C
f5c2 : a686             [ 5]                 LDA     A,X
f5c4 : 9b35             [ 4]                 ADDA    <$C835
f5c6 : 8b0a             [ 2]                 ADDA    #$0A
f5c8 : c501             [ 2]                 BITB    #$01
f5ca : 2604             [ 3]                 BNE     LF5D0
f5cc : eb86             [ 5]                 ADDB    A,X
f5ce : 2003             [ 3]                 BRA     LF5D3
                             
f5d0 : 5a               [ 2] LF5D0:          DECB
f5d1 : e086             [ 5]                 SUBB    A,X
f5d3 : d736             [ 4] LF5D3:          STB     <Vec_Angle
f5d5 : 9636             [ 4]                 LDA     <Vec_Angle
f5d7 : 3590             [ 9]                 PULS    X,PC
                             
                             ;-----------------------------------------------------------------------;
                             ;       F5D9    Get_Rise_Idx                                            ;
                             ;       F5DB    Get_Run_Idx                                             ;
                             ;                                                                       ;
                             ; These routines are responsible for generating the two index pairs     ;
                             ; which are required by the rest of the rotation routines.  Each index  ;
                             ; pair is two bytes long, and has the following format:                 ;
                             ;                                                                       ;
                             ;       The high byte is obtained by masking the anglewith 0x1F (this   ;
                             ;       forces the angle to be between 0 and 180 degrees), and then     ;
                             ;       using this value to index into the multiplier table.            ;
                             ;                                                                       ;
                             ;       The lower byte contains information about whether the angle     ;
                             ;       lies along either the x or y axis, and whether the rise/run     ;
                             ;       will be positive or negative.                                   ;
                             ;                                                                       ;
                             ;               0 => positive rise, not on an axis, or                  ;
                             ;                    negative run, not on an axis.                      ;
                             ;            0x80 => negative rise, not on an axis, or                  ;
                             ;                    positive run, not on an axis.                      ;
                             ;               1 => positive rise, on an axis, or                      ;
                             ;                    negative run, on an axis.                          ;
                             ;            0x81 => negative rise, on an axis, or                      ;
                             ;                    positive run, on an axis.                          ;
                             ;                                                                       ;
                             ; ENTRY A-reg = the angle value                                         ;
                             ;                                                                       ;
                             ; EXIT: A-reg = slope?                                                  ;
                             ;       B-reg = slope direction?                                        ;
                             ;                                                                       ;
                             ;       X-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f5d9 : 8b10             [ 2] Get_Rise_Idx:   ADDA    #$10            ;Offset angle by 90 degrees
f5db : 8efc6d           [ 3] Get_Run_Idx:    LDX     #DFC6D          ;Get address of slope table
f5de : 5f               [ 2]                 CLRB
f5df : 8520             [ 2]                 BITA    #$20            ;If angle in 180-360,
f5e1 : 2702             [ 3]                 BEQ     LF5E5
f5e3 : c680             [ 2]                 LDB     #$80            ;flag negative rise or positive run
f5e5 : 841f             [ 2] LF5E5:          ANDA    #$1F            ;Mask to multiple of 180 degrees
f5e7 : 8110             [ 2]                 CMPA    #$10            ;If 90 degrees
f5e9 : 2601             [ 3]                 BNE     LF5EC
f5eb : 5c               [ 2]                 INCB                    ;then rise or run is on an axis
f5ec : a686             [ 5] LF5EC:          LDA     A,X             ;Get slope from slope table
f5ee : 39               [ 5]                 RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F5EF    Rise_Run_Idx                                            ;
                             ;                                                                       ;
                             ; This routine gets the index pair for both the rise and run, using     ;
                             ; the passed-in angle value.                                            ;
                             ;                                                                       ;
                             ; ENTRY DP = $C8                                                        ;
                             ;       $C836 contains the angle value                                  ;
                             ;                                                                       ;
                             ; EXIT: $C837-$C838 contains the index pair for the run                 ;
                             ;       $C839-$C83A contains the index pair for the rise                ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f5ef : 3410             [ 7] Rise_Run_Idx:   PSHS    X               ;Save X-reg
f5f1 : 9636             [ 4]                 LDA     <Vec_Angle      ;Get angle
f5f3 : 8de6             [ 7]                 BSR     Get_Run_Idx     ;Get run index pair for angle
f5f5 : dd37             [ 5]                 STD     <Vec_Run_Index
f5f7 : 9636             [ 4]                 LDA     <Vec_Angle      ;Get angle
f5f9 : 8dde             [ 7]                 BSR     Get_Rise_Idx    ;Get rise index pair for angle
f5fb : dd39             [ 5]                 STD     <Vec_Rise_Index
f5fd : 3590             [ 9]                 PULS    X,PC            ;Restore X-reg and return
                             
                             ;-----------------------------------------------------------------------;
                             ;       F5FF    Rise_Run_X                                              ;
                             ;       F601    Rise_Run_Y                                              ;
                             ;       F603    Rise_Run_Len                                            ;
                             ;                                                                       ;
                             ; This routine takes an angle value which is relative to the x- or      ;
                             ; y-axis, and calculates the rise and run for that angle, relative to a ;
                             ; passed-in scalar velocity value.  A large scalar value will cause an  ;
                             ; object to move quickly, while a small scalar value will cause an      ;
                             ; object to move more slowly.                                           ;
                             ;                                                                       ;
                             ; Keep in mind that most games store x & y coordinates as 2 bytes each, ;
                             ; with the upper byte being the actual coordinate, and the lower byte   ;
                             ; being that which is usually added to the rise/run value; when the     ;
                             ; lower byte overflows into the hi byte, then the object will 'move'.   ;
                             ; The rise/run values returned here are meant to be added to the low    ;
                             ; byte -- NOT the hi byte!!                                             ;
                             ;                                                                       ;
                             ; ENTRY DP = $C8                                                        ;
                             ;       A-reg = the scalar velocity value (except Rise_Run_Len)         ;
                             ;       B-reg = the Vectrex angle value                                 ;
                             ;                                                                       ;
                             ; EXIT: A-reg = the rise value                                          ;
                             ;       B-reg = the run value                                           ;
                             ;                                                                       ;
                             ;       All other registers are saved.                                  ;
                             ;-----------------------------------------------------------------------;
                             
f5ff : c010             [ 2] Rise_Run_X:     SUBB    #$10
f601 : d736             [ 4] Rise_Run_Y:     STB     <Vec_Angle
f603 : 973b             [ 4] Rise_Run_Len:   STA     <Vec_RiseRun_Len
f605 : 8de8             [ 7]                 BSR     Rise_Run_Idx    ;Get index pair of angle
f607 : 8d54             [ 7]                 BSR     Xform_Run       ;Get run value
f609 : 40               [ 2]                 NEGA
f60a : 3402             [ 6]                 PSHS    A               ;Save run value
f60c : 8d55             [ 7]                 BSR     Xform_Rise      ;Get rise value
f60e : 3584             [ 8]                 PULS    B,PC            ;Restore run value and return
                             
                             ;-----------------------------------------------------------------------;
                             ;       F610    Rot_VL_ab                                               ;
                             ;       F616    Rot_VL                                                  ;
                             ;                                                                       ;
                             ; This routine rotates a vector list of length 'n+1', where 'n' is      ;
                             ; specified by the value in the B register.  The A register contains    ;
                             ; the rotation value, and the X contains a pointer to the vector list.  ;
                             ; The U register contains a pointer to a buffer into which the          ;
                             ; transformed points are to be saved.  The vector list has the          ;
                             ; following format:                                                     ;
                             ;                                                                       ;
                             ;       rel y, rel x, rel y, rel x, ...                                 ;
                             ;                                                                       ;
                             ; ENTRY A-reg = rotation angle value (Rot_VL_ab only)                   ;
                             ;       $C836 = rotation angle value (Rot_VL only)                      ;
                             ;       B-reg = number of points - 1 (Rot_VL_ab only)                   ;
                             ;       $C823 = number of points - 1 (Rot_VL only)                      ;
                             ;       X-reg points to original vector list                            ;
                             ;       U-reg points to rotated vector list                             ;
                             ;                                                                       ;
                             ; EXIT: DP = $C8                                                        ;
                             ;       X-reg points to next byte after list                            ;
                             ;       U-reg points to next byte after rotated list                    ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f610 : b7c836           [ 5] Rot_VL_ab:      STA     Vec_Angle
f613 : f7c823           [ 5]                 STB     $C823
f616 : 3408             [ 6] Rot_VL:         PSHS    DP
f618 : bdf1af           [ 9]                 JSR     DP_to_C8
f61b : 8dd2             [ 7]                 BSR     Rise_Run_Idx
f61d : 2018             [ 3]                 BRA     LF637
                             
                             ;-----------------------------------------------------------------------;
                             ;       F61F    Rot_VL_Mode                                             ;
                             ;       F62B    Rot_VL_M_dft                                            ;
                             ;                                                                       ;
                             ; This routine rotates a vector list having the following format:       ;
                             ;                                                                       ;
                             ;       mode, rel y, rel x,                                             ;
                             ;       mode, rel y, rel x,                                             ;
                             ;         .     .      .                                                ;
                             ;         .     .      .                                                ;
                             ;       mode, rel y, rel x,                                             ;
                             ;       0x01                                                            ;
                             ;                                                                       ;
                             ; The A register contains the rotation value, and the X contains a      ;
                             ; pointer to the vector list.  The U register contains a pointer to a   ;
                             ; buffer into which the transformed points are to be saved.             ;
                             ;                                                                       ;
                             ; ENTRY DP = $C8                                                        ;
                             ;       A-reg = rotation angle value (Rot_VL_Mode only)                 ;
                             ;       X-reg points to original vector list                            ;
                             ;       U-reg points to rotated vector list                             ;
                             ;                                                                       ;
                             ; EXIT: X-reg points to next byte after list                            ;
                             ;       U-reg points to next byte after rotated list                    ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f61f : b7c836           [ 5] Rot_VL_Mode:    STA     Vec_Angle       ;Save angle
f622 : 3408             [ 6]                 PSHS    DP              ;Save DP register
f624 : bdf1af           [ 9]                 JSR     DP_to_C8        ;DP to RAM
f627 : 9723             [ 4]                 STA     <$C823          ;Store $C8 (negative value) into $C823
f629 : 8dc4             [ 7]                 BSR     Rise_Run_Idx    ;Get index pair of angle
f62b : a680             [ 6] Rot_VL_M_dft:   LDA     ,X+             ;Get mode byte
f62d : a7c0             [ 6]                 STA     ,U+             ;Copy to destination
f62f : 2f06             [ 3]                 BLE     LF637           ;Rotate if not end of list
f631 : 0f23             [ 6]                 CLR     <$C823          ;Exit with $C823 cleared
f633 : 3588             [ 8]                 PULS    DP,PC           ;Restore DP register and return
                             
f635 : 0a23             [ 6] LF635:          DEC     <$C823          ;Decrement count for (y,x) list
f637 : a680             [ 6] LF637:          LDA     ,X+             ;Get y coordinate
f639 : 8d26             [ 7]                 BSR     Xform_Rise_a
f63b : a7c4             [ 4]                 STA     ,U              ;Store partial y coordinate
f63d : a684             [ 4]                 LDA     ,X              ;Get x coordinate
f63f : 8d1a             [ 7]                 BSR     Xform_Run_a
f641 : abc4             [ 4]                 ADDA    ,U              ;Add to partial y coordinate
f643 : a7c0             [ 6]                 STA     ,U+             ;Store rotated y coordinate
f645 : a61f             [ 5]                 LDA     -1,X            ;Get y coordinate
f647 : 8d12             [ 7]                 BSR     Xform_Run_a
f649 : a7c4             [ 4]                 STA     ,U              ;Store partial x coordinate
f64b : a680             [ 6]                 LDA     ,X+             ;Get x coordinate
f64d : 8d12             [ 7]                 BSR     Xform_Rise_a
f64f : a0c4             [ 4]                 SUBA    ,U              ;Add to partial x coordinate
f651 : a7c0             [ 6]                 STA     ,U+             ;Store rotated x coordinate
f653 : 9623             [ 4]                 LDA     <$C823          ;Get counter
f655 : 2bd4             [ 3]                 BMI     Rot_VL_M_dft    ;If negative, go back to mode list loop
f657 : 26dc             [ 3]                 BNE     LF635           ;If non-zero, go back to (y,x) list loop
f659 : 3588             [ 8]                 PULS    DP,PC
                             
                             ;-----------------------------------------------------------------------;
                             ;       F65B    Xform_Run_a                                             ;
                             ;       F65D    Xform_Run                                               ;
                             ;                                                                       ;
                             ; These two routines generate a run value, using the run index pair in  ;
                             ; $C837-$C838.  For Xform_Run_a the scalar value is passed in the       ;
                             ; A register, while for Xform_Run, the scalar value must already be in  ;
                             ; $C83B.  The transformed value is return in the A register.            ;
                             ;                                                                       ;
                             ; ENTRY DP = $C8                                                        ;
                             ;       A-reg = length for rise/run (Xform_Rise_a only)                 ;
                             ;                                                                       ;
                             ; EXIT: A-reg = run value                                               ;
                             ;                                                                       ;
                             ;       B-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f65b : 973b             [ 4] Xform_Run_a:    STA     <Vec_RiseRun_Len
f65d : dc37             [ 5] Xform_Run:      LDD     <Vec_Run_Index
f65f : 2004             [ 3]                 BRA     LF665
                             
                             ;-----------------------------------------------------------------------;
                             ;       F661    Xform_Rise_a                                            ;
                             ;       F663    Xform_Rise                                              ;
                             ;                                                                       ;
                             ; These two routines generate a rise value, using the rise index pair   ;
                             ; in $C839-$C83A.  For Xform_Rise_a the scalar value is passed in the   ;
                             ; A register, while for Xform_Rise, the scalar value must already be    ;
                             ; in $C83B.  The transformed value is return in the A register.         ;
                             ;                                                                       ;
                             ; ENTRY DP = $C8                                                        ;
                             ;       A-reg = length for rise/run (Xform_Run_a only)                  ;
                             ;                                                                       ;
                             ; EXIT: A-reg = rise value                                              ;
                             ;                                                                       ;
                             ;       B-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f661 : 973b             [ 4] Xform_Rise_a:   STA     <Vec_RiseRun_Len
f663 : dc39             [ 5] Xform_Rise:     LDD     <Vec_Rise_Index
f665 : d73c             [ 4] LF665:          STB     <$C83C
f667 : c501             [ 2]                 BITB    #$01
f669 : 2704             [ 3]                 BEQ     LF66F
f66b : 963b             [ 4]                 LDA     <Vec_RiseRun_Len
f66d : 200a             [ 3]                 BRA     LF679
                             
f66f : d63b             [ 4] LF66F:          LDB     <Vec_RiseRun_Len
f671 : 2a03             [ 3]                 BPL     LF676
f673 : 033c             [ 6]                 COM     <$C83C
f675 : 50               [ 2]                 NEGB
f676 : 3d               [11] LF676:          MUL
f677 : 8900             [ 2]                 ADCA    #$00
f679 : d63c             [ 4] LF679:          LDB     <$C83C
f67b : 2a01             [ 3]                 BPL     LF67E
f67d : 40               [ 2]                 NEGA
f67e : 39               [ 5] LF67E:          RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F67F    Move_Mem_a_1                                            ;
                             ;       F683    Move_Mem_a                                              ;
                             ;                                                                       ;
                             ; This routine copies a block of memory, starting at the hi address,    ;
                             ; and working down to the low address.  The base of the source address  ;
                             ; is specified in the U register, and the base of the destination       ;
                             ; address is  specified in the X register.  The A register contains     ;
                             ; the number of bytes to copy; 0x80 is the maximum value which can      ;
                             ; be specified.                                                         ;
                             ;                                                                       ;
                             ; ENTRY A-reg = byte count (Move_Mem_a only)                            ;
                             ;       A-reg = byte count minus 1 (Move_Mem_a_1 only)                  ;
                             ;       X-reg points to the destination                                 ;
                             ;       U-reg points to the source                                      ;
                             ;                                                                       ;
                             ; EXIT  A-reg = $FF                                                     ;
                             ;       B-reg = first byte of source                                    ;
                             ;-----------------------------------------------------------------------;
                             
f67f : e6c6             [ 5] Move_Mem_a_1:   LDB     A,U             ;Copy the byte
f681 : e786             [ 5]                 STB     A,X
f683 : 4a               [ 2] Move_Mem_a:     DECA                    ;Decrement the count
f684 : 2af9             [ 3]                 BPL     Move_Mem_a_1    ;Go back until finished
f686 : 39               [ 5] LF686:          RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F687    Init_Music_chk                                          ;
                             ;       F68D    Init_Music                                              ;
                             ;       F692    Init_Music_dft                                          ;
                             ;                                                                       ;
                             ; These routines are responsible for filling the music work buffer      ;
                             ; while a sound is being made.  It should be called once during each    ;
                             ; refresh cycle.  If you want to start a new sound, then you must set   ;
                             ; $C856 to 0x01, and point the U-register to the sound block.  If no    ;
                             ; sound is in progress ($C856 = 0), then it returns immediately         ;
                             ; (unless you called Init_Music or Init_Music_dft, which do not make    ;
                             ; this check).  When a sound is in progress, $C856 will be set to 0x80. ;
                             ;                                                                       ;
                             ; These routines process a single note at a time, and calculate the     ;
                             ; amplitude and course/fine tuning values for the 3 sound channels.     ;
                             ; The values calculated are stored in the music work buffer, at         ;
                             ; $C83F-$C84C.                                                          ;
                             ;                                                                       ;
                             ; Music data format:                                                    ;
                             ;                                                                       ;
                             ;       header word -> $C84F  32 nibble ADSR table                      ;
                             ;       header word -> $C851  8-byte "twang" table                      ;
                             ;       data bytes                                                      ;
                             ;                                                                       ;
                             ; The ADSR table is simply 32 nibbles (16 bytes) of amplitude values.   ;
                             ;                                                                       ;
                             ; The twang table is 8 signed bytes to modify the base frequency of     ;
                             ; each note being played.  Each channel has a different limit to its    ;
                             ; twang table index (6-8) to keep them out of phase to each other.      ;
                             ;                                                                       ;
                             ; Music data bytes:                                                     ;
                             ;       Bits 0-5 = frequency                                            ;
                             ;       Bit 6 clear = tone                                              ;
                             ;       Bit 6 set = noise                                               ;
                             ;       Bit 7 set = next music data byte is for next channel            ;
                             ;       Bit 7 clear, play note with duration in next music data byte:   ;
                             ;               bits 0-5 = duration                                     ;
                             ;               bit 6 = unused                                          ;
                             ;               bit 7 set = end of music                                ;
                             ;                                                                       ;
                             ; ENTRY DP = $C8                                                        ;
                             ;       U-reg points to the start of the music data                     ;
                             ;       $C84D points to frequency table (Init_Music_dft only)           ;
                             ;       $C856 may need to be set.                                       ;
                             ;                                                                       ;
                             ;       D-reg, X-reg, Y-reg, U-reg trashed                              ;
                             ;-----------------------------------------------------------------------;
                             
f687 : 9656             [ 4] Init_Music_chk: LDA     <Vec_Music_Flag ;Test sound active flag
f689 : 2b28             [ 3]                 BMI     LF6B3           ;Continue sound if active
f68b : 27f9             [ 3]                 BEQ     LF686           ;Return if sound not active
f68d : 8efc8d           [ 3] Init_Music:     LDX     #Freq_Table     ;Save pointer to frequency table
f690 : 9f4d             [ 5]                 STX     <Vec_Freq_Table
f692 : 8680             [ 2] Init_Music_dft: LDA     #$80            ;Set sound active flag
f694 : 9756             [ 4]                 STA     <Vec_Music_Flag
f696 : ecc1             [ 8]                 LDD     ,U++            ;Save address of ADSR table
f698 : dd4f             [ 5]                 STD     <Vec_ADSR_Table
f69a : ecc1             [ 8]                 LDD     ,U++            ;Save address of twang table
f69c : dd51             [ 5]                 STD     <Vec_Twang_Table
f69e : df53             [ 5]                 STU     <Vec_Music_Ptr  ;Save pointer to music data
f6a0 : bdf533           [ 9]                 JSR     Init_Music_Buf  ;Initialize music buffer
f6a3 : cc1f1f           [ 3]                 LDD     #$1F1F
f6a6 : dd5f             [ 5]                 STD     <Vec_ADSR_Timers+1;Init ADSR timers of chans 2 & 3
f6a8 : cc0000           [ 3]                 LDD     #$0000
f6ab : dd63             [ 5]                 STD     <Vec_Music_Freq+2;Clear frequency of channel 2
f6ad : dd65             [ 5]                 STD     <Vec_Music_Freq+4;Clear frequency of channel 3
f6af : 9755             [ 4]                 STA     <Vec_Music_Chan ;A-reg = 0 (sound channel number?)
f6b1 : 2039             [ 3]                 BRA     LF6EC
                             
                             ; Continue currently playing sound here
                             
f6b3 : cec85e           [ 3] LF6B3:          LDU     #Vec_ADSR_Timers;Get address of ADSR timers
f6b6 : c602             [ 2]                 LDB     #$02            ;Count for three channels
f6b8 : a6c5             [ 5] LF6B8:          LDA     B,U             ;Get the channel's ADSR timer
f6ba : 811f             [ 2]                 CMPA    #$1F
f6bc : 2702             [ 3]                 BEQ     LF6C0           ;Skip if at maximum
f6be : 6cc5             [ 7]                 INC     B,U             ;Else increment the timer
f6c0 : 5a               [ 2] LF6C0:          DECB                    ;Go back for the other channels
f6c1 : 2af5             [ 3]                 BPL     LF6B8
f6c3 : 9e51             [ 5]                 LDX     <Vec_Twang_Table
f6c5 : cec858           [ 3]                 LDU     #Vec_Music_Twang
f6c8 : 8607             [ 2]                 LDA     #$07            ;Twang limit is 6-8 depending on channel
f6ca : 6cc4             [ 6] LF6CA:          INC     ,U              ;Increment twang counter
f6cc : a1c4             [ 4]                 CMPA    ,U              ;Check against limit
f6ce : 2c02             [ 3]                 BGE     LF6D2
f6d0 : 6fc4             [ 6]                 CLR     ,U              ;Clear it if limit exceeded
f6d2 : e6c0             [ 6] LF6D2:          LDB     ,U+             ;Get twang count
f6d4 : c407             [ 2]                 ANDB    #$07            ;Mask out low 3 bits
f6d6 : e685             [ 5]                 LDB     B,X             ;Get twang value from table
f6d8 : e7c0             [ 6]                 STB     ,U+             ;Update current twang value
f6da : 4c               [ 2]                 INCA                    ;Increment twang limit
f6db : 8109             [ 2]                 CMPA    #$09
f6dd : 23eb             [ 3]                 BLS     LF6CA           ;Go back until all three channels done
f6df : 0a57             [ 6]                 DEC     <Vec_Duration   ;Decrement the duration timer
f6e1 : 266b             [ 3]                 BNE     LF74E           ;Update ADSR while note still playing
f6e3 : 9655             [ 4] LF6E3:          LDA     <Vec_Music_Chan ;Go to next music channel
f6e5 : 4a               [ 2]                 DECA
f6e6 : 2a02             [ 3]                 BPL     LF6EA           ;If < 0, set it to 2
f6e8 : 8602             [ 2]                 LDA     #$02
f6ea : 9755             [ 4] LF6EA:          STA     <Vec_Music_Chan
f6ec : e69fc853         [ 9] LF6EC:          LDB     [Vec_Music_Ptr] ;Get next byte of music data
f6f0 : cec85e           [ 3]                 LDU     #Vec_ADSR_Timers;Clear ADSR timer for this channel
f6f3 : 6fc6             [ 7]                 CLR     A,U
f6f5 : c540             [ 2]                 BITB    #$40            ;If $40 bit of music data set,
f6f7 : 2719             [ 3]                 BEQ     LF712           ;we're going to make some noise
f6f9 : 8ef9e4           [ 3]                 LDX     #Music_Table_1  ;Get bit mask for this channel
f6fc : a686             [ 5]                 LDA     A,X
f6fe : 9445             [ 4]                 ANDA    <Vec_Music_Wk_7 ;Turn channel bit off for register 7
f700 : 9745             [ 4]                 STA     <Vec_Music_Wk_7
f702 : 9655             [ 4]                 LDA     <Vec_Music_Chan ;Set current channel bit in register 7
f704 : 8b03             [ 2]                 ADDA    #$03
f706 : a686             [ 5]                 LDA     A,X
f708 : 9a45             [ 4]                 ORA     <Vec_Music_Wk_7
f70a : 9745             [ 4]                 STA     <Vec_Music_Wk_7
f70c : c41f             [ 2]                 ANDB    #$1F            ;Mask off low 5 bits of music data
f70e : d746             [ 4]                 STB     <Vec_Music_Wk_6 ;and store in register 6
f710 : 2023             [ 3]                 BRA     LF735
                             
f712 : 8ef9ea           [ 3] LF712:          LDX     #Music_Table_2  ;If $40 bit of music data was cleared,
f715 : a686             [ 5]                 LDA     A,X             ;Get bit mask for this channel
f717 : 9445             [ 4]                 ANDA    <Vec_Music_Wk_7 ;Turn channel bit off for register 7
f719 : 9745             [ 4]                 STA     <Vec_Music_Wk_7
f71b : 9655             [ 4]                 LDA     <Vec_Music_Chan ;Set current channel bit in register 7
f71d : 8b03             [ 2]                 ADDA    #$03
f71f : a686             [ 5]                 LDA     A,X
f721 : 9a45             [ 4]                 ORA     <Vec_Music_Wk_7
f723 : 9745             [ 4]                 STA     <Vec_Music_Wk_7
f725 : 9655             [ 4]                 LDA     <Vec_Music_Chan ;Get $C855 * 2 + 3
f727 : 48               [ 2]                 ASLA
f728 : 8b03             [ 2]                 ADDA    #Vec_Music_Freq-Vec_ADSR_Timers
f72a : 33c6             [ 5]                 LEAU    A,U             ;Point U-reg to #$C861 + $C855 * 2
f72c : c43f             [ 2]                 ANDB    #$3F            ;Mask off low 6 bits of music data,
f72e : 58               [ 2]                 ASLB                    ;multiply by 2
f72f : 9e4d             [ 5]                 LDX     <Vec_Freq_Table ;Get pointer to note-to-frequency table
f731 : ec85             [ 6]                 LDD     B,X             ;Get note table data
f733 : edc4             [ 5]                 STD     ,U              ;Store in word at $C861-$C866
f735 : 9e53             [ 5] LF735:          LDX     <Vec_Music_Ptr  ;Re-get byte of music data
f737 : e680             [ 6]                 LDB     ,X+
f739 : 9f53             [ 5]                 STX     <Vec_Music_Ptr  ;Update music data pointer
f73b : 5d               [ 2]                 TSTB
f73c : 2ba5             [ 3]                 BMI     LF6E3           ;If byte>=$80, advance to next channel
f73e : e680             [ 6]                 LDB     ,X+             ;Get second byte of music data
f740 : 2a06             [ 3]                 BPL     LF748           ;If >=$80, (terminator)
f742 : bdf533           [ 9]                 JSR     Init_Music_Buf  ;  clear music buffer,
f745 : 0f56             [ 6]                 CLR     <Vec_Music_Flag ;  clear music flag,
f747 : 39               [ 5]                 RTS                     ;  and exit
                             
f748 : 9f53             [ 5] LF748:          STX     <Vec_Music_Ptr  ;Update music data pointer
f74a : c43f             [ 2]                 ANDB    #$3F            ;Duration in low 6 bits of second byte
f74c : d757             [ 4]                 STB     <Vec_Duration   ;Store duration counter
f74e : 109e4f           [ 6] LF74E:          LDY     <Vec_ADSR_Table ;Get pointer to ADSR table
f751 : cec85e           [ 3]                 LDU     #Vec_ADSR_Timers;Point to ADSR timer table
f754 : 8ec842           [ 3]                 LDX     #Vec_Music_Wk_A
f757 : 8602             [ 2]                 LDA     #$02            ;Count for three channels
f759 : e6c0             [ 6] LF759:          LDB     ,U+             ;Get channel timer?
f75b : c501             [ 2]                 BITB    #$01            ;Test low bit of ADSR index
f75d : 2707             [ 3]                 BEQ     LF766
f75f : 54               [ 2]                 LSRB                    ;If odd, divide ADSR index by by 2
f760 : e6a5             [ 5]                 LDB     B,Y             ;Get low nibble from ADSR table
f762 : c40f             [ 2]                 ANDB    #$0F
f764 : 2007             [ 3]                 BRA     LF76D
                             
f766 : 54               [ 2] LF766:          LSRB                    ;If even, divide ADSR index by 2
f767 : e6a5             [ 5]                 LDB     B,Y             ;Get high nibble from ADSR table
f769 : 54               [ 2]                 LSRB
f76a : 54               [ 2]                 LSRB
f76b : 54               [ 2]                 LSRB
f76c : 54               [ 2]                 LSRB
f76d : e786             [ 5] LF76D:          STB     A,X             ;Store ADSR value in regs 10-12
f76f : 4a               [ 2]                 DECA                    ;Decrement channel counter
f770 : 2ae7             [ 3]                 BPL     LF759           ;Go back for next channel
f772 : cec867           [ 3]                 LDU     #Vec_Music_Freq+6;Point to base frequency table
f775 : 8ec847           [ 3]                 LDX     #Vec_Music_Wk_5 ;Point to twang table
f778 : ecc3             [ 8] LF778:          LDD     ,--U            ;Get next base frequency
f77a : 6d58             [ 7]                 TST     -8,U            ;Test twang value
f77c : 2a0a             [ 3]                 BPL     LF788
f77e : 6058             [ 7]                 NEG     -8,U            ;If <0, negate twang table entry
f780 : e058             [ 5]                 SUBB    -8,U            ;Subtract negated value from frequency
f782 : 8200             [ 2]                 SBCA    #$00            ;Propagate borrow to high byte
f784 : 6058             [ 7]                 NEG     -8,U            ;Un-negate twang entry
f786 : 2004             [ 3]                 BRA     LF78C
                             
f788 : eb58             [ 5] LF788:          ADDB    -8,U            ;If >0 add twang to base frequency
f78a : 8900             [ 2]                 ADCA    #$00            ;Propagate carry to high byte
f78c : ed81             [ 8] LF78C:          STD     ,X++            ;Store freq in regs 5/4, 3/2, 1/0
f78e : 8cc84d           [ 4]                 CMPX    #Vec_Music_Work+14
f791 : 26e5             [ 3]                 BNE     LF778
f793 : 39               [ 5] LF793_RTS:      RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F7A9    Select_Game                                             ;
                             ;                                                                       ;
                             ; This routine provides a game with the means for allowing the player   ;
                             ; to choose the game number he would like to play, and the number of    ;
                             ; players.  The game indicates the number of game versions available,   ;
                             ; by placing the  value in the B register.  The number of players       ;
                             ; allowed is specified in the A register.  If a parameter is passed in  ;
                             ; with a value of 0, then the corresponding question will not be asked. ;
                             ; The number of players selected is returned in $C879, while the game   ;
                             ; number selected is returned in $C87A.                                 ;
                             ;                                                                       ;
                             ; This routine performs most of the work involved in allowing the       ;
                             ; player to select a game version and the number of players.  It        ;
                             ; displays the game # and player options, and allows the player a       ;
                             ; certain amount of time to modify their values.  Anytime one of the    ;
                             ; buttons is used to modify a value, the timer will be restarted.       ;
                             ; When a button is pressed, the associated value is modified,           ;
                             ; and then redisplayed on the screen.  This routine will return when    ;
                             ; either the timer expires, or button 4 is pressed.                     ;
                             ;                                                                       ;
                             ; ENTRY A-reg = maximum number of players allowed                       ;
                             ;       B-reg = number of game versions available                       ;
                             ;                                                                       ;
                             ; EXIT: DP = $C8                                                        ;
                             ;       $C879 contains number of players selected                       ;
                             ;       $C87A contains the game version selected                        ;
                             ;                                                                       ;
                             ;       D-reg, X-reg, Y-reg trashed                                     ;
                             ;-----------------------------------------------------------------------;
                             
f794 : 20c0                  Player_Str:     FDB     $20C0
f796 : 40c0                                  FDB     $40C0
f798 : 504c41594552                          FCC     "PLAYER"
f79e : 80                                    FCB     $80
                             
f79f : e0c0                  Game_Str:       FDB     $E0C0
f7a1 : 01c0                                  FDB     $01C0
f7a3 : 2047414d45                            FCC     " GAME"
f7a8 : 80                                    FCB     $80
                             
f7a9 : fdc84f           [ 6] Select_Game:    STD     Vec_Max_Players ;Save max players and games
f7ac : 4d               [ 2]                 TSTA                    ;If non-zero players specified,
f7ad : 2702             [ 3]                 BEQ     LF7B1
f7af : 8601             [ 2]                 LDA     #$01            ;  set selection to 1
f7b1 : 5d               [ 2] LF7B1:          TSTB                    ;If non-zero games specified,
f7b2 : 2702             [ 3]                 BEQ     LF7B6
f7b4 : c601             [ 2]                 LDB     #$01            ;  set selection to 1
f7b6 : fdc879           [ 6] LF7B6:          STD     Vec_Num_Players ;Save default selection
f7b9 : bdf1af           [ 9]                 JSR     DP_to_C8        ;DP to RAM
f7bc : ccf850           [ 3]                 LDD     #$F850
f7bf : dd2a             [ 5]                 STD     <Vec_Text_HW
f7c1 : 973c             [ 4]                 STA     <$C83C          ;Set $C83C flag to non-zero
f7c3 : 2067             [ 3]                 BRA     LF82C
                             
f7c5 : bdf192           [ 9] LF7C5:          JSR     Wait_Recal      ;Start with a fresh frame, DP to I/O
f7c8 : 4f               [ 2]                 CLRA                    ;Read buttons, all in direct mode
f7c9 : bdf1b4           [ 9]                 JSR     Read_Btns_Mask
f7cc : bdf55a           [ 9]                 JSR     Dec_3_Counters
f7cf : bdf2a9           [ 9]                 JSR     Intensity_7F    ;Brightness to normal
f7d2 : b6c879           [ 5]                 LDA     Vec_Num_Players ;Display number of players
f7d5 : 108ef794         [ 4]                 LDY     #Player_Str
f7d9 : 8d5a             [ 7]                 BSR     Display_Option
f7db : b6c87a           [ 5]                 LDA     Vec_Num_Game    ;Display currently selected game
f7de : 108ef79f         [ 4]                 LDY     #Game_Str
f7e2 : 8d51             [ 7]                 BSR     Display_Option
f7e4 : bdf1af           [ 9]                 JSR     DP_to_C8        ;DP to RAM
f7e7 : 963c             [ 4]                 LDA     <$C83C          ;If $C83C=0, check buttons
f7e9 : 2706             [ 3]                 BEQ     LF7F1
f7eb : 960f             [ 4]                 LDA     <Vec_Btn_State
f7ed : 263d             [ 3]                 BNE     LF82C           ;If any button pressed, reset timers
f7ef : 0f3c             [ 6]                 CLR     <$C83C          ;Clear $C83C flag
f7f1 : 962f             [ 4] LF7F1:          LDA     <Vec_Counter_2  ;Return if counter 2 timed out
f7f3 : 279e             [ 3]                 BEQ     LF793_RTS
f7f5 : 962e             [ 4]                 LDA     <Vec_Counter_1  ;If repeat timer not timed out,
f7f7 : 26cc             [ 3]                 BNE     LF7C5           ;  ignore the buttons
f7f9 : 9615             [ 4]                 LDA     <Vec_Button_1_4
f7fb : 2696             [ 3]                 BNE     LF793_RTS       ;Return if button 4 pressed
f7fd : 9612             [ 4]                 LDA     <Vec_Button_1_1
f7ff : 270f             [ 3]                 BEQ     LF810
f801 : 9679             [ 4]                 LDA     <Vec_Num_Players; Ignore if no players option
f803 : 270b             [ 3]                 BEQ     LF810           ;If button 1 pressed,
f805 : 4c               [ 2]                 INCA                    ;   increment number of players
f806 : 914f             [ 4]                 CMPA    <Vec_Max_Players
f808 : 2302             [ 3]                 BLS     LF80C
f80a : 8601             [ 2]                 LDA     #$01            ;Reset to 1 if max players exceeded
f80c : 9779             [ 4] LF80C:          STA     <Vec_Num_Players; Update number of players
f80e : 201c             [ 3]                 BRA     LF82C           ;Update timers and go back to the loop
                             
f810 : 967a             [ 4] LF810:          LDA     <Vec_Num_Game   ;Return to the loop if no game options
f812 : 27b1             [ 3]                 BEQ     LF7C5
f814 : d613             [ 4]                 LDB     <Vec_Button_1_2
f816 : 2709             [ 3]                 BEQ     LF821
f818 : 4c               [ 2]                 INCA                    ;If button 2 down, increment game
f819 : 9150             [ 4]                 CMPA    <Vec_Max_Games
f81b : 230d             [ 3]                 BLS     LF82A
f81d : 8601             [ 2]                 LDA     #$01            ;Reset to 1 if maximum exceeded
f81f : 2009             [ 3]                 BRA     LF82A
                             
f821 : d614             [ 4] LF821:          LDB     <Vec_Button_1_3
f823 : 27a0             [ 3]                 BEQ     LF7C5
f825 : 4a               [ 2]                 DECA                    ;If button 3 down, decrement game
f826 : 2602             [ 3]                 BNE     LF82A
f828 : 9650             [ 4]                 LDA     <Vec_Max_Games  ;Reset to max if zero reached
f82a : 977a             [ 4] LF82A:          STA     <Vec_Num_Game
f82c : 86f3             [ 2] LF82C:          LDA     #$F3            ;Reset timers
f82e : 972f             [ 4]                 STA     <Vec_Counter_2
f830 : 43               [ 2]                 COMA
f831 : 972e             [ 4]                 STA     <Vec_Counter_1
f833 : 2090             [ 3]                 BRA     LF7C5           ;Go back to the loop
                             
                             ;-----------------------------------------------------------------------;
                             ;       F835    Display_Option  (not called by GCE cartridges)          ;
                             ;                                                                       ;
                             ; This routine displays the player or game option string, along with    ;
                             ; the current value for that option.  The A-register contains the       ;
                             ; value of the option, while the Y-register points to a block of the    ;
                             ; following form:                                                       ;
                             ;                                                                       ;
                             ;       rel y, rel x,      ( for value )                                ;
                             ;       rel y, rel x,      ( for option string)                         ;
                             ;       option string,                                                  ;
                             ;       0x80                                                            ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       A-reg=the option value.                                         ;
                             ;       Y-reg points to the string block.                               ;
                             ;                                                                       ;
                             ;       D-reg, U-reg, X-reg trashed                                     ;
                             ;-----------------------------------------------------------------------;
                             
f835 : 8ec85e           [ 3] Display_Option: LDX     #$C85E          ;Point to temp storage
f838 : 3402             [ 6]                 PSHS    A               ;Save option
f83a : 8d13             [ 7]                 BSR     Clear_Score     ;Clear scratch score accumulator
f83c : a6e0             [ 6]                 LDA     ,S+             ;Get option back
f83e : 270e             [ 3]                 BEQ     LF84E           ;Exit printing nothing if option = zero
f840 : 8d1c             [ 7]                 BSR     Add_Score_a     ;Put option in scratch score accumulator
f842 : 1f13             [ 6]                 TFR     X,U             ;Transfer X to be printed
f844 : eca1             [ 8]                 LDD     ,Y++            ;Get (y,x) of value
f846 : bdf37a           [ 9]                 JSR     Print_Str_d     ;Print value
f849 : 1f23             [ 6]                 TFR     Y,U             ;Transfer Y to be printed
f84b : bdf378           [ 9]                 JSR     Print_Str_yx    ;Print option string
f84e : 39               [ 5] LF84E:          RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F84F    Clear_Score                                             ;
                             ;                                                                       ;
                             ; This routine will initialize the passed-in score string (pointed to   ;
                             ; by the X-register) to the following value:                            ;
                             ;                                                                       ;
                             ;       "     0",0x80                                                   ;
                             ;                                                                       ;
                             ; ENTRY X-reg points to seven byte score accumulator                    ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f84f : cc2020           [ 3] Clear_Score:    LDD     #' '*256+' '    ;Store the leading blanks
f852 : ed84             [ 5]                 STD     ,X
f854 : ed02             [ 6]                 STD     2,X
f856 : a704             [ 5]                 STA     4,X
f858 : cc3080           [ 3]                 LDD     #'0'*256+$80    ;Store the zero and terminator byte
f85b : ed05             [ 6]                 STD     5,X
f85d : 39               [ 5]                 RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F85E    Add_Score_a                                             ;
                             ;       F87C    Add_Score_d                                             ;
                             ;                                                                       ;
                             ; These routines take the BCD value in the D-register or the binary     ;
                             ; value in the A-register, and add it to the 6-byte ASCII number        ;
                             ; pointed by the X-register.                                            ;
                             ;                                                                       ;
                             ; ENTRY A-reg = binary value (Add_Score_a only)                         ;
                             ;       D-reg = BCD value (Add_Score_d only)                            ;
                             ;       U-reg = BCD conversion of A-reg (Add_Score_a only)              ;
                             ;       X-reg points to six byte ASCII score accumulator                ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f85e : ce0000           [ 3] Add_Score_a:    LDU     #$0000          ;Initialize BCD result to zero
f861 : 8163             [ 2] LF861:          CMPA    #99             ;Add in the hundreds
f863 : 2308             [ 3]                 BLS     LF86D
f865 : 8064             [ 2]                 SUBA    #100
f867 : 33c90100         [ 8]                 LEAU    $0100,U
f86b : 20f4             [ 3]                 BRA     LF861
                             
f86d : 8109             [ 2] LF86D:          CMPA    #9              ;Add in the tens
f86f : 2307             [ 3]                 BLS     LF878
f871 : 800a             [ 2]                 SUBA    #10
f873 : 33c810           [ 5]                 LEAU    $10,U
f876 : 20f5             [ 3]                 BRA     LF86D
                             
f878 : 33c6             [ 5] LF878:          LEAU    A,U             ;Add in the ones
f87a : 1f30             [ 6]                 TFR     U,D             ;Move it to the D-register
                             
f87c : 3402             [ 6] Add_Score_d:    PSHS    A               ;Save BCD on stack in reverse order
f87e : 3404             [ 6]                 PSHS    B
f880 : c605             [ 2]                 LDB     #$05
f882 : 4f               [ 2] LF882:          CLRA                    ;Add zero to 10000 and 100000 digits
f883 : c101             [ 2]                 CMPB    #$01
f885 : 2310             [ 3]                 BLS     LF897
f887 : c501             [ 2]                 BITB    #$01            ;Add right nibble to hundreds and ones
f889 : 2704             [ 3]                 BEQ     LF88F
f88b : a6e4             [ 4]                 LDA     ,S
f88d : 2006             [ 3]                 BRA     LF895
                             
f88f : a6e0             [ 6] LF88F:          LDA     ,S+             ;Add left nibble to thousands and tens
f891 : 44               [ 2]                 LSRA
f892 : 44               [ 2]                 LSRA
f893 : 44               [ 2]                 LSRA
f894 : 44               [ 2]                 LSRA
f895 : 840f             [ 2] LF895:          ANDA    #$0F            ;Isolate desired nibble
f897 : bbc823           [ 5] LF897:          ADDA    $C823           ;Add in carry ($C823 is normally zero)
f89a : 7fc823           [ 7]                 CLR     $C823           ;Clear carry
f89d : ab85             [ 5]                 ADDA    B,X             ;Add to digit
f89f : 812f             [ 2]                 CMPA    #'0'-1          ;If digit was a blank,
f8a1 : 2e02             [ 3]                 BGT     LF8A5
f8a3 : 8b10             [ 2]                 ADDA    #$10            ;  promote the result to a digit
f8a5 : 8139             [ 2] LF8A5:          CMPA    #'9'            ;If a carry has occurred,
f8a7 : 2305             [ 3]                 BLS     LF8AE
f8a9 : 800a             [ 2]                 SUBA    #10             ;  subtract ten
f8ab : 7cc823           [ 7]                 INC     $C823           ;  and set carry flag
f8ae : a785             [ 5] LF8AE:          STA     B,X             ;Store resulting digit
f8b0 : 5a               [ 2]                 DECB                    ;Go back for more digits
f8b1 : 2acf             [ 3]                 BPL     LF882
f8b3 : 7fc823           [ 7]                 CLR     $C823           ;Clear $C823 back to zero
f8b6 : 5f               [ 2]                 CLRB
                             
                             ;-----------------------------------------------------------------------;
                             ;       F8B7    Strip_Zeros                                             ;
                             ;                                                                       ;
                             ; This routine strips the leading zeros from a score accumulator.       ;
                             ;                                                                       ;
                             ; ENTRY B-reg = first digit to start with (usually zero)                ;
                             ;       X-reg points to six byte ASCII score accumulator                ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f8b7 : a685             [ 5] Strip_Zeros:    LDA     B,X             ;Test current digit
f8b9 : 8130             [ 2]                 CMPA    #'0'
f8bb : 2609             [ 3]                 BNE     LF8C6           ;Exit if not zero
f8bd : 8620             [ 2]                 LDA     #' '            ;Change it to a blank
f8bf : a785             [ 5]                 STA     B,X
f8c1 : 5c               [ 2]                 INCB
f8c2 : c105             [ 2]                 CMPB    #$05
f8c4 : 2df1             [ 3]                 BLT     Strip_Zeros
f8c6 : 39               [ 5] LF8C6:          RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F8C7    Compare_Score                                           ;
                             ;                                                                       ;
                             ; This routine will compare two BCD score strings, to determine which   ;
                             ; one is higher.  The two strings are pointed to by the U and X         ;
                             ; registers.  Depending upon how the scores compare, one of the         ;
                             ; following values will be returned in the A-register:                  ;
                             ;                                                                       ;
                             ;       1) The scores are the same: a = 0                               ;
                             ;       2) X score > U score:   a = 1                                   ;
                             ;       3) U score > X score:   a = 2                                   ;
                             ;                                                                       ;
                             ; ENTRY X-reg points to first score string (terminated with $80)        ;
                             ;       U-reg points to second score string                             ;
                             ;                                                                       ;
                             ; EXIT: A-reg returns result of the compare                             ;
                             ;                                                                       ;
                             ;       B-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
f8c7 : 3450             [ 9] Compare_Score:  PSHS    X,U             ;Save score pointers
f8c9 : 4f               [ 2]                 CLRA                    ;Default to scores are the same
f8ca : e680             [ 6] LF8CA:          LDB     ,X+
f8cc : 2b08             [ 3]                 BMI     LF8D6           ;Return if end of string
f8ce : e1c0             [ 6]                 CMPB    ,U+
f8d0 : 27f8             [ 3]                 BEQ     LF8CA           ;Continue if byte is the same
f8d2 : 2201             [ 3]                 BHI     LF8D5           ;Return 1 if X > U
f8d4 : 4c               [ 2]                 INCA                    ;Return 2 if U > X
f8d5 : 4c               [ 2] LF8D5:          INCA
f8d6 : 35d0             [11] LF8D6:          PULS    X,U,PC          ;Restore pointers and return
                             
                             ;-----------------------------------------------------------------------;
                             ;       F8D8    New_High_Score                                          ;
                             ;                                                                       ;
                             ; This routine compares a players score string, pointed to by the       ;
                             ; X register, to the current hi score, pointed by the U register.  If   ;
                             ; the player's score is higher than the currently saved hi score, then  ;
                             ; the player's score will be copied into the hi score buffer pointed    ;
                             ; to by the U register.                                                 ;
                             ;                                                                       ;
                             ; ENTRY X-reg points to a player's score string                         ;
                             ;       U-reg points to the high score string (usually $CBEB?)          ;
                             ;                                                                       ;
                             ;       X-reg, U-reg, D-reg trashed                                     ;
                             ;-----------------------------------------------------------------------;
                             
f8d8 : 8ded             [ 7] New_High_Score: BSR     Compare_Score   ;Compare the scores
f8da : 8101             [ 2]                 CMPA    #$01
f8dc : 2606             [ 3]                 BNE     LF8E4           ;Return if X is not > U
f8de : a680             [ 6] LF8DE:          LDA     ,X+             ;Copy the new high score
f8e0 : a7c0             [ 6]                 STA     ,U+
f8e2 : 2afa             [ 3]                 BPL     LF8DE           ;until end of string encountered
f8e4 : 39               [ 5] LF8E4:          RTS
                             
                             ;-----------------------------------------------------------------------;
                             ;       F8E5    Obj_Will_Hit_u                                          ;
                             ;       F8F3    Obj_Will_Hit                                            ;
                             ;                                                                       ;
                             ; This routine first modifies the position of the object, and then it   ;
                             ; checks to see if the missile has hit the object.  The Y register      ;
                             ; contains the (y,x) position of the object, the U register contains    ;
                             ; a pointer to the (y,x) modification values, the X register contains   ;
                             ; the missile (y,x) position, and the D register contains the           ;
                             ; (height/2, width/2) of the object.                                    ;
                             ;                                                                       ;
                             ; (0,u) is temporarily added to the y position of the object, and       ;
                             ; (1,u) is temporarily added to the x position.                         ;
                             ;                                                                       ;
                             ; ENTRY Y-reg = (y,x) position of the object                            ;
                             ;       X-reg = (y,x) position of the missile                           ;
                             ;       U-reg points to movement (y,x) (Mov_Obj_Hit_u only)             ;
                             ;       U-reg = movement (y,x) (Mov_Obj_Hit only)                       ;
                             ;       D-reg = (h/2,w/2) size of object                                ;
                             ;                                                                       ;
                             ; EXIT: Carry bit set if the object & missile have collided             ;
                             ;                                                                       ;
                             ;       ALL registers saved.  Even the original Y-register.             ;
                             ;-----------------------------------------------------------------------;
                             
f8e5 : 3420             [ 7] Obj_Will_Hit_u: PSHS    Y               ;Save regs for the hit-test code
f8e7 : 3436             [11]                 PSHS    D,X,Y
f8e9 : ec64             [ 6]                 LDD     4,S             ;Get object position
f8eb : abc4             [ 4]                 ADDA    ,U              ;Add it to the modification values
f8ed : eb41             [ 5]                 ADDB    1,U
f8ef : ed64             [ 6] LF8EF:          STD     4,S             ;Put updated object position back
f8f1 : 2010             [ 3]                 BRA     LF903           ;Go do the hit-test
                             
f8f3 : 3420             [ 7] Obj_Will_Hit:   PSHS    Y               ;Save regs for the hit-test code
f8f5 : 3436             [11]                 PSHS    D,X,Y
f8f7 : 1f30             [ 6]                 TFR     U,D             ;Get modification values
f8f9 : ab64             [ 5]                 ADDA    4,S             ;Add them to the object position
f8fb : eb65             [ 5]                 ADDB    5,S
f8fd : 20f0             [ 3]                 BRA     LF8EF           ;Put update position back and hit-test
                             
                             ;-----------------------------------------------------------------------;
                             ;       F8FF    Obj_Hit                                                 ;
                             ;                                                                       ;
                             ; Thit routine checks to see if a missile hashit an object.  If the     ;
                             ; missile has hit the object, then the carry bit will be set;           ;
                             ; otherwise, the carry bit will be cleared.  A hit is checked for in    ;
                             ; the following fashion:                                                ;
                             ;                                                                       ;
                             ;   if (object y-height/2) <= missile y <= (object y+height/2)          ;
                             ;                               and                                     ;
                             ;      (object x-width/2)  <= missile x <= (object x+width/x)           ;
                             ;                                                                       ;
                             ;   then the missile hit, otherwise it missed.                          ;
                             ;                                                                       ;
                             ; ENTRY Y-reg = (y,x) position of the object                            ;
                             ;       X-reg = (y,x) position of the missile                           ;
                             ;       D-reg = (h/2,w/2) size of object                                ;
                             ;                                                                       ;
                             ; EXIT: Carry bit set if the object & missile have collided             ;
                             ;                                                                       ;
                             ;       All registers preserved.                                        ;
                             ;-----------------------------------------------------------------------;
                             
f8ff : 3420             [ 7] Obj_Hit:        PSHS    Y               ;Save some regs
f901 : 3436             [11]                 PSHS    D,X,Y
f903 : 1f41             [ 6] LF903:          TFR     S,X             ;Point X to the stack
f905 : 5f               [ 2]                 CLRB                    ;Offset to point to y
f906 : 3a               [ 3] LF906:          ABX
f907 : a604             [ 5]                 LDA     4,X             ;Get height/2
f909 : ab84             [ 4]                 ADDA    ,X              ;Add object y
f90b : 2802             [ 3]                 BVC     LF90F
f90d : 867f             [ 2]                 LDA     #$7F            ;Set to $7F if overflow
f90f : a102             [ 5] LF90F:          CMPA    2,X             ;Branch if missile out of range
f911 : 2d15             [ 3]                 BLT     LF928
f913 : a604             [ 5]                 LDA     4,X             ;Get height/2
f915 : a084             [ 4]                 SUBA    ,X              ;Subtract object y
f917 : 2802             [ 3]                 BVC     LF91B
f919 : 8680             [ 2]                 LDA     #$80            ;Set to $80 if overflow
f91b : a102             [ 5] LF91B:          CMPA    2,X             ;Branch if missile out of range
f91d : 2e09             [ 3]                 BGT     LF928
f91f : 5c               [ 2]                 INCB                    ;Offset to point to x
f920 : c102             [ 2]                 CMPB    #$02
f922 : 25e2             [ 3]                 BCS     LF906           ;Go back for x
f924 : 1a01             [ 3]                 ORCC    #$01            ;Object in range, set carry
f926 : 2002             [ 3]                 BRA     LF92A
                             
f928 : 1cfe             [ 3] LF928:          ANDCC   #$FE            ;Object not in range, clear carry
f92a : 3536             [11] LF92A:          PULS    D,X,Y
f92c : 35a0             [ 9]                 PULS    Y,PC
                             
                             ;-----------------------------------------------------------------------;
                             ;       F92E    Explosion_Snd                                           ;
                             ;                                                                       ;
                             ; This routine appears to generate some type of an explosion sound,     ;
                             ; dependent upon the 4 bytes which are pointed to by the U register.    ;
                             ; You will probably need to call Do_Sound for this to do anything.      ;
                             ;                                                                       ;
                             ; The format of the 4-byte block is:                                    ;
                             ;       1)      Bits 0-2 = ?    Stored in $C85D                         ;
                             ;               Bits 3-5 = ?    Stored in $C853                         ;
                             ;               Bits 6-7 = 0                                            ;
                             ;               Bits 0-2 and 3-5 are ORed and stored in bits 0-2 of     ;
                             ;                                                               $C854   ;
                             ;       2)      <0 = ?          Something to do with register 6         ;
                             ;               =0 = ?                                                  ;
                             ;               >0 = ?                                                  ;
                             ;       3)      <0 = ?                                                  ;
                             ;               =0 = ?                                                  ;
                             ;               >0 = ?                                                  ;
                             ;       4)      Speed?  Higher values = lower duration?                 ;
                             ;                                                                       ;
                             ; ENTRY DP = $C8                                                        ;
                             ;       U-reg points to 4-byte block of data if $C867 high bit set      ;
                             ;                                                                       ;
                             ;       D-reg, X-reg trashed                                            ;
                             ;-----------------------------------------------------------------------;
                             
f92e : 9667             [ 4] Explosion_Snd:  LDA     <Vec_Expl_Flag
f930 : 2a29             [ 3]                 BPL     LF95B
f932 : 847f             [ 2]                 ANDA    #$7F
f934 : 9767             [ 4]                 STA     <Vec_Expl_Flag
f936 : 8ec858           [ 3]                 LDX     #Vec_Expl_1     ;Copy 4 bytes from U-reg to $C858
f939 : 8604             [ 2]                 LDA     #$04
f93b : bdf683           [ 9]                 JSR     Move_Mem_a
f93e : 54               [ 2]                 LSRB                    ;Divide first byte by 8
f93f : 54               [ 2]                 LSRB
f940 : 54               [ 2]                 LSRB
f941 : da58             [ 4]                 ORB     <Vec_Expl_1     ;OR with first byte
f943 : c407             [ 2]                 ANDB    #$07            ;AND with 7
f945 : d754             [ 4]                 STB     <Vec_Expl_Chans ;store in $C854
f947 : d658             [ 4]                 LDB     <Vec_Expl_1     ;Get first byte
f949 : c438             [ 2]                 ANDB    #$38            ;Mask off bits 3-5
f94b : d753             [ 4]                 STB     <Vec_Expl_ChanA ;store in $C853
f94d : d658             [ 4]                 LDB     <Vec_Expl_1     ;Get first byte
f94f : c407             [ 2]                 ANDB    #$07            ;AND with 7
f951 : d75d             [ 4]                 STB     <Vec_Expl_ChanB ;store in $C85D
f953 : c602             [ 2]                 LDB     #$02            ;Start with channel number 2
f955 : d75c             [ 4]                 STB     <Vec_Expl_Chan
f957 : 867f             [ 2]                 LDA     #$7F            ;Initialize time count
f959 : 200d             [ 3]                 BRA     LF968
                             
f95b : 9677             [ 4] LF95B:          LDA     <Vec_Expl_Timer
f95d : 276a             [ 3]                 BEQ     LF9C9_RTS
f95f : 905b             [ 4]                 SUBA    <Vec_Expl_4
f961 : 2a05             [ 3]                 BPL     LF968
f963 : 5f               [ 2]                 CLRB
f964 : d777             [ 4]                 STB     <Vec_Expl_Timer
f966 : 2062             [ 3]                 BRA     LF9CA
                             
f968 : 9777             [ 4] LF968:          STA     <Vec_Expl_Timer
f96a : 44               [ 2]                 LSRA
f96b : 44               [ 2]                 LSRA
f96c : d653             [ 4]                 LDB     <Vec_Expl_ChanA
f96e : 270d             [ 3]                 BEQ     LF97D
f970 : 9746             [ 4]                 STA     <Vec_Music_Wk_6
f972 : d659             [ 4]                 LDB     <Vec_Expl_2
f974 : 2b05             [ 3]                 BMI     LF97B
f976 : 2705             [ 3]                 BEQ     LF97D
f978 : 1f89             [ 6]                 TFR     A,B
f97a : 53               [ 2]                 COMB
f97b : d746             [ 4] LF97B:          STB     <Vec_Music_Wk_6
f97d : 44               [ 2] LF97D:          LSRA
f97e : 8107             [ 2]                 CMPA    #$07
f980 : 2305             [ 3]                 BLS     LF987
f982 : 810f             [ 2]                 CMPA    #$0F
f984 : 2701             [ 3]                 BEQ     LF987
f986 : 4c               [ 2]                 INCA
f987 : d65a             [ 4] LF987:          LDB     <Vec_Expl_3
f989 : 2b06             [ 3]                 BMI     LF991
f98b : 2702             [ 3]                 BEQ     LF98F
f98d : 880f             [ 2]                 EORA    #$0F
f98f : 1f89             [ 6] LF98F:          TFR     A,B
f991 : 8d37             [ 7] LF991:          BSR     LF9CA
f993 : d65d             [ 4]                 LDB     <Vec_Expl_ChanB
f995 : 272b             [ 3]                 BEQ     LF9C2
f997 : 965c             [ 4] LF997:          LDA     <Vec_Expl_Chan  ;Get channel number
f999 : 4a               [ 2]                 DECA                    ;Decrement channel number
f99a : 2a02             [ 3]                 BPL     LF99E
f99c : 8602             [ 2]                 LDA     #$02            ;Reset to 2 if less than zero
f99e : 975c             [ 4] LF99E:          STA     <Vec_Expl_Chan  ;Save channel number
f9a0 : bdf57e           [ 9]                 JSR     Bitmask_a       ;Get bit mask of the channel
f9a3 : 955d             [ 4]                 BITA    <Vec_Expl_ChanB
f9a5 : 27f0             [ 3]                 BEQ     LF997           ;Go back if not in for $C85D
f9a7 : d65c             [ 4]                 LDB     <Vec_Expl_Chan
f9a9 : 58               [ 2]                 ASLB                    ;Negative of channel number ; 2
f9aa : 50               [ 2]                 NEGB
f9ab : 8ec84b           [ 3]                 LDX     #Vec_Music_Wk_1 ;  (registers 1, 3, and 5)
f9ae : 3085             [ 5]                 LEAX    B,X
f9b0 : bdf517           [ 9]                 JSR     Random
f9b3 : 840f             [ 2]                 ANDA    #$0F
f9b5 : 8105             [ 2]                 CMPA    #$05
f9b7 : 2203             [ 3]                 BHI     LF9BC
f9b9 : 48               [ 2]                 ASLA
f9ba : 8b05             [ 2]                 ADDA    #$05
f9bc : a784             [ 4] LF9BC:          STA     ,X
f9be : 967e             [ 4]                 LDA     <Vec_Random_Seed+1
f9c0 : a701             [ 5]                 STA     1,X
f9c2 : 9658             [ 4] LF9C2:          LDA     <Vec_Expl_1
f9c4 : 43               [ 2]                 COMA
f9c5 : 9445             [ 4]                 ANDA    <Vec_Music_Wk_7
f9c7 : 9745             [ 4]                 STA     <Vec_Music_Wk_7
f9c9 : 39               [ 5] LF9C9_RTS:      RTS
                             
f9ca : 9654             [ 4] LF9CA:          LDA     <Vec_Expl_Chans
f9cc : 8ec845           [ 3]                 LDX     #Vec_Music_Wk_7
f9cf : 4d               [ 2] LF9CF:          TSTA                    ;Exit if all channels done
f9d0 : 2709             [ 3]                 BEQ     LF9DB_RTS
f9d2 : 301f             [ 5]                 LEAX    -1,X            ;Point to next register (8-10)
f9d4 : 44               [ 2]                 LSRA
f9d5 : 24f8             [ 3]                 BCC     LF9CF
f9d7 : e784             [ 4]                 STB     ,X              ;Store noise value if chan in use
f9d9 : 20f4             [ 3]                 BRA     LF9CF
                             
f9db : 39               [ 5] LF9DB_RTS:      RTS
                             
f9dc : 0102040810204080      Bit_Masks:      FCB     $01,$02,$04,$08,$10,$20,$40,$80 ;For Bitmask_a
                             
f9e4 : f7efdf010204          Music_Table_1:  FCB     $F7,$EF,$DF,$01,$02,$04         ;For noise
                             
f9ea : fefdfb081020          Music_Table_2:  FCB     $FE,$FD,$FB,$08,$10,$20         ;For music
                             
f9f0 : 7f7f8080              Recal_Points:   FDB     $7F7F,$8080                     ;For Recalibrate
                             
f9f4 : 0020505020c820..      Char_Table:     FDB     $0020,$5050,$20C8,$2010,$1040,$2000,$0000,$0008
fa04 : 3020707010f830..                      FDB     $3020,$7070,$10F8,$30F8,$7070,$0060,$0000,$0070
fa14 : 7020f070f0f8f8..                      FDB     $7020,$F070,$F0F8,LF878,$8870,$0888,$8088,$88F8
fa24 : f070f070f88888..                      FDB     $F070,$F070,$F888,$8888,$8888,$F870,$8070,$2000
fa34 : 00200820000000..                      FDB     $0020,$0820,$0000,$0038,$1020,$4444,$00FE,$FFFE
                             
fa44 : 0070505078c850..                      FDB     $0070,$5050,$78C8,$5020,$2020,$A820,$0000,$0008
fa54 : 48608888308040..                      FDB     $4860,$8888,$3080,$4008,$8888,$6060,$1000,$4088
fa64 : 88504888488080..                      FDB     $8850,$4888,$4880,$8080,$8820,$0890,$80D8,$C888
fa74 : 88888888a88888..                      FDB     $8888,$8888,$A888,$8888,$8888,$0840,$8008,$5000
fa84 : 00700c20707000..                      FDB     $0070,$0C20,$7070,$0044,$1070,$0000,$6C82,$FFFE
                             
fa94 : 007050f8a01050..                      FDB     $0070,$50F8,$A010,$5040,$4010,$7020,$0000,$0010
faa4 : 4820080850f080..                      FDB     $4820,$0808,$50F0,$8010,$8888,$6000,$2078,$2008
fab4 : a8884880488080..                      FDB     $A888,$4880,$4880,$8080,$8820,$08A0,$80A8,$A888
fac4 : 88888840208888..                      FDB     $8888,$8840,$2088,$8888,$5050,$1040,$4008,$8800
fad4 : 70a80a2088f860..                      FDB     $70A8,$0A20,$88F8,$60BA,$3820,$0000,$9282,$FFFE
                             
fae4 : 00200050702060..                      FDB     $0020,$0050,$7020,$6000,$4010,$A8F8,$0070,$0020
faf4 : 482070309008f0..                      FDB     $4820,$7030,$9008,$F020,$7078,$0060,$4000,$1010
fb04 : b888708048e0e0..                      FDB     $B888,$7080,$48E0,$E098,$F820,$08C0,$80A8,$9888
fb14 : f088f020208850..                      FDB     $F088,$F020,$2088,$50A8,$2020,$2040,$2008,$0000
fb24 : fe20082088f8f0..                      FDB     $FE20,$0820,$88F8,$F0A2,$38F8,$8238,$9282,$FFFE
                             
fb34 : 000000f87040a8..                      FDB     $0000,$00F8,$7040,$A800,$4010,$A820,$4000,$0040
fb44 : 48208008f80888..                      FDB     $4820,$8008,$F808,$8840,$8808,$6060,$2078,$2020
fb54 : b0f84880488080..                      FDB     $B0F8,$4880,$4880,$8088,$8820,$08A0,$8088,$8888
fb64 : 80a8a010208850..                      FDB     $80A8,$A010,$2088,$50A8,$5020,$4040,$1008,$0000
fb74 : fe2078a888f8f0..                      FDB     $FE20,$78A8,$88F8,$F0BA,$7C20,$4444,$6C82,$FFFE
                             
fb84 : 00000050289890..                      FDB     $0000,$0050,$2898,$9000,$2020,$0020,$4000,$0080
fb94 : 48208088108888..                      FDB     $4820,$8088,$1088,$8880,$8810,$6020,$1000,$4000
fba4 : 80884888488080..                      FDB     $8088,$4888,$4880,$8088,$8820,$8890,$8888,$8888
fbb4 : 80909088208820..                      FDB     $8090,$9088,$2088,$20A8,$8820,$8040,$0808,$0000
fbc4 : 4820f070707060..                      FDB     $4820,$F070,$7070,$6044,$6C50,$3882,$0082,$FFFE
                             
fbd4 : 00200050f89868..      Char_Table_End: FDB     $0020,$0050,$F898,$6800,$1040,$0000,$8000,$8080
fbe4 : 3070f870107070..                      FDB     $3070,$F870,$1070,$7080,$7060,$0040,$0000,$0020
fbf4 : 7888f070f0f880..                      FDB     $7888,$F070,$F0F8,$8078,$8870,$7088,$F888,$88F8
fc04 : 80688870207020..                      FDB     $8068,$8870,$2070,$2050,$8820,$F870,$0870,$00F8
fc14 : 00206020000000..                      FDB     $0020,$6020,$0000,$0038,$8288,$0000,$00FE,$FFFE
                             
                             ;       These tables are used by the rise/run calculations
                             
fc24 : 0011413021102031      DFC24:          FDB     $0011,$4130,$2110,$2031
                             
fc2c : 000103060a0f15..      DFC2C:          FDB     $0001,$0306,$0A0F,$151C,$242D,$0810,$0810,$0B08
fc3c : 100d0a08100e0b..                      FDB     $100D,$0A08,$100E,$0B09,$0810,$0E0C,$0A09,$0810
fc4c : 0e0d0b0a090810..                      FDB     $0E0D,$0B0A,$0908,$100F,$0D0C,$0B0A,$0908,$100F
fc5c : 0e0c0b0a090908..                      FDB     $0E0C,$0B0A,$0909,$0810,$0F0E,$0D0C,$0B0A,$0909
fc6c : 08                                    FCB     $08
                             
fc6d : 0019324a62798e..      DFC6D:          FDB     $0019,$324A,$6279,$8EA2,$B5C6,$D5E2,$EDF5,$FBFF
fc7d : fffffbf5ede2d5..                      FDB     $FFFF,$FBF5,$EDE2,$D5C6,$B5A2,$8E79,$624A,$3219
                             
                             ;       Music note to frequency table
                             
fc8d : 03bd0387035403..      Freq_Table:     FDB     $03BD,$0387,$0354,$0324,$02F7,$02CD,$02A4,$027E
fc9d : 025b0239021901..                      FDB     $025B,$0239,$0219,$01FB,$01DE,$01C3,$01AA,$0192
fcad : 017c0166015201..                      FDB     $017C,$0166,$0152,$013F,$012D,$011C,$010C,$00FD
fcbd : 00ef00e200d500..                      FDB     $00EF,$00E2,$00D5,$00C9,$00BE,$00B3,$00A9,$00A0
fccd : 0097008e008600..                      FDB     $0097,$008E,$0086,$007F,$0078,$0071,$006B,$0065
fcdd : 005f005a005500..                      FDB     $005F,$005A,$0055,$0050,$004B,$0047,$0043,$003F
fced : 003c0038003500..                      FDB     $003C,$0038,$0035,$0032,$002F,$002D,$002A,$0028
fcfd : 00260024002200..                      FDB     $0026,$0024,$0022,$0020,$001E,$001C,$001B,$0000
                             
                             ;       FD0D = power-on music and music for Crazy Coaster and Narrow Escape
                             
fd0d : fee8feb6931f0c..      Intro_Music:    FDB     DFEE8,DFEB6,$931F,$0C93,$1F06,$989F,$243C,$1180
                             
                             ;       FD1D = music for Berzerk?
                             
fd1d : fd69fd79210721..      DFD1D:          FDB     DFD69,DFD79,$2107,$2107,$2107,$2107,$2107,$2107
fd2d : 210e999f240e95..                      FDB     $210E,$999F,$240E,$959B,$200E,$2107,$2107,$2107
fd3d : 2107210721079d..                      FDB     $2107,$2107,$2107,$9DA3,$280E,$A0A6,$2B0E,$2202
fd4d : 28022d02280222..                      FDB     $2802,$2D02,$2802,$2202,$2802,$2D02,$2802,$2202
fd5d : 28022d0228022e..                      FDB     $2802,$2D02,$2802,$2E02,$2D28,$2180
                             
                             ;       FD69 = ADSR table for Berzerk and FF7A
                             
fd69 : effffedcba0000..      DFD69:          FDB     $EFFF,$FEDC,$BA00,$0000,$0000,$0000,$0000,$0000
                             
                             ;       FD79 = twang table for Berzerk and Scramble
                             
fd79 : 0001020100fffeff      DFD79:          FDB     $0001,$0201,$00FF,$FEFF
                             
                             ;       FD81 = music
                             
fd81 : fdc3feb6512450..      DFD81:          FDB     DFDC3,DFEB6,$5124,$5006,$5006,$500C,$5006,$5006
fd91 : 50045004500450..                      FDB     $5004,$5004,$5004,$5018,$5004,$5004,$5004,$500C
fda1 : 500c5024500650..                      FDB     $500C,$5024,$5006,$5006,$500C,$5006,$5006,$5004
fdb1 : 50045004501850..                      FDB     $5004,$5004,$5018,$5004,$5004,$5004,$500C,$5018
fdc1 : 2680                                  FDB     $2680
                             
                             ;       FDC3 = ADSR table for FD81 and FF8F
                             
fdc3 : fdba9876554433..      DFDC3:          FDB     $FDBA,$9876,$5544,$3322,$1100,$0000,$0000,$0000
                             
                             ;       FDD3 = music for Scramble
                             
fdd3 : fe28fd79981c10..      DFDD3:          FDB     DFE28,DFD79,$981C,$103F,$0898,$1C04,$981C,$0498
fde3 : 1c103f08981c04..                      FDB     $1C10,$3F08,$981C,$0498,$1C04,$981C,$0893,$1808
fdf3 : 981c089c1f0898..                      FDB     $981C,$089C,$1F08,$981C,$0893,$1808,$981C,$0893
fe03 : 1808981c089c1f..                      FDB     $1808,$981C,$089C,$1F08,$981C,$0893,$1808,$981C
fe13 : 08931808981c08..                      FDB     $0893,$1808,$981C,$089C,$1F08,$981C,$0893,$1808
fe23 : 9c1f301a80                            FCB     $9C,$1F,$30,$1A,$80
                             
                             ;       FE28 = ADSR table for Scramble, FF26, FF44, FF62
                             
fe28 : fffedcba987654..      DFE28:          FDB     $FFFE,$DCBA,$9876,$5432,$1000,$0000,$0000,$0000
                             
                             ;       FE38 = music for Solar Quest
                             
fe38 : fe66feb60c1811..      DFE38:          FDB     DFE66,DFEB6,$0C18,$1118,$0C18,$1118,$0C18,$1118
fe48 : 0c120c0611189d..                      FDB     $0C12,$0C06,$1118,$9D21,$189F,$2318,$A124,$18A3
fe58 : 26189fa4281807..                      FDB     $2618,$9FA4,$2818,$0712,$0706,$003C,$1880
                             
                             ;       FE66 = ADSR table for Solar Quest
                             
fe66 : deeffedcba0000..      DFE66:          FDB     $DEEF,$FEDC,$BA00,$0000,$0000,$0000,$0000,$0000
                             
                             ;       FE76 = music
                             
fe76 : feb2feb618061a..      DFE76:          FDB     DFEB2,DFEB6,$1806,$1A06,$1C0C,$180C,$1A24,$2318
fe86 : 170618061a0c17..                      FDB     $1706,$1806,$1A0C,$170C,$1824,$2418,$A428,$0CA3
fe96 : 260ca1240c9f23..                      FDB     $260C,$A124,$0C9F,$230C,$9D21,$189A,$1F18,$1706
fea6 : 18061a0c170c18..                      FDB     $1806,$1A0C,$170C,$1824,$2424,$1880
                             
                             ;       FEB2 = ADSR table for FE76
                             
feb2 : ffeeddcc              DFEB2:          FDB     $FFEE,$DDCC
                             
                             ;       FEB6 = "flat" twang table
                             
feb6 : 00000000000000..      DFEB6:          FDB     $0000,$0000,$0000,$0000,$0000,$0000,$0000,$0000
                             
                             ;       FEC6 = music
                             
fec6 : fee8feb6969a1d..      DFEC6:          FDB     DFEE8,DFEB6,$969A,$1D1E,$9195,$181E,$9498,$1B1E
fed6 : 8f941814160a8c..                      FDB     $8F94,$1814,$160A,$8C91,$1514,$160A,$9195,$1832
fee6 : 1880                                  FDB     $1880
                             
                             ;       FEE8 = ADSR table for FEC6
                             
fee8 : eeffffeeeeddcc..      DFEE8:          FDB     $EEFF,$FFEE,$EEDD,$CCBB,$AA99,$8888,$8888,$8888
                             
                             ;       FEF8 = music for Melody Master
                             
fef8 : ff16feb61c061f..      DFEF8:          FDB     DFF16,DFEB6,$1C06,$1F06,$1C06,$1806,$1A06,$1806
ff08 : 15061306180613..                      FDB     $1506,$1306,$1806,$1306,$1706,$181E,$1880
                             
                             ;       FF16 = ADSR table for FEF8
                             
ff16 : ffffeeeeddddcc..      DFF16:          FDB     $FFFF,$EEEE,$DDDD,$CCCC,$0000,$0000,$0000,$0000
                             
                             ;       FF26 = music
                             
ff26 : fe28feb6160f16..      DFF26:          FDB     DFE28,DFEB6,$160F,$1605,$1605,$1605,$1A0F,$160F
ff36 : 1d0f1d051d051d..                      FDB     $1D0F,$1D05,$1D05,$1D05,$210F,$1D32,$1D80
                             
                             ;       FF44 = music
                             
ff44 : fe28feb6160616..      DFF44:          FDB     DFE28,DFEB6,$1606,$1602,$1602,$1602,$1A06,$1606
ff54 : 1d061d021d021d..                      FDB     $1D06,$1D02,$1D02,$1D02,$2106,$1D32,$1180
                             
                             ;       FF62 = music
                             
ff62 : fe28feb61b0f16..      DFF62:          FDB     DFE28,DFEB6,$1B0F,$1605,$1605,$1605,$1730,$1605
ff72 : 1605160517301680                      FDB     $1605,$1605,$1730,$1680
                             
                             ;       FF7A = music
                             
ff7a : fd69feb6a02312..      DFF7A:          FDB     DFD69,DFEB6,$A023,$12A0,$230C,$9C20,$069E,$2112
ff8a : 9c20321380                            FCB     $9C,$20,$32,$13,$80
                             
                             ;       FF8F = music
                             
ff8f : fdc3feb6160416..      DFF8F:          FDB     DFDC3,DFEB6,$1604,$1604,$1604,$1604,$1A08,$1C80
                             
                             ;-----------------------------------------------------------------------;
                             ;       FF9F    Draw_Grid_VL                                            ;
                             ;                                                                       ;
                             ; This routine apparently will draw a vector list using a 16x16 grid,   ;
                             ; and occasionally using regular vector lists too.  This could possibly ;
                             ; be useful for drawing gridded things like a chess board and all of    ;
                             ; its pieces at the same time.                                          ;
                             ;                                                                       ;
                             ; The master vector list contains multiple sublists that start with     ;
                             ; a flag byte:                                                          ;
                             ;       Bit 7 = draw the next regular vector list (from X-reg) first    ;
                             ;       Bit 6 = this is the last sublist in the master vector list      ;
                             ;       Bits 5,4 = unused                                               ;
                             ;       Bits 3-0 = number of points in this sublist (1-16)              ;
                             ;                                                                       ;
                             ; The points are stored as a pair of nibbles:                           ;
                             ;       Bits 7-4 = Y coordinate (?)                                     ;
                             ;       Bits 3-0 = X coordinate (?)                                     ;
                             ;                                                                       ;
                             ; ENTRY DP = $D0                                                        ;
                             ;       X-reg points to regular vector lists                            ;
                             ;       Y-reg points to master vector list                              ;
                             ;                                                                       ;
                             ; EXIT: X-reg points to next byte after last regular vector list used   ;
                             ;       Y-reg points to next byte after end of master vector list       ;
                             ;                                                                       ;
                             ;       D-reg trashed                                                   ;
                             ;-----------------------------------------------------------------------;
                             
ff9f : a6a0             [ 6] Draw_Grid_VL:   LDA     ,Y+             ;Get flag byte
ffa1 : 2008             [ 3]                 BRA     LFFAB           ;Jump into loop
                             
ffa3 : bdf3be           [ 9] LFFA3:          JSR     Mov_Draw_VL_d   ;Draw a regular vector list
ffa6 : b6c880           [ 5]                 LDA     $C880           ;Clear vector list flag
ffa9 : 847f             [ 2]                 ANDA    #$7F
ffab : b7c880           [ 5] LFFAB:          STA     $C880           ;Save flag byte for vector count
ffae : 7ac880           [ 7] LFFAE:          DEC     $C880           ;Decrement vector count
ffb1 : a6a4             [ 4]                 LDA     ,Y              ;Get Y of next point
ffb3 : 47               [ 2]                 ASRA
ffb4 : 84f8             [ 2]                 ANDA    #$F8
ffb6 : e6a0             [ 6]                 LDB     ,Y+             ;Get X of next point
ffb8 : 58               [ 2]                 ASLB
ffb9 : 58               [ 2]                 ASLB
ffba : 58               [ 2]                 ASLB
ffbb : 58               [ 2]                 ASLB
ffbc : 57               [ 2]                 ASRB
ffbd : c4f8             [ 2]                 ANDB    #$F8
ffbf : 7dc880           [ 7]                 TST     $C880           ;Draw a regular vector list?
ffc2 : 2bdf             [ 3]                 BMI     LFFA3           ;Go back if so
ffc4 : bdf3df           [ 9]                 JSR     Draw_Line_d     ;Draw a line to the new point
ffc7 : b6c880           [ 5]                 LDA     $C880           ;Check vector counter
ffca : 850f             [ 2]                 BITA    #$0F
ffcc : 26e0             [ 3]                 BNE     LFFAE           ;Go back if more vectors to draw
ffce : 8520             [ 2]                 BITA    #$20            ;Check for end of list
ffd0 : 27cd             [ 3]                 BEQ     Draw_Grid_VL    ;Go back if more lists to draw
ffd2 : 39               [ 5]                 RTS
                             
ffd3 : 4b415252534f46..                      FCC     "KARRSOFT82LDMCBCJT82LDMCBCJ"
                             
ffee : 00000000                              FDB     0,0             ;Unused
                             
fff2 : cbf2                                  FDB     $CBF2           ;SWI3 vector
fff4 : cbf2                                  FDB     $CBF2           ;SWI2 vector
fff6 : cbf5                                  FDB     $CBF5           ;FIRQ vector
fff8 : cbf8                                  FDB     $CBF8           ;IRQ vector
fffa : cbfb                                  FDB     $CBFB           ;SWI vector
fffc : cbfb                                  FDB     $CBFB           ;NMI vector
fffe : f000                                  FDB     Start           ;Reset vector
                             
ffae =                                       END     Start
No errors in pass 2.
Wrote binary from address $f000 through $ffff.
Total size 4096 bytes.
Program start address is at $f000 (61440).
