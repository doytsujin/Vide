/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * SingleImagePanel.java
 *
 * Created on 05.05.2010, 12:37:37
 */

package de.malban.graphics;

import de.malban.gui.Scaler;
import de.malban.gui.TimingTriggerer;
import de.malban.gui.TriggerCallback;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Stroke;
import java.awt.image.BufferedImage;
import java.util.HashMap;
import javax.swing.SwingUtilities;

/**
 *
 * @author malban
 */
public class Single3dDisplayPanel extends SingleVectorPanel//javax.swing.JPanel 
{
    int inSetting = 0;
    boolean doRun = false;
    int index=-1;
    int animDelay = 25;
    boolean anim = true;
    boolean isOpaque = false;
    
    GFXVector xAxis = new GFXVector();
    GFXVector yAxis = new GFXVector();
    GFXVector zAxis = new GFXVector();

    GFXVectorAnimation animation = new GFXVectorAnimation();
    boolean axisShown = false;
    boolean repaint = true;
    public void setRepaint(boolean rp)
    {
        repaint = rp;
    }
    
    public GFXVectorAnimation getAnimation()
    {
        return animation;
    }
    public void setAnimation(GFXVectorAnimation a)
    {
        animation = a;
        index = 0;
        if (animation.size()>0)
        {
            setForegroundVectorList(animation.get(0));
        }
        else
        {
            setForegroundVectorList(new GFXVectorList());
        }
    }
    
    public void setAxisShown (boolean s)
    {
        axisShown = s;
        sharedRepaint();
    }
            
    public Single3dDisplayPanel() {
        initComponents();
        xAxis.start.x(-2000);
        xAxis.end.x(+2000);
        yAxis.start.y(-2000);
        yAxis.end.y(+2000);
        zAxis.start.z(-2000);
        zAxis.end.z(+2000);
    }
    public void deinit()
    {
        setVisible(false);
    }
    public void setDelay(int d)
    {
        boolean oldRepaint = noRepaint;
        noRepaint = true;
        boolean iv = isVisible();
        setVisible(false);        
        animDelay=d;
        if (iv)
            setVisible(true);        
        noRepaint = oldRepaint;
        repaint();
    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 235, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 241, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    TriggerCallback tt; 
    boolean started = false;
    @Override public synchronized void setVisible(boolean b)
    {
        boolean oldVisibility = isVisible();
        super.setVisible(b);
        if (oldVisibility == b) return;

        if (animDelay == -1)
        {
            index = 0;
            return;
        }

        final TimingTriggerer timer = TimingTriggerer.getTimer();
        if (b)
        {
            started = true;
            timer.setResolution(10); //100*1ms resoltuion is 0,1seconds
            if (tt != null)
            {
                timer.removeTrigger(tt);
                tt = null;                
            }

            tt = new TriggerCallback()
            {
                @Override
                public synchronized void doIt(int state, Object o)
                {
                    if (!isVisible()) return;
                    
                    if (animDelay != -1)
                    {
                        
                        if (!animation.list.isEmpty())
                        {
                            index = (index + 1) % animation.list.size();
                            setForegroundVectorList(animation.get(index));
                        }
                        else
                            index = -1;
                        

                        if (started)
                            timer.addTrigger(tt, animDelay, 0, null);
                    }
                    SwingUtilities.invokeLater(new Runnable()
                    {
                        public void run()
                        {
                            repaint();
                        }
                    } );
                }
            };
            timer.addTrigger(tt, animDelay, 0, null);
        }
        
        else
        {
            timer.removeTrigger(tt);
            tt = null;
            started = false;
        }
    }    
    
    int axisXAngle = 38;
    int axisYAngle = 49;
    int axisZAngle = 31;
    public void setAxisAngleX(int value)
    {
        axisXAngle = value;
        sharedRepaint();
    }
    public void setAxisAngleY(int value)
    {
        axisYAngle = value;
        sharedRepaint();
    }
    public void setAxisAngleZ(int value)
    {
        axisZAngle = value;
        sharedRepaint();
    }
    
    int angleX = 0;
    int angleY = 0;
    int angleZ = 0;
    int transX = 0;
    int transY = 0;
    int transZ = 0;
    double scale = 1.0;
    public void setAngleX(int value)
    {
        angleX = value;
        sharedRepaint();
    }
    public void setAngleY(int value)
    {
        angleY = value;
        sharedRepaint();
    }
    public void setAngleZ(int value)
    {
        angleZ = value;
        sharedRepaint();
    }
    
    public void setTranslocationX(int x)
    {
        transX = x;
        sharedRepaint();
    }
    public void setTranslocationY(int y)
    {
        transY = y;
        sharedRepaint();
    }
    public void setTranslocationZ(int z)
    {
        transZ = z;
        sharedRepaint();
    }
    public void setScale(double s)
    {
        scale = s;
        updateAndRepaint();
    }
    public double getScale()
    {
        return scale;
    }
    public GFXVectorList getDisplayVectorList()
    {
        return lastDisplayList;
    }
    GFXVectorList lastDisplayList = new GFXVectorList();
    @Override public void paintComponent(Graphics g)
    {
//        super.paintComponent(g);
        if (bufferUsed == -1) return;
        g.drawImage(paintBufferImage[bufferUsed], 0, 0, null);
    }

    @Override
    public void sharedRepaint() {
        if (singleRepaint)
        {
            return;
        }

        updateAndRepaint();
        super.sharedRepaint(); //To change body of generated methods, choose Tools | Templates.

    }


    
    
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    boolean singleRepaint = false;
    public void setSingleRepaint(boolean b)
    {
        singleRepaint = b;
    }
    boolean oldSingleRepaint = false;
    public void disableSingleRepaint()
    {
        oldSingleRepaint = singleRepaint;
        singleRepaint = false;
    }
    public void enableSingleRepaint()
    {
        singleRepaint = oldSingleRepaint;
    }
    
    BufferedImage[] paintBufferImage = new BufferedImage[2];
    int bufferUsed = -1;
    synchronized void updateAndRepaint()
    {
        if (noRepaint) return;
        int width = getWidth();
        int height = getHeight();
        if (width == 0) return;
        if (height == 0) return;
        int nextBuffer = (bufferUsed +1)%2;
        paintBufferImage[nextBuffer] = de.malban.util.UtilityImage.getNewImage(width, height);

        if ( paintBufferImage[nextBuffer] == null) return;

        if (!repaint) 
        {
            bufferUsed = nextBuffer;
            return;
        }

        Graphics2D g = paintBufferImage[nextBuffer].createGraphics();
    
        synchronized (vars.foregroundVectors.list)
        {
            g.setColor(Color.BLACK);
            g.fillRect(0, 0, getWidth(), getHeight());
            if (!repaint) return;
            x0Offset = getWidth()/2;
            y0Offset = getHeight()/2;

            if (vars.drawByteFrame)
            {
                g.setColor(vars.FRAME_COLOR);
                int x0 = -128;
                int x1 = 127;
                int y0 = -128;
                int y1 = 127;


                x0 = Scaler.scaleDoubleToInt(x0, scale);            
                y0 = -Scaler.scaleDoubleToInt(y0, scale);            
                x1 = Scaler.scaleDoubleToInt(x1, scale);            
                y1 = -Scaler.scaleDoubleToInt(y1, scale);            

                x0 = x0Offset + x0;
                y0 = y0Offset + y0;
                x1 = x0Offset + x1;
                y1 = y0Offset + y1;

                g.drawLine(x0, y0, x1, y0);
                g.drawLine(x0, y0, x0, y1);
                g.drawLine(x1, y0, x1, y1);
                g.drawLine(x0, y1, x1, y1);

            }            

            // save original color
            Color c = g.getColor();


            Matrix4x4 trans = Matrix4x4.getTranslocation(transX, transY, transZ);
            Matrix4x4 rotx = Matrix4x4.getRotationX(Math.toRadians(angleX));
            Matrix4x4 roty = Matrix4x4.getRotationY(Math.toRadians(angleY));
            Matrix4x4 rotz = Matrix4x4.getRotationZ(Math.toRadians(angleZ));
            Matrix4x4 rotax = Matrix4x4.getRotationX(Math.toRadians(axisXAngle));
            Matrix4x4 rotay = Matrix4x4.getRotationY(Math.toRadians(axisYAngle));
            Matrix4x4 rotaz = Matrix4x4.getRotationZ(Math.toRadians(axisZAngle));
            if (axisShown)
            {
                GFXVector ax = rotax.multiply(xAxis);
                ax = rotay.multiply(ax);
                ax = rotaz.multiply(ax);
                GFXVector ay = rotax.multiply(yAxis);
                ay = rotay.multiply(ay);
                ay = rotaz.multiply(ay);
                GFXVector az = rotax.multiply(zAxis);
                az = rotay.multiply(az);
                az = rotaz.multiply(az);

                g.setColor(Color.BLUE);
                g.drawLine((int) ax.start.x()+x0Offset, (int) -ax.start.y()+y0Offset,  (int) ax.end.x()+x0Offset,  (int)- ax.end.y()+y0Offset);
                g.setColor(Color.GREEN);
                g.drawLine((int) ay.start.x()+x0Offset, (int) -ay.start.y()+y0Offset,  (int) ay.end.x()+x0Offset,  (int)- ay.end.y()+y0Offset);
                g.setColor(Color.MAGENTA);
                g.drawLine((int) az.start.x()+x0Offset, (int) -az.start.y()+y0Offset,  (int) az.end.x()+x0Offset,  (int)- az.end.y()+y0Offset);
            }        


            lastDisplayList = vars.foregroundVectors.clone();
            int count = 0;
           // for (GFXVector v: vars.foregroundVectors.list)
            HashMap<Vertex, Vertex> noDouble = new HashMap<Vertex, Vertex>();
            for (GFXVector v: lastDisplayList.list)
            {
                double x0,x1,y0,y1, z0, z1;
                // vectrex y coordinate has opposite "direction"

                // transformation
                Vertex p1 = v.start;
                Vertex p2 = v.end;

                if (noDouble.get(p1) == null)
                {
                    noDouble.put(p1,p1);
                    p1 = trans.multiply(p1);
                    p1 = rotx.multiply(p1);
                    p1 = roty.multiply(p1);
                    p1 = rotz.multiply(p1);
                    p1 = rotax.multiply(p1);
                    p1 = rotay.multiply(p1);
                    p1 = rotaz.multiply(p1);
                    p1.coords[0] = Math.round(p1.coords[0]);
                    p1.coords[1] = Math.round(p1.coords[1]);
                    p1.coords[2] = Math.round(p1.coords[2]);
                    v.start.set(p1);
                }
                if (noDouble.get(p2) == null)
                {
                    noDouble.put(p2,p2);
                    p2 = trans.multiply(p2);
                    p2 = rotx.multiply(p2);
                    p2 = roty.multiply(p2);
                    p2 = rotz.multiply(p2);
                    p2 = rotax.multiply(p2);
                    p2 = rotay.multiply(p2);
                    p2 = rotaz.multiply(p2);
                    p2.coords[0] = Math.round(p2.coords[0]);
                    p2.coords[1] = Math.round(p2.coords[1]);
                    p2.coords[2] = Math.round(p2.coords[2]);
                    v.end.set(p2);
                }


                
                
                
      //          lastDisplayList.list.get(count).start = p1;
      //          lastDisplayList.list.get(count).end = p2;


                x0 = Scaler.scaleDoubleToInt(p1.x(), scale);            
                y0 = -Scaler.scaleDoubleToInt(p1.y(), scale);            
                x1 = Scaler.scaleDoubleToInt(p2.x(), scale);            
                y1 = -Scaler.scaleDoubleToInt(p2.y(), scale);            

                double x0v = x0Offset + x0;
                double y0v = y0Offset + y0;
                double x1v = x0Offset + x1;
                double y1v = y0Offset + y1;

                if ((v.a>255) || (v.a<0)) v.a = 127;
                g.setColor(new Color(v.r, v.g, v.b, v.a));
                // g.setColor(Color.white);
                if (v.highlight)
                {
                    g.setColor(Color.YELLOW);
                }
                if (v.selected)
                {
                    g.setColor(Color.red);
                }


                // DRAW the Vector
                if (v.pattern != 255)
                {
                    float[] pattern = getPattern(v);
                    Stroke dashed = new BasicStroke(0, BasicStroke.CAP_BUTT, BasicStroke.JOIN_BEVEL, 1, pattern, 0);
                    Graphics2D g2 = (Graphics2D) g;
                    Stroke saveStroke = g2.getStroke();
                    g2.setStroke(dashed);
                    g2.drawLine((int) x0v,  (int)y0v,  (int)x1v,  (int)y1v);
                    g2.setStroke(saveStroke);
                }
                else
                {
                    g.drawLine((int) x0v,  (int)y0v,  (int)x1v,  (int)y1v);
                }

                // DRAW endpoints
                if (v.start.highlight)
                {
                    g.setColor(Color.YELLOW);
                    g.fillRect((int) x0v, (int)y0v, 3, 3);
                }
                if (v.end.highlight)
                {
                    g.setColor(Color.YELLOW);
                    g.fillRect((int) x1v, (int)y1v, 3, 3);
                }
                if (v.start.selected)
                {
                    g.setColor(Color.red);
                    g.fillRect((int) x0v, (int)y0v, 3, 3);
                }
                if (v.end.selected)
                {
                    g.setColor(Color.red);
                    g.fillRect((int) x1v, (int)y1v, 3, 3);
                }
                count++;
            } // Foreground Vectors done

            if (!dumpMode)
                lastDisplayList.setRelativeWherePossible();

            // restore original color
            g.setColor(c);
        }
        bufferUsed = nextBuffer;
        super.repaint();
    }
    public void repaint() 
    {
        updateAndRepaint();
    }
    boolean noRepaint = false;
    public void suspendRepaint()
    {
        noRepaint = true;
    }
    public void continueRepaint()
    {
        noRepaint = false;
        repaint();
    }
    
    boolean dumpMode = false;
    public void setDumpMode(boolean dp)
    {
        dumpMode = dp;
    }
}
