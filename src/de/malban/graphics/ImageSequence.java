/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package de.malban.graphics;

import java.awt.image.BufferedImage;
import java.util.*;

/**
 * This class is a wrapper to the generated class ImageSequenceData.
 * It provides additional functionality.
 * 
 * In general it hold thus all data regarding a sequence of images.
 * 
 * This class holds the DATA not the images itself. It does not provide painting methods or the like.
 * "Paintable" image sequences can be generated by the class "BaseImageData".
 *
 * @author malban
 */
public class ImageSequence {

    protected ImageSequenceData mData = new ImageSequenceData();
    public ImageSequence()
    {

    }

    public int getDelay()
    {
        return mData.mDelay;
    }

    public ImageSequence(ImageSequenceData data)
    {
        if (data == null) data = new ImageSequenceData();
        mData = data;
    }
    public ImageSequence(ImageSequenceData data, Vector <BaseImageData> mbid)
    {
        if (data == null) data = new ImageSequenceData();
        mData = data;
        mBIData = mbid;
    }
    public ImageSequence(Vector <BaseImageData> mbid)
    {
        mData = new ImageSequenceData();
        BaseImageData.fromBase(mData, mbid);
        mBIData = mbid;
    }
    
    public static ImageSequence createImageSequence(String filename, String _class, String name)
    {
        return createImageSequence(filename, name);
    }

    public static ImageSequence createImageSequence(String filename, String name)
    {
        ImageSequenceDataPool dataPool = new ImageSequenceDataPool(filename);
        ImageSequenceData data = dataPool.getHashMap().get(name);
        return new ImageSequence(data);
    }

    public static Vector<String> getClasses(String filename)
    {
        ImageSequenceDataPool dataPool = new ImageSequenceDataPool(filename);
        HashMap<String,String> map = dataPool.getKlassenHashMap();

        Set entries = map.entrySet();
        Iterator it = entries.iterator();
        Vector<String> classes = new Vector<String>();
        while (it.hasNext())
        {
            Map.Entry entry = (Map.Entry) it.next();
            String _class = (String) entry.getValue();
            classes.add(_class);
        }
        Collections.sort(classes, new Comparator<String>()
        {
            @Override
           public final int compare(String s1, String s2)
           {
              return s1.compareTo(s2);
           }
        });

        return classes;
    }

    public static Vector<String> getNames(String filename, String _class)
    {
        ImageSequenceDataPool dataPool = new ImageSequenceDataPool(filename);
        HashMap<String,ImageSequenceData> map = dataPool.getMapForKlasse(_class);

        Set entries = map.entrySet();
        Iterator it = entries.iterator();
        Vector<String> names = new Vector<String>();
        while (it.hasNext())
        {
            Map.Entry entry = (Map.Entry) it.next();
            ImageSequenceData value = (ImageSequenceData) entry.getValue();
            names.add(value.mName);
        }
        Collections.sort(names, new Comparator<String>()
        {
            @Override
           public final int compare(String s1, String s2)
           {
              return s1.compareTo(s2);
           }
        });

        return names;
    }

    public static Vector<String> getAllNames(String filename)
    {
        ImageSequenceDataPool dataPool = new ImageSequenceDataPool(filename);
        HashMap<String,ImageSequenceData> map = dataPool.getHashMap();

        Set entries = map.entrySet();
        Iterator it = entries.iterator();
        Vector<String> names = new Vector<String>();
        while (it.hasNext())
        {
            Map.Entry entry = (Map.Entry) it.next();
            ImageSequenceData value = (ImageSequenceData) entry.getValue();
            names.add(value.mName);
        }
        Collections.sort(names, new Comparator<String>()
        {
            @Override
           public final int compare(String s1, String s2)
           {
              return s1.compareTo(s2);
           }
        });

        return names;
    }

    Vector <BaseImageData> mBIData=null;
    public Vector <BaseImageData> getBaseImageData()
    {
        if (mBIData == null)
            mBIData = BaseImageData.toBase(mData); 
        return mBIData;
    }

    public Vector<BufferedImage> getImageVector()
    {
        Vector <BaseImageData> bdata = getBaseImageData();
        Vector<BufferedImage> images = new Vector<BufferedImage>();
        for (int i = 0; i < bdata.size(); i++)
        {
            BaseImageData baseImageData = bdata.elementAt(i);
            images.addElement(baseImageData.image);
        }

        return images;
    }
    
    public BufferedImage getImageAt(int i)
    {
        return getBaseImageData().elementAt(i).image;
    }
    
    public int getImageCount()
    {
        return getBaseImageData().size();
    }
}
