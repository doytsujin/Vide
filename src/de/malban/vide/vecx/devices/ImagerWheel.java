/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package de.malban.vide.vecx.devices;

import static de.malban.vide.vecx.devices.Imager3dDevice.photoReceiverAngleStart;
import java.awt.BasicStroke;
import java.awt.Color;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.Point;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.io.Serializable;

/**
 *
 * @author malban
 */
public class ImagerWheel extends javax.swing.JPanel 
{
    Point center = new Point();
    int outerRadius = 0;
    int innerRadius = 0;
    
    public static WheelData NARROW_ESCAPE;
    WheelData currentWheel = NARROW_ESCAPE;
    static
    {
        
        NARROW_ESCAPE = new WheelData();
        NARROW_ESCAPE.id = 1;
        NARROW_ESCAPE.name="Narrow Escape";
        NARROW_ESCAPE.startAngle = new double[4];
        NARROW_ESCAPE.colors = new Color[4];

        // black
        NARROW_ESCAPE.startAngle[0] = 0;
        NARROW_ESCAPE.colors[0] = new Color(0,0,0,255);

        // red
        NARROW_ESCAPE.startAngle[1] = 180;
        NARROW_ESCAPE.colors[1] = new Color(0,0,255,100);

        // green
        NARROW_ESCAPE.startAngle[2] = 240;
        NARROW_ESCAPE.colors[2] = new Color(0,255,0,100);

        // blue
        NARROW_ESCAPE.startAngle[3] = 304;
        NARROW_ESCAPE.colors[3] = new Color(255,0,0,100);
        
        
        
        
        NARROW_ESCAPE.indexAngle = 254; // guessing
    }
    
    double one_millimenter = 0;             // conversion factor in relation to panel size
    BufferedImage zeroAngleImage1 = null;   // image of color
    BufferedImage zeroAngleImage2 = null;   // image of index hole, these two images will be rotated!
    
    /**
     * Creates new form ImagerWheel
     */
    public ImagerWheel() {
        initComponents();
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                formComponentResized(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents

    private void formComponentResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentResized
        
        // upon resize, set the center 
        // and place a "square" in the middle, which holds the wheel image
        int w = getWidth();
        int h = getHeight();
        center = new Point(w/2,h/2);
        if (w<h) outerRadius = w;
        else outerRadius = h;
        outerRadius -=8;
        one_millimenter = outerRadius;
        outerRadius = outerRadius/2;
        one_millimenter = one_millimenter/WHEEL_WIDTH;
        
        innerRadius = scale(CENTER_WIDTH/2);
        
        // create the image
        createCurrentWheel();
        repaint();
        
    }//GEN-LAST:event_formComponentResized

    public void repaintWheel()
    {
        formComponentResized(null);
    }
    // converts one milimeter to current panel scale
    int scale(double valueInMilimeter)
    {
        return (int) (one_millimenter*valueInMilimeter);
    }
    
    void createCurrentWheel()
    {
        if (outerRadius == 0)
        {
            zeroAngleImage1 = null;
            return;
        }
        // image of colors
        zeroAngleImage1 = de.malban.util.UtilityImage.getNewImage(outerRadius*2,outerRadius*2);
        zeroAngleImage2 = de.malban.util.UtilityImage.getNewImage(outerRadius*2,outerRadius*2);
        
        // create wheel color image
        Graphics2D g2 = zeroAngleImage1.createGraphics();
        g2.setBackground(new Color(0,0,0,0));
        g2.clearRect(0,0, outerRadius*2,outerRadius*2);
        // arc starts at 15:00
        // positive values rotate anti clockwise
        
        // a) we want to start at 18:00
        // b) drawing should be clock wise
        
        int mod = currentWheel.startAngle.length;
        for (int i=0; i<currentWheel.startAngle.length;i++)
        {
            g2.setColor(currentWheel.colors[i]);
            int startAngle = (int) currentWheel.startAngle[i];
            startAngle += 90; // start at 18:00
            int angleWidth;
            if (i+1 >= currentWheel.startAngle.length)
                angleWidth = (int) ((currentWheel.startAngle[(i+1)%mod]+360 - currentWheel.startAngle[i]));
            else
                angleWidth = (int) ((currentWheel.startAngle[i+1] - currentWheel.startAngle[i]));
            g2.fillArc(0,0, outerRadius*2, outerRadius*2, -startAngle, -angleWidth);
        }
        
        // create index whole image at correct position in relation to wheel colors
        g2 = zeroAngleImage2.createGraphics();
        g2.setBackground(new Color(0,0,0,0));
        g2.clearRect(0,0, outerRadius*2,outerRadius*2);

        // index, draw at 0 than rotate to correct position
        g2.setColor(new Color(0,0,0,255 ));
        g2.rotate(Math.toRadians(currentWheel.indexAngle-3/* width of whole*/),outerRadius, outerRadius);
        g2.fillOval(outerRadius-scale(INDEX_WIDTH/2.0), outerRadius+scale(INDEX_FROM_CENTER), scale(INDEX_WIDTH), scale(INDEX_WIDTH));
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables

    @Override public void paintComponent(Graphics g)
    {
        Graphics2D g2 = (Graphics2D) g;

        // rember 0 rotation transformation
        AffineTransform old = g2.getTransform();

        // rotate the drawn image by current angle
        g2.rotate(Math.toRadians(currentAngle),center.x, center.y);
        g2.drawImage(zeroAngleImage1, center.x-outerRadius, center.y-outerRadius, null);
        // reset to 0 angle
        g2.setTransform(old);
        
        // draw outer wheel border
        g2.setStroke(new BasicStroke(2));
        g2.setColor(new Color(255,255,255,255 ));
        g2.drawOval(center.x-outerRadius, center.y-outerRadius, outerRadius*2, outerRadius*2);
        
        // draw white plastic in the middle
        g2.setColor(new Color(255,255,255,255 ));
        g2.fillOval(center.x-innerRadius, center.y-innerRadius, innerRadius*2, innerRadius*2);

        // draw both eye holes
        g2.setStroke(new BasicStroke(1));
        g2.setColor(new Color(255,255,255,100 ));
        g2.drawLine(center.x, center.y, center.x, center.y+outerRadius);
        g2.fillRoundRect(center.x-scale(EYE_DISTANCE/2)-scale(EYE_WIDTH), center.y-scale(EYE_HEIGHT/2), scale(EYE_WIDTH), scale(EYE_HEIGHT), scale(EYE_HEIGHT), scale(EYE_HEIGHT));
        g2.fillRoundRect(center.x+scale(EYE_DISTANCE/2), center.y-scale(EYE_HEIGHT/2), scale(EYE_WIDTH), scale(EYE_HEIGHT), scale(EYE_HEIGHT), scale(EYE_HEIGHT));

        // rotate the next drawing
        g2.rotate(Math.toRadians(currentAngle),center.x, center.y);
        // which is the index whole again (must be painted after the white inner plastic thingy)
        g2.drawImage(zeroAngleImage2, center.x-outerRadius, center.y-outerRadius, null);
        g2.setTransform(old);
        
        // index, draw LED
        g2.setColor(new Color(255,0,0,200 ));
        g2.rotate(Math.toRadians(photoReceiverAngleStart-3),center.x, center.y); // -3 because of drawing
        g2.fillOval(center.x-scale(INDEX_WIDTH/2.0), center.y+scale(INDEX_FROM_CENTER), scale(INDEX_WIDTH), scale(INDEX_WIDTH));
        g2.setTransform(old);
        
    }
    
    public void setWheel(WheelData wheel)
    {
        currentWheel = wheel;
        formComponentResized(null);
        repaint();
    }
    
    public void setAngle(double a)
    {
        currentAngle = a;
        repaint();
    }
    double currentAngle = 0;
    public static double WHEEL_WIDTH = 99;
    public static double CENTER_WIDTH = 39;
    public static double EYE_WIDTH = 24;
    public static double EYE_HEIGHT = 8;
    public static double EYE_DISTANCE = 44;

    // attention!
    // the whole size DOES matter
    // since the index hole triggers an interrupt from low to high
    // while handling the interrupt
    // a resetRef0 is called
    // which  resets VIA PCR to interrupt from high to low
    // thus at the "end" of the index another interrupt is called
    // if that happens at the wrong moment
    // the game you play will crash or behave weirdly!
    
    // actually...
    // things changed, I added an interrupt length
    // which should simulate
    // at what range the phototransitor reacts on the LED
    // that range is considerably smaller!
    // I don't know how small - but I use a small
    // value that just an interrupt is triggerd - nothing else
    // see Imager3dDevice
    
    public static double INDEX_WIDTH = 3.3274;
    public static double INDEX_FROM_CENTER = 16;
}
// everything from the sandpoint of a wearer of the goggles looking "thru" them
// rotation than is anti clockwise

// inner circle = 39 mm
// outer circle = 95 mm

// eye height 8mm
// eye width 24mm
// eye distance 44mm

// index size: 3mm


// ATTENTION
// if goggle spin to fast, at least narrow escape crashes
// since DP is somewhere set to $c8
// and is not set anywhere in the interrupt routine - therefor all
// writes go to dp $c8 instead of $d0, so the VIA clear interrupt flag
// thus the program is caught in an endless interrupt loop!
// this happens by speed of about 30 Hz
// manually setting "set dp =$d0" in dissi salvages the situation...