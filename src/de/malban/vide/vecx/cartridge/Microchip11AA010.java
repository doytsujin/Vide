/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package de.malban.vide.vecx.cartridge;

import de.malban.config.Configuration;
import de.malban.gui.CSAMainFrame;
import de.malban.gui.panels.LogPanel;
import de.malban.vide.dissy.DASM6809;
import java.io.Serializable;

// writes to data array
// are done directly!
// this means, if a write command is not finished by a nomak, the data is 
// still in the array!
// this is not exact, data should only be set when a nomak is issued!


/**
 *
 * @author malban

* Emulated at the moment are only features which are used by VectorPilot
* This means the commands:
* CRRD
* ERAL
* SETAL
* 
* Are not emulated, since to my knowledge they are not used, and I have no example
* or test programs for them.
* If in the future they are needed - I will implement them, if I still can figure out how
* the below emulation works - it will be easy :-)
*
* 
All instructions,
addresses, and data are transferred MSb first, LSb
last.
* 
* Standby Pulse
When the master has control of SCIO, a standby pulse
can be generated by holding SCIO high for TSTBY. At
this time, the 11XX will reset and return to Standby
mode. Subsequently, a high-to-low transition on SCIO
(the first low pulse of the header) will return the device
to the active state.
Once a command is terminated
* 
Start Data Transfer
All operations must be preceded by a start header. The
start header consists of holding SCIO low for a period
of THDR, followed by transmitting an 8-bit ‘01010101’
code. This code is used to synchronize the slave’s
internal clock period with the master’s clock period, so
accurate timing is very important.

* 
* Acknowledge
An Acknowledge routine occurs after each byte is
transmitted, including the start header. This routine
consists of two bits. The first bit is transmitted by the
master, and the second bit is transmitted by the slave.
The Master Acknowledge, or MAK, is signified by transmitting
a ‘1’, and informs the slave that the current
operation is to be continued. Conversely, a Not
Acknowledge, or NoMAK, is signified by transmitting a
‘0’, and is used to end the current operation (and initiate
the write cycle for write operations).
* 
* The slave Acknowledge, or SAK, is also signified by
transmitting a ‘1’, and confirms proper communication.
However, unlike the NoMAK, the NoSAK is signified by
the lack of a middle edge during the bit period.
* 
* If a NoSAK is received from the slave after any byte
(except the start header), an error has occurred. The
master should then perform a standby pulse and begin
the desired command again.
* 
* Device address is (in our case): 1010 0000 = $a0
* 
* 
* DEVICE COMMANDS
After the device address byte, a command byte must
be sent by the master to indicate the type of operation
to be performed.
* 
* Instruction Name Instruction Code Hex Code Description
                READ 0000 0011 0x03 Read data from memory array beginning at specified address
                CRRD 0000 0110 0x06 Read data from current location in memory array
                WRITE 0110 1100 0x6C Write data to memory array beginning at specified address
                WREN 1001 0110 0x96 Set the write enable latch (enable write operations)
                WRDI 1001 0001 0x91 Reset the write enable latch (disable write operations)
                RDSR 0000 0101 0x05 Read STATUS register
                WRSR 0110 1110 0x6E Write STATUS register
                ERAL 0110 1101 0x6D Write ‘0x00’ to entire array
                SETAL 0110 0111 0x67 Write ‘0xFF’ to entire array
* 
* 
* 
* bit 0 = going from high to low
* bit 1 = going from low to high
* 
* 
* 
*/
public class Microchip11AA010  implements Serializable{
    
    transient LogPanel log = (LogPanel) Configuration.getConfiguration().getDebugEntity();
    public static final int MAX_DATA_LEN = 128; // 1K of bits;
    
    public transient Cartridge cart;
    
    public static class EpromData implements Serializable
    {
        byte[] data = new byte[MAX_DATA_LEN];
    }
    EpromData epromData = new EpromData();
    public byte[] getData()
    {
        return epromData.data;
    }
    
    public void init()
    {
        if (log == null)
            log = (LogPanel) Configuration.getConfiguration().getDebugEntity();
    }
    
    // low level states
    public transient static final int LL_NONE = 0;
    public transient static final int LL_STANDBY = 1;
    public transient static final int LL_ACTIVE = 2;
    public transient static final int LL_START_HEADER = 3;
    public transient static final int LL_IN_HEADER_0 = 4;
    public transient static final int LL_IN_HEADER_1 = 5;
    public transient static final int LL_IN_HEADER_FINISH = 6;
    public transient static final int LL_DELAY = 7;
    
    String[] ll_names = {
        "NONE",
        "STANDBY",
        "ACTIVE",
        "START_HEADER",
        "IN_HEADER_0",
        "IN_HEADER_1",
        "IN_HEADER_FINISH",
        "DELAY"
    };
    
    
    public transient static final int maxFreqCycles = 15; // 100 kHz
    public transient static final int minFreqCycles = 150; // 10 kHz
    
    public transient static final int standByPulseTimerCycles = 900; // 600 micro seconds
    
    // header must be started by low, 5 micro seconds is not emulated
    public transient static final int startHeaderLowPulseCycles = 8; // 5 micro seconds
    public transient static final int startHeaderSetupCycles = 15; // 10 micro seconds
    
    //Write, WRSR commands ERAL, SETAL commands
    public transient static final int writeCycleTimeByteCycles = (75*100); //  5 milli seconds
    public transient static final int writeCycleTimePageCycles = (15*1000); // 10 milli seconds
    
    
    public transient static final int COMMAND_NONE = 0; 
    public transient static final int COMMAND_READ = 0x03; 
    public transient static final int COMMAND_CRRD = 0x06; 
    public transient static final int COMMAND_WRITE = 0x6c; 
    
    public transient static final int COMMAND_WREN = 0x96; 
    public transient static final int COMMAND_WRDI = 0x91; 
    
    public transient static final int COMMAND_RDSR = 0x05; 
    public transient static final int COMMAND_WRSR = 0x6e; 
    public transient static final int COMMAND_ERAL = 0x6d; 
    public transient static final int COMMAND_SETAL = 0x67; 
    int currentCommand = COMMAND_NONE;
    
    // medium level states
    public transient static final int ML_NONE = 0; 
    public transient static final int ML_MAK = 1; 
    public transient static final int ML_SAK = 2; 
    public transient static final int ML_NOMAK = 3; 
    public transient static final int ML_NOSAK = 4; 
    public transient static final int ML_DEV_ADDRESS = 5; 
    public transient static final int ML_DELAY_TSS = 6; 
    public transient static final int ML_DELAY_THDR = 7; 
    public transient static final int ML_COMMAND = 8; 
    public transient static final int ML_ADDRESS_HI = 9; 
    public transient static final int ML_ADDRESS_LO = 10; 
    public transient static final int ML_BYTE_FROM_MC = 11; 
    public transient static final int ML_BYTE_TO_MC = 12; 
    public transient static final int ML_DELAY_BYTE_WRITE = 13; 
    public transient static final int ML_DELAY_PAGE_WRITE = 14; 
    public transient static final int ML_WAIT_FOR_HEADER = 15; 
    public transient static final int ML_MAK_OR_NO_MAK = 16; 
  

    String[] ml_names = {
        "NONE",
        "MAK",
        "SAK",
        "NOMAK",
        "NOSAK",
        "DEV_ADDRESS",
        "DELAY_TSS",
        "DELAY_THDR",
        "COMMAND",
        "ADDRESS_HI",
        "ADDRESS_LO",
        "BYTE_FROM_MC",
        "BYTE_TO_MC",
        "DELAY_BYTE_WRITE",
        "DELAY_PAGE_WRITE",
        "WAIT_FOR_HEADER",
        "MAK_OR_NO_MAK"
    };
    
    // high level states
    public transient static final int HL_NONE = 0;
    public transient static final int HL_HEADER_FINISH = 1; 
    public transient static final int HL_COMMAND = 2; 
    public transient static final int HL_ADDRESS = 3; 
    public transient static final int HL_BYTE_FROM_MC = 4; 
    public transient static final int HL_BYTE_TO_MC_NOMAK = 5; 
    public transient static final int HL_BYTE_DELAY = 6; 
    public transient static final int HL_PAGE_DELAY = 7; 
    public transient static final int HL_WAIT_FOR_HEADER = 8; 
    public transient static final int HL_BYTE_TO_MC = 9; 
    public transient static final int HL_LAST = 10; 
    String[] hl_names = {
        "NONE",
        "HEADER_FINISH",
        "COMMAND",
        "ADDRESS",
        "BYTE_FROM_MC",
        "BYTE_TO_MC_NOMAK",
        "BYTE_DELAY",
        "PAGE_DELAY",
        "WAIT_FOR_HEADER",
        "BYTE_TO_MC"
    };

    
    static transient int[][] high_level_stateSequence;
    static transient final int[] hl_none={ML_NONE};
    static transient final int[] hl_header_finish={ML_MAK, ML_NOSAK, ML_DEV_ADDRESS, ML_MAK, ML_SAK};
    static transient final int[] hl_command={ML_COMMAND, ML_MAK_OR_NO_MAK, ML_SAK};
    static transient final int[] hl_address={ML_ADDRESS_HI, ML_MAK, ML_SAK, ML_ADDRESS_LO, ML_MAK, ML_SAK};
    static transient final int[] hl_byte_from_mc={ML_BYTE_FROM_MC, ML_MAK_OR_NO_MAK, ML_SAK}; 
    static transient final int[] hl_byte_to_mc_nomak={ML_BYTE_TO_MC, ML_NOMAK, ML_SAK};
    static transient final int[] hl_byte_to_mc={ML_BYTE_TO_MC, ML_MAK_OR_NO_MAK, ML_SAK};
    static transient final int[] hl_byte_delay={ML_DELAY_BYTE_WRITE};
    static transient final int[] hl_page_delay={ML_DELAY_PAGE_WRITE};
    static transient final int[] hl_wait_for_header={ML_DELAY_TSS, ML_DELAY_THDR, ML_WAIT_FOR_HEADER };
    static
    {
        high_level_stateSequence = new int[HL_LAST][];
        high_level_stateSequence[HL_NONE] = hl_none;
        high_level_stateSequence[HL_HEADER_FINISH] = hl_header_finish;
        high_level_stateSequence[HL_COMMAND] = hl_command;
        high_level_stateSequence[HL_ADDRESS] = hl_address;
        high_level_stateSequence[HL_BYTE_FROM_MC] = hl_byte_from_mc;
        high_level_stateSequence[HL_BYTE_TO_MC_NOMAK] = hl_byte_to_mc_nomak;
        high_level_stateSequence[HL_BYTE_DELAY] = hl_byte_delay;
        high_level_stateSequence[HL_PAGE_DELAY] = hl_page_delay;
        high_level_stateSequence[HL_WAIT_FOR_HEADER] = hl_wait_for_header;
        high_level_stateSequence[HL_BYTE_TO_MC] = hl_byte_to_mc;
    }
    
    int mc_status_register = 0; //xxxx BP1 BP0 WEL WIP(all x read as 0), only BP1 and BP0 can be set by user directly
    int mc_address_register = 0;
    int mc_writeTimer = 0;
    boolean mc_writeEnable = false;
    
    long cycles = 0; // last change of line was at time: "cycles"
    boolean lineIn = false; // false is 0, true is 1
    boolean old_lineIn = false;
    boolean lineOut = false; // false is 0, true is 1
    int bitSequenceTimer = 0;
    
    boolean commandStart = true; // indicator for MAK/NOMAK commands, that the command just started and nothing should be repeated
    
    int lowLevelState = LL_STANDBY;
    int mediumLevelState = ML_NONE;
    int highLevelState = HL_NONE;
    int highLevelSequenceCounter;

    public transient static int MAK = 1;
    public transient static int NOMAK = 0;
    public transient static int NONE = -1;
    int lastMasterAk = NONE;
    
    boolean isInputToMicrochip = true;
    
    // these define the boolean current state of the low level manchester code in "step"
    // either which state is currently read
    // or which state should be written
    public transient static final int MANCHESTER_SWITCH_NONE = 0;
    public transient static final int MANCHESTER_SWITCH_TRUE = 1;
    public transient static final int MANCHESTER_SWITCH_FALSE = -1;
    int lowLevelSwitch;
    int manchester0 = MANCHESTER_SWITCH_NONE; // only for debuging
    int manchester1 = MANCHESTER_SWITCH_NONE;
    
    int bitCounter = 0; // counter for 8 bit values
    long syncCounter = 0; // as a "counter" of cycles
    long headerSyncCounter = 0; // used in initializaten / calculation of timing period
    int dataByte = 0; // data byte got from a 8 bit manchester code

    long lastCalledCycles = 0; // when was "step" last called (in cycle)
    
    boolean firstChangeDone = false; // additional resync (see comment below)
    
    int delayValue = 0;
    int writeState = 0; // 0 we have not written data, 1 we have written first bit, 2 we have written mid change, 3 we have written 2 part
    
    public Microchip11AA010(Cartridge c)
    {
        cart = c;
    }
    public Microchip11AA010 clone()
    {
        Microchip11AA010 c = new Microchip11AA010(cart);
        for (int i=0; i<MAX_DATA_LEN;i++)
        {
            c.epromData.data[i] = epromData.data[i];
        }
        c.cycles = cycles;
        c.lineIn = lineIn; 
        c.old_lineIn = old_lineIn;
        c.lineOut = lineOut; 
        

        c.mc_status_register = mc_status_register;
        c.mc_address_register = mc_address_register;
        c.mc_writeEnable = mc_writeEnable;
        c.mc_writeTimer = mc_writeTimer;
        c.bitSequenceTimer = bitSequenceTimer;
        c.currentCommand = currentCommand;
        c.lowLevelState = lowLevelState;
        c.mediumLevelState = mediumLevelState;
        c.highLevelState = highLevelState;
        c.highLevelSequenceCounter = highLevelSequenceCounter;
        c.isInputToMicrochip = isInputToMicrochip;
        c.lowLevelSwitch = lowLevelSwitch;
        c.bitCounter = bitCounter; 
        c.syncCounter = syncCounter; 
        c.headerSyncCounter = headerSyncCounter; 
        c.dataByte = dataByte;
        c.lastCalledCycles = lastCalledCycles; 
        c.firstChangeDone = firstChangeDone; 
        c.delayValue = delayValue;
        c.writeState = writeState; 
        c.manchester0 = manchester0; 
        c.manchester1 = manchester1; 
        c.lastMasterAk = lastMasterAk; 
        c.commandStart = commandStart;
        
        
        
        return c;
    }

    void doError()
    {
        // go standby mode
        resetStandby();
        log.addLog("Microchip11AA010: ERROR - Standby entered!", LogPanel.ERROR);
    }
    public void reset()
    {
        loadBytesFromDisk();
        resetStandby();
        mc_writeEnable = false;
        mc_writeTimer = 0;
    }
    
    // switching to standby does NOT influence write enable!
    public void resetStandby()
    {
        manchester0 = MANCHESTER_SWITCH_NONE; // only for debuging
        manchester1 = MANCHESTER_SWITCH_NONE;

        lowLevelState = LL_STANDBY;
        highLevelState = HL_NONE;
        currentCommand = COMMAND_NONE;
        mediumLevelState = ML_NONE;
        lowLevelSwitch = MANCHESTER_SWITCH_NONE;
        syncCounter = 0;
        bitSequenceTimer = 0; 
    }

    // check if current command byte is valid
    boolean checkCommand()
    {
        boolean ok = false;
        if (currentCommand == COMMAND_READ)
        {
            log.addLog("Microchip11AA010: Command got: READ!", LogPanel.INFO);
            ok = true;
        }
        else if (currentCommand == COMMAND_CRRD)
        {
            log.addLog("Microchip11AA010: Command got: CRRD!", LogPanel.INFO);
            ok = true;
        }
        else if (currentCommand == COMMAND_WRITE)
        {
            log.addLog("Microchip11AA010: Command got: WRITE!", LogPanel.INFO);
            ok = true;
        }
        else if (currentCommand == COMMAND_WREN)
        {
            log.addLog("Microchip11AA010: Command got: WREN!", LogPanel.INFO);
            ok = true;
        }
        else if (currentCommand == COMMAND_WRDI)
        {
            log.addLog("Microchip11AA010: Command got: WRDI!", LogPanel.INFO);
            ok = true;
        }
        else if (currentCommand == COMMAND_RDSR)
        {
            log.addLog("Microchip11AA010: Command got: RDSR!", LogPanel.INFO);
            ok = true;
        }
        else if (currentCommand == COMMAND_WRSR)
        {
            log.addLog("Microchip11AA010: Command got: WRSR!", LogPanel.INFO);
            ok = true;
        }
        else if (currentCommand == COMMAND_ERAL)
        {
            log.addLog("Microchip11AA010: Command got: ERAL!", LogPanel.INFO);
            ok = true;
        }
        else if (currentCommand == COMMAND_SETAL)
        {
            log.addLog("Microchip11AA010: Command got: SETAL!", LogPanel.INFO);
            ok = true;
        }
        return ok;
    }
    public String getLowLevelName()
    {
        return ll_names[lowLevelState];
    }
    public String getMediumLevelName()
    {
        return ml_names[mediumLevelState];
    }
    public String getHighLevelName()
    {
        return hl_names[highLevelState];
    }

    public String getCommandName()
    {
        if (currentCommand == COMMAND_READ)
        {
            return "READ";
        }
        else if (currentCommand == COMMAND_CRRD)
        {
            return "CRRD";
        }
        else if (currentCommand == COMMAND_WRITE)
        {
            return "WRITE";
        }
        else if (currentCommand == COMMAND_WREN)
        {
            return "WREN";
        }
        else if (currentCommand == COMMAND_WRDI)
        {
            return "WRDI";
        }
        else if (currentCommand == COMMAND_RDSR)
        {
            return "RDSR";
        }
        else if (currentCommand == COMMAND_WRSR)
        {
            return "WRSR";
        }
        else if (currentCommand == COMMAND_ERAL)
        {
            return "ERAL";
        }
        else if (currentCommand == COMMAND_SETAL)
        {
            return "SETAL";
        }
        return "unkown";
    }
    
    public String getStatusRegister()
    {
        int reg = mc_status_register&0xc;
        if (mc_writeEnable) reg = reg | 0x02;
        if (mc_writeTimer>0) reg = reg | 0x01;
        return ""+DASM6809.printbinary(reg);
    }
    public String getAddressRegister()
    {
        return ""+mc_address_register;
    }
    public String getManchester0()
    {
        if (manchester0 == MANCHESTER_SWITCH_FALSE)
            return "false";
        if (manchester0 == MANCHESTER_SWITCH_TRUE)
            return "true";
        return "none";
    }
    public String getManchester1()
    {
        if (manchester1 == MANCHESTER_SWITCH_FALSE)
            return "false";
        if (manchester1 == MANCHESTER_SWITCH_TRUE)
            return "true";
        return "none";
    }
    public boolean isInputToMicrochip()
    {
        return isInputToMicrochip;
    }
    public String getWriteTimer()
    {
        if (mc_writeTimer<=0) return "none";
        return ""+mc_writeTimer;
    }

    public String getSyncBase()
    {
        return ""+bitSequenceTimer;
    }
    public String getSyncCounter()
    {
        if (syncCounter<=0) return "no sync";
        return ""+syncCounter;
    }
    public String getLineIn()
    {
        if (lineIn) return "1";
        return "0";
    }
    public String getLineOut()
    {
        if (lineOut) return "1";
        return "0";
    }
    public String getBitCounter()
    {
        return ""+bitCounter;
    }
    public String getBit()
    {
        if (lowLevelSwitch == MANCHESTER_SWITCH_FALSE)
            return "false";
        if (lowLevelSwitch == MANCHESTER_SWITCH_TRUE)
            return "true";
        return "none";
    }    
    // receiving line information from the emulator (VIA)
    public void lineIn(boolean l)
    {
        lineIn = l;
    }

    // sending line information to the emulator (VIA)
    public void lineOut(boolean l)
    {
        lineOut = l;
        cart.setPB6FromCarrtridge(lineOut);
    }    
    public static EpromData loadData(String serialname)
    {
        return (EpromData)CSAMainFrame.deserialize(serialname);
    }
    public static boolean saveData(String serialname, EpromData d)
    {
        return CSAMainFrame.serialize(d, serialname);
    }
    void loadBytesFromDisk()
    {
        epromData = loadData(getSaveName());
        if (epromData == null)
        {
            epromData = new EpromData();
        }
    }
    void saveBytestoDisk()
    {
        saveData(getSaveName(), epromData);
    }
    public String getSaveName()
    {
        return cart.cartName+".microchip.ser";
    }

    // low level step
    // this is triggered with every cycle from the emulator
    // c is the current cylce counter of the vecx emulator, needed for timing
    // (since I don't trust that we are called each cycle :-) )
    public void step(long c)
    {
        // all "timings" in vectrex cycles
        long difLast = c - lastCalledCycles;        // dif since last call of step
        mc_writeTimer -=difLast;
        if (mc_writeTimer<0)mc_writeTimer = 0;
        syncCounter += difLast;                     // time since sequence start
        lastCalledCycles = c;                       // keeping track of last call, for difLast
        long difLastChange = c - cycles;            // dif since last change of linen state
        boolean change = (lineIn != old_lineIn);    // did a change of line occur since last call of step()
        old_lineIn = lineIn;                        // keeping track of last state of line
        
        if (!isInputToMicrochip)
        {
            cycles = c; // we cant time out while in write mode - i think
        }
        if (change)
        {
            // reset cycle count on line changes (which are triggered from the outside)
            // in "cycles" allways the value is stored, when the last change of the line happened
            cycles = c;
        }
        
        // keeping "high" for to long will initiate a standby mode
        // regardless of any other mode we may be in
        if ((lineIn) && (difLastChange >standByPulseTimerCycles))
        {
            if (lowLevelState == LL_STANDBY) return;
            resetStandby();
            log.addLog("Microchip11AA010: Standby entered!", LogPanel.INFO);
            return;
        }
        
        // if the device "delays" it simulated the 
        // standby times for some timings
        // this is done in priority to all other states
        // known delays:
        // Tss = Start header setup (10 micro seconds)
        // Thdr = start header low pulse time (5 micro seconds)
        // Twc(byte) = 5 milli seconds
        // Twc(page) = 10 milli seconds
        // the last two delays will automatically initiate a standby mode!
        // if initiated after a SAK
        // this is in accordance to manual
        if (lowLevelState == LL_DELAY)
        {
            if (syncCounter>=delayValue)
            {
                handleOneSequence();
            }
            else
            {
                // do nothing while delaying
                // OR we could check for Thdr if state is really LOW, but why bother...
                // or for Tss if state is realy HIGH
                return;
            }
        }
        

        // if high level state == NONE
        // and we come here , than we are in header receive and timing sync
        if (highLevelState == HL_NONE)
        {
            // also determines sync timing
            checkHeaderSteps(c, change);
            return;
        }
        
        
        // if we come here, the communication sync has been established
        // we know the cycles for one sequence
        // from now on our thinking in lowlevel only is in regard to one "sequence"
        
        int mediumCycles = bitSequenceTimer/2; // middle of one sequence
        int mediumRange = mediumCycles/10; // doc says 5% difference allowed - I make it 20% ...
        
        // Tuts "special":
        // in vector pilot the command after a header start is
        // off (in regard to syncing) by 36 cycles [half sequence length = 72]
        // this is WAY out of any allowance what the handbook describes
        // anyway, it seems to work
        // therefor I implement another sync scheme:
        // if a change occured, and that change is "greater" than mediumCycles and no "first" change happened
        // than I accept that change as a medium change and resync to it 
        // see stuff arround: "firstChangeDone" 
        
        // we are in input mode, so read the line and set lowLevelSwitch to the byte change we find
        if (isInputToMicrochip)
        {
            // low level input of one sequence in sync timing
            //
            // encountered one "manchester" change
            // remember the manchester encoded bit, and try to resync
            if (change)
            {
                //// DISPLAY ONLY start
                if (syncCounter<=mediumRange)
                {
                    if (lineIn)
                        manchester0 = MANCHESTER_SWITCH_TRUE;
                    else
                        manchester0 = MANCHESTER_SWITCH_FALSE;
                }
                if (firstChangeDone)
                {
                    if (lineIn)
                        manchester1 = MANCHESTER_SWITCH_TRUE;
                    else
                        manchester1 = MANCHESTER_SWITCH_FALSE;
                }
                else if (syncCounter+mediumRange>=bitSequenceTimer)
                {
                    if (lineIn)
                        manchester1 = MANCHESTER_SWITCH_TRUE;
                    else
                        manchester1 = MANCHESTER_SWITCH_FALSE;
                }            
                //// DISPLAY ONLY end
                // mid change
                if ((Math.abs(syncCounter-mediumCycles)<=mediumRange) || ((syncCounter>mediumCycles) && (!firstChangeDone)))
                {
                    if (lineIn) // switch low to high = true
                        lowLevelSwitch = MANCHESTER_SWITCH_TRUE;
                    else
                        lowLevelSwitch = MANCHESTER_SWITCH_FALSE;
                    syncCounter = bitSequenceTimer/2;
                    firstChangeDone = true;

                }

                // if near a begin -> sync to 0 for keeping in sync
                else if (syncCounter<=mediumRange)
                {
                    syncCounter = 0;
                    firstChangeDone = true;
                }
                // if near an end -> sync to end for keeping in sync
                else if (syncCounter+mediumRange>=bitSequenceTimer)
                {
                    syncCounter = bitSequenceTimer;
                }
            }   
            
            
        }
        
        // we are in output mode, so write to line the bits in regard to lowLevelSwitch 
        else
        {
            // low level output of one sequence in sync timing
            
            // start one sequence
            // if we are pretty close to start, change output line in regard to the bit we must send
            if (syncCounter<=mediumRange) 
            {
                // only start writing if write state is 0
                if (writeState == 0)
                {
                    // manchester TRUE is low to high, so we start with low
                    if (lowLevelSwitch == MANCHESTER_SWITCH_TRUE)
                    {
                        // low to high
                        lineOut(false);
                    }
                    else if (lowLevelSwitch == MANCHESTER_SWITCH_FALSE)
                    {
                        // high to low
                        lineOut(true);
                    }
                    else if (lowLevelSwitch == MANCHESTER_SWITCH_NONE)
                    {
                        //  stay
                     //   lineOut(!lineIO);
                    }
                    syncCounter = 0;
                    writeState++;
                    if (lineOut)
                        manchester0 = MANCHESTER_SWITCH_TRUE;
                    else
                        manchester0 = MANCHESTER_SWITCH_FALSE;
                }
            }
            // mid change
            else if (syncCounter>=mediumCycles)
            {
                if (writeState == 1)
                {
                    if (lowLevelSwitch == MANCHESTER_SWITCH_TRUE)
                    {
                        // low to high
                        lineOut(true);
                    }
                    else if (lowLevelSwitch == MANCHESTER_SWITCH_FALSE)
                    {
                        // high to low
                        lineOut(false);
                    }
                    else if (lowLevelSwitch == MANCHESTER_SWITCH_NONE)
                    {
                        // opposite stay
                    }
                    writeState++;
                    syncCounter = bitSequenceTimer/2;
                }
                if (lineOut)
                    manchester1 = MANCHESTER_SWITCH_TRUE;
                else
                    manchester1 = MANCHESTER_SWITCH_FALSE;
            }
            // end output
            else if (syncCounter>=bitSequenceTimer)
            {
                if (writeState == 2)
                {
                    writeState++;
                }
            }
        }

        
        // complete sequence, if complete, lets handle the result of the one sequence
        if (syncCounter>=bitSequenceTimer)
        {
            handleOneSequence();
            firstChangeDone = false;
        }
    }
    
    
    // here no syncing has been done and the length of one bit sequence is not known
    // these are low level steps only!
    // the header consists of 8 bits
    // timing for these 8 bits is measured
    // and divided by 8, thus the sequence length for future reference is derived
    void checkHeaderSteps(long c, boolean change)    
    {
        bitSequenceTimer = 0;
        lastMasterAk = NONE;
        currentCommand = COMMAND_NONE;
        
        // getting a low while in standby mode initiates a start header sequence
        if (((lowLevelState == LL_STANDBY)||(lowLevelState == LL_NONE)) && (!lineIn)) // NONE is waiting for header
        {
            if (lowLevelState == LL_STANDBY)
                log.addLog("Microchip11AA010: Activation impulse found (from standby)!", LogPanel.INFO);
            else
                log.addLog("Microchip11AA010: Activation impulse found (from 'wait for header')!", LogPanel.INFO);
            lowLevelState = LL_START_HEADER;
            return;
        }
        if (!change) return;
        
        
        
        // getting a high after an activation imulse starts the
        // actual header byte sequence 0101 0101
        // with that byte sequence the "period" length of one byte is measured
        if ((lowLevelState == LL_START_HEADER) && (lineIn))
        {
            log.addLog("Microchip11AA010: Activation impulse ended, reading bit 0 of header!", LogPanel.VERBOSE);
            lowLevelState = LL_IN_HEADER_0; 
            headerSyncCounter = cycles;
            manchester0 = MANCHESTER_SWITCH_TRUE;
            manchester1 = MANCHESTER_SWITCH_NONE;
            bitCounter = 0;
            dataByte = 0;
            return;
        }
        // in the middle of a bit 0, switch from high to low
        if ((lowLevelState == LL_IN_HEADER_0) && (!lineIn))
        {
            log.addLog("Microchip11AA010: Receive header bit ("+bitCounter+") =  0!", LogPanel.VERBOSE);
            lowLevelState = LL_IN_HEADER_1;
            dataByte = dataByte <<1;
            dataByte+=0;
            manchester0 = MANCHESTER_SWITCH_TRUE;
            manchester1 = MANCHESTER_SWITCH_FALSE;
            bitCounter++;
            return;
        }
        
        // in the middle of a bit 1, switch from low to high
        if ((lowLevelState == LL_IN_HEADER_1) && (lineIn))
        {
            lowLevelState = LL_IN_HEADER_0;
            log.addLog("Microchip11AA010: Receive header bit ("+bitCounter+") =  1!", LogPanel.VERBOSE);
            manchester0 = MANCHESTER_SWITCH_FALSE;
            manchester1 = MANCHESTER_SWITCH_TRUE;
            dataByte = dataByte <<1;
            dataByte+=1;
            bitCounter++;
            if (bitCounter == 8)
            {
                lowLevelState = LL_IN_HEADER_FINISH;
            }
            return;
        }
        if ((lowLevelState == LL_IN_HEADER_FINISH) && (!lineIn))
        {
            if (dataByte != 85) // 0101 0101
            {
                // error
                log.addLog("Microchip11AA010: header byte is incorrect ("+DASM6809.printbinary(dataByte)+")!", LogPanel.INFO);
                doError();
                return;
            }
            else
            {
                log.addLog("Microchip11AA010: header byte is correct (0101 0101)!", LogPanel.INFO);
            }
            int periodLength = (int)(cycles - headerSyncCounter);
            bitSequenceTimer = periodLength/8;
            bitSequenceTimer += 2; // adjustment, doing the EXACT timing above, seems to be off for 1 cycle at least with vector pilot, 
                                   // for good measurement I added two!
            log.addLog("Microchip11AA010: Receive header finish: sequence length in vectrex cycles: "+bitSequenceTimer, LogPanel.INFO);
            initHighLevel(HL_HEADER_FINISH);
            return;
        }

    }
    void initHighLevel(int hl)
    {
        lastMasterAk = NONE;
        highLevelState = hl;
        highLevelSequenceCounter = 0;
        initMediumLevel(high_level_stateSequence[highLevelState][highLevelSequenceCounter]);
    }
    void initMediumLevel(int ml)
    {
        lowLevelState = LL_NONE;
        mediumLevelState = ml;
        if (mediumLevelState == ML_NONE)        isInputToMicrochip = true;
        if (mediumLevelState == ML_MAK)         isInputToMicrochip = true;
        if (mediumLevelState == ML_NOMAK)       isInputToMicrochip = true;
        if (mediumLevelState == ML_MAK_OR_NO_MAK)isInputToMicrochip = true;
        if (mediumLevelState == ML_SAK)         isInputToMicrochip = false;
        if (mediumLevelState == ML_NOSAK)       isInputToMicrochip = false;
        if (mediumLevelState == ML_COMMAND)     isInputToMicrochip = true;
        if (mediumLevelState == ML_DEV_ADDRESS) isInputToMicrochip = true;
        if (mediumLevelState == ML_DELAY_TSS)   isInputToMicrochip = true; // doesnt matter
        if (mediumLevelState == ML_DELAY_THDR)  isInputToMicrochip = true; // doesnt matter
        if (mediumLevelState == ML_DELAY_BYTE_WRITE)   isInputToMicrochip = true; // doesnt matter
        if (mediumLevelState == ML_DELAY_PAGE_WRITE)  isInputToMicrochip = true; // doesnt matter
        if (mediumLevelState == ML_WAIT_FOR_HEADER)  isInputToMicrochip = true; // doesnt matter
        if (mediumLevelState == ML_ADDRESS_HI) isInputToMicrochip = true;
        if (mediumLevelState == ML_ADDRESS_LO) isInputToMicrochip = true;
        if (mediumLevelState == ML_BYTE_FROM_MC) isInputToMicrochip = false;
        if (mediumLevelState == ML_BYTE_TO_MC) isInputToMicrochip = true;

        
        switch (mediumLevelState)
        {
            case ML_BYTE_FROM_MC:
            {
                if (currentCommand == COMMAND_RDSR)
                {
                    int reg = mc_status_register&0xc;
                    if (mc_writeEnable) reg = reg | 0x02;
                    if (mc_writeTimer>0) reg = reg | 0x01;
                    dataByte = reg;
                    log.addLog("Microchip11AA010: initMediumLevel() byte write initiated "+mediumLevelState+", from status register, value: $"+ String.format("%02X", reg), LogPanel.VERBOSE);
                }
                if (currentCommand == COMMAND_READ)
                {
                    log.addLog("Microchip11AA010: initMediumLevel() byte write initiated "+mediumLevelState+", from address $"+ String.format("%04X", mc_address_register), LogPanel.VERBOSE);
                    dataByte = epromData.data[mc_address_register];
                }
                bitCounter = 0;
                if ((dataByte&0x80) == 0x80)
                {
                    lowLevelSwitch = MANCHESTER_SWITCH_TRUE;
                    log.addLog("Microchip11AA010: bit("+bitCounter+") write 1", LogPanel.VERBOSE);
                }
                else
                {
                    lowLevelSwitch = MANCHESTER_SWITCH_FALSE;
                    log.addLog("Microchip11AA010: bit("+bitCounter+") write 0", LogPanel.VERBOSE);
                }
                break;
            }
            case ML_ADDRESS_HI:
            case ML_ADDRESS_LO:
            case ML_BYTE_TO_MC:
            case ML_COMMAND:
            case ML_DEV_ADDRESS:
            {
                log.addLog("Microchip11AA010: initMediumLevel() byte read initiated "+mediumLevelState, LogPanel.VERBOSE);
                bitCounter = 0;
                dataByte = 0;
                break;
            }
            case ML_DELAY_BYTE_WRITE:
            {
                log.addLog("Microchip11AA010: initMediumLevel() byte delay initiated "+mediumLevelState, LogPanel.VERBOSE);
                lowLevelState = LL_DELAY;
                delayValue = writeCycleTimeByteCycles;
                break;
            }
            case ML_DELAY_PAGE_WRITE:
            {
                log.addLog("Microchip11AA010: initMediumLevel() page delay initiated "+mediumLevelState, LogPanel.VERBOSE);
                lowLevelState = LL_DELAY;
                delayValue = writeCycleTimePageCycles;
                break;
            }
            case ML_DELAY_TSS:
            {
                log.addLog("Microchip11AA010: initMediumLevel() tss delay initiated "+mediumLevelState, LogPanel.VERBOSE);
                lowLevelState = LL_DELAY;
                delayValue = startHeaderSetupCycles;
                break;
            }
            case ML_DELAY_THDR:
            {
                log.addLog("Microchip11AA010: initMediumLevel() thdr delay initiated "+mediumLevelState, LogPanel.VERBOSE);
                lowLevelState = LL_DELAY;
                delayValue = startHeaderLowPulseCycles;
                break;
            }
            case ML_WAIT_FOR_HEADER:
            {
                log.addLog("Microchip11AA010: initMediumLevel() wait for header initiated "+mediumLevelState, LogPanel.VERBOSE);
                highLevelState = HL_NONE; // do low level only
                break;
            }
            case ML_MAK_OR_NO_MAK:
            {
                lastMasterAk = NONE;
                log.addLog("Microchip11AA010: initMediumLevel() MAK OR NOMAK initiated "+mediumLevelState, LogPanel.VERBOSE);
                break;
            }
            case ML_MAK:
            {
                log.addLog("Microchip11AA010: initMediumLevel() MAK initiated "+mediumLevelState, LogPanel.VERBOSE);
                break;
            }
            case ML_NOMAK:
            {
                log.addLog("Microchip11AA010: initMediumLevel() NOMAK initiated "+mediumLevelState, LogPanel.VERBOSE);
                break;
            }
            case ML_SAK:
            {
                log.addLog("Microchip11AA010: initMediumLevel() SAK initiated "+mediumLevelState, LogPanel.VERBOSE);
                lowLevelSwitch = MANCHESTER_SWITCH_TRUE;
                break;
            }
            case ML_NOSAK:
            {
                log.addLog("Microchip11AA010: initMediumLevel() NOSAK initiated "+mediumLevelState, LogPanel.VERBOSE);
                lowLevelSwitch = MANCHESTER_SWITCH_NONE;
                break;
            }
            default:
            {
                log.addLog("Microchip11AA010: initMediumLevel() ERROR unkown ML STATUS: "+mediumLevelState, LogPanel.ERROR);
                break;
            }
        }
        if (isInputToMicrochip)
            initLowLevelRead();
        else
            initLowLevelWrite();
    }
    void initLowLevelWrite()
    {
        syncCounter = 0;
        writeState = 0;
    }
    void initLowLevelRead()
    {
        syncCounter = 0;
        lowLevelSwitch = MANCHESTER_SWITCH_NONE;
    }
    void handleOneSequence()
    {
        // todo
        boolean ok = false;
        manchester0 = MANCHESTER_SWITCH_NONE; // only for debuging
        manchester1 = MANCHESTER_SWITCH_NONE;
        switch (mediumLevelState)
        {
            case ML_MAK_OR_NO_MAK:
            {
                if (commandStart)
                {
                    if (lowLevelSwitch == MANCHESTER_SWITCH_FALSE)
                    {
                        // success
                        ok = true;
                        log.addLog("Microchip11AA010: NOMAK received!", LogPanel.INFO);
                        lastMasterAk = NOMAK;
                    }
                    else if (lowLevelSwitch == MANCHESTER_SWITCH_TRUE)
                    {
                        ok = true;
                        log.addLog("Microchip11AA010: MAK received!", LogPanel.INFO);
                        lastMasterAk = MAK;
                    }
                    else 
                    {
                        // error
                        // what now?
                        log.addLog("Microchip11AA010: no (MAK or NOMAK) received!", LogPanel.INFO);
                    }                 
                    commandStart = false;
                    break;
                }
                
                if (currentCommand == COMMAND_WRITE)
                {
                    log.addLog("Microchip11AA010: WRITE data ($"+String.format("%02X", dataByte)+") to MC address: $"+String.format("%04X", mc_address_register)+"!", LogPanel.INFO);

                    int block = 0;
                    if (mc_address_register>=128/4) block++;
                    if (mc_address_register>=128/2) block++;
                    if (mc_address_register>=128/2+128/4) block++;
                    
                    if (!isProtected(block))
                    {
                        epromData.data[mc_address_register] = (byte)dataByte;
                    }
                    else
                    {
                        log.addLog("Microchip11AA010: WRITE error, address is write protected!", LogPanel.INFO);
                    }
                        
                }

                
                if (lowLevelSwitch == MANCHESTER_SWITCH_FALSE)
                {
                    // success
                    ok = true;
                    log.addLog("Microchip11AA010: NOMAK received!", LogPanel.INFO);
                    if (  (currentCommand == COMMAND_READ)
                        ||(currentCommand == COMMAND_CRRD))
                        mc_address_register++;
                    if (currentCommand == COMMAND_WRITE)
                    {
                        // respect low nibble as page boundry
                        int hi = mc_address_register & 0xf0;
                        int lo = mc_address_register & 0xf;
                        lo = (lo+1)%16;
                        mc_address_register = hi+lo;
                    }
                    mc_address_register = mc_address_register % MAX_DATA_LEN;
                    lastMasterAk = NOMAK;
                }
                else if (lowLevelSwitch == MANCHESTER_SWITCH_TRUE)
                {
                    ok = true;
                    log.addLog("Microchip11AA010: MAK received - high level command repeated!", LogPanel.INFO);
                    if (  (currentCommand == COMMAND_READ)
                        ||(currentCommand == COMMAND_CRRD))
                        mc_address_register++;
                    if (currentCommand == COMMAND_WRITE)
                    {
                        // respect low nibble as page boundry
                        int hi = mc_address_register & 0xf0;
                        int lo = mc_address_register & 0xf;
                        lo = (lo+1)%16;
                        mc_address_register = hi+lo;
                    }
                    mc_address_register = mc_address_register % MAX_DATA_LEN;
                    lastMasterAk = MAK;
                }
                else 
                {
                    // error
                    // what now?
                    log.addLog("Microchip11AA010: no (MAK or NOMAK) received!", LogPanel.INFO);
                }
                break;
            }

            case ML_BYTE_FROM_MC:
            {
                bitCounter++;
                if (bitCounter<8)
                {
                    dataByte = (dataByte<<1)&0xff;
                    if ((dataByte&0x80) == 0x80)
                    {
                        lowLevelSwitch = MANCHESTER_SWITCH_TRUE;
                        log.addLog("Microchip11AA010: bit("+bitCounter+") write 1", LogPanel.VERBOSE);
                    }
                    else
                    {
                        lowLevelSwitch = MANCHESTER_SWITCH_FALSE;
                        log.addLog("Microchip11AA010: bit("+bitCounter+") write 0", LogPanel.VERBOSE);
                    }
                    initLowLevelWrite();
                    
                    return;
                }
                ok = true;
                break;
            }
            // read a byte
            case ML_ADDRESS_HI:
            case ML_ADDRESS_LO:
            case ML_BYTE_TO_MC:
            case ML_COMMAND:
            case ML_DEV_ADDRESS:
            {
                if (bitCounter<8)
                {
                    dataByte = dataByte<<1;
                    if (lowLevelSwitch == MANCHESTER_SWITCH_TRUE)
                    {
                        dataByte++;
                        log.addLog("Microchip11AA010: bit("+bitCounter+") received: 1", LogPanel.VERBOSE);
                    }
                    else if (lowLevelSwitch == MANCHESTER_SWITCH_FALSE)
                    {
                        log.addLog("Microchip11AA010: bit("+bitCounter+") received: 0", LogPanel.VERBOSE);
                    }
                    else 
                    {
                        log.addLog("Microchip11AA010: bit("+bitCounter+") received: ?", LogPanel.VERBOSE);
                        doError();
                        return;
                    }
                    initLowLevelRead();
                    bitCounter++;
                }
                if (bitCounter<8) return;

                
                if (mediumLevelState == ML_ADDRESS_LO)
                {
                    mc_address_register = (mc_address_register & 0xff00)+dataByte;
                    ok = true;
                }
                else if (mediumLevelState == ML_ADDRESS_HI)
                {
                    mc_address_register = (mc_address_register & 0xff)+(dataByte<<8);
                    ok = true;
                }
                else if (mediumLevelState == ML_DEV_ADDRESS)
                {
                    // device byte: 1010 0000 = $a0
                    ok = (dataByte == 0xa0);


                    if (ok)
                        log.addLog("Microchip11AA010: device byte correctly received (1010 0000)!", LogPanel.INFO);
                    else
                        log.addLog("Microchip11AA010: device byte is incorrect ("+DASM6809.printbinary(dataByte)+")!", LogPanel.INFO);
                }
                else if (mediumLevelState == ML_COMMAND)
                {
                    currentCommand = dataByte;
                    ok = checkCommand();
                    if (!ok)
                        log.addLog("Microchip11AA010: Command unkown ($"+String.format("%02X", dataByte)+")!", LogPanel.WARN);
                    else
                    {
                        commandStart = true;
                    }
                }            
                else
                {
                    log.addLog("Microchip11AA010: byte received ($"+String.format("%02X", dataByte)+")!", LogPanel.INFO);
                    ok = true;
                }
                break;

            }
            case ML_NOMAK:
            {
                if (lowLevelSwitch == MANCHESTER_SWITCH_FALSE)
                {
                    // success
                    ok = true;
                    log.addLog("Microchip11AA010: NOMAK received!", LogPanel.INFO);
                }
                else
                {
                    // error
                    // what now?
                    log.addLog("Microchip11AA010: NOMAK not received!", LogPanel.INFO);
                }
                break;
            }
            case ML_MAK:
            {
                if (lowLevelSwitch == MANCHESTER_SWITCH_TRUE)
                {
                    // success
                    ok = true;
                    log.addLog("Microchip11AA010: MAK received!", LogPanel.INFO);
                }
                else
                {
                    // error
                    // what now?
                    log.addLog("Microchip11AA010: MAK not received!", LogPanel.INFO);
                }
                break;
            }
            case ML_SAK:   // was a write, cant check anything
            {
                ok = true;
                log.addLog("Microchip11AA010: SAK sent!", LogPanel.INFO);
                break;
            }
            case ML_NOSAK: // was a write, cant check anything
            {
                ok = true;
                log.addLog("Microchip11AA010: NOSAK sent!", LogPanel.INFO);
                break;
            }
            case ML_DELAY_TSS:
            {
                ok = true;
                log.addLog("Microchip11AA010: TSS wait!", LogPanel.INFO);
                break;
            }
            case ML_DELAY_THDR:
            {
                ok = true;
                log.addLog("Microchip11AA010: THDR wait!", LogPanel.INFO);
                break;
            }
            case ML_WAIT_FOR_HEADER:
            {
                // wait forever - stay in "loop" of medium states
                highLevelSequenceCounter--;
                ok = true;
                log.addLog("Microchip11AA010: Header wait!", LogPanel.INFO);
                break;
            }
            default:
            {
                log.addLog("Microchip11AA010: handleOneSequence() ERROR unkown ML STATUS: "+mediumLevelState, LogPanel.ERROR);
            }
        }
        if (ok)
        {
            if (highLevelSequenceCounter+1<high_level_stateSequence[highLevelState].length)
            {
                highLevelSequenceCounter++;
                initMediumLevel(high_level_stateSequence[highLevelState][highLevelSequenceCounter]);
            }
            else
            {
                nextHighlevel();
            }
        }
        else
        {
            doError();
        }
            
    }
    void nextHighlevel()
    {
        // the switching is allways done
        // with the PREVIOUSLY
        // executed high level state
        // on this must be reacted!
        // and the next high level state must be derived from that
        switch (highLevelState)
        {
            case HL_HEADER_FINISH:
            {
                log.addLog("Microchip11AA010: HL_HEADER_FINISH done", LogPanel.VERBOSE);
                initHighLevel(HL_COMMAND);
                break;
            }
            // we received a byte for a command
            // handle command again...
            case HL_BYTE_TO_MC_NOMAK:
            {
                switch (currentCommand)
                {
                    case COMMAND_WRSR:
                    {
                        log.addLog("Microchip11AA010: HL_BYTE_TO_MC_NOMAK->WRSR done", LogPanel.VERBOSE);
                        mc_status_register = dataByte&0x0c; // only block read write can be user set
                        mc_writeTimer = writeCycleTimeByteCycles;
                        log.addLog("Microchip11AA010: Status register set to: $"+String.format("%02X", dataByte), LogPanel.INFO);
                        initHighLevel(HL_BYTE_DELAY); // enters standby
                        mc_writeEnable = false; // write disables write latch
                        break;
                    }
                    default:
                    {
                        log.addLog("Microchip11AA010: done, HL_BYTE_TO_MC_NOMAK-> command not found", LogPanel.ERROR);
                        doError();
                        break;
                    }
                    
                }                
                break;
            }
            // we received a byte for a command
            // perhaps redo command (write)
            case HL_BYTE_TO_MC:
            {
                switch (currentCommand)
                {
                    case COMMAND_WRITE:
                    {
                        // if this is a continuous write.... continue
                        if (lastMasterAk == MAK)
                        {
                            initHighLevel(HL_BYTE_TO_MC); 
                        }
                        else
                        {
                            // write is initiated by a nomak
                            mc_writeTimer = writeCycleTimeByteCycles;
                            mc_writeEnable = false; // write disables write latch
                            saveBytestoDisk();
                            initHighLevel(HL_WAIT_FOR_HEADER); 
                        }
                        break;
                    }
                    default:
                    {
                        log.addLog("Microchip11AA010: done, HL_BYTE_TO_MC-> command not found", LogPanel.ERROR);
                        doError();
                        break;
                    }
                    
                }                
                break;
            }
            
            case HL_BYTE_FROM_MC:
            {
                switch (currentCommand)
                {
                    case COMMAND_READ:
                    {
                        // if this is a continuous read.... continue
                        if (lastMasterAk == MAK)
                        {
                            initHighLevel(HL_BYTE_FROM_MC); 
                        }
                        else
                        {
                            initHighLevel(HL_WAIT_FOR_HEADER); 
                        }
                        break;
                    }
                    
                    case COMMAND_RDSR:
                    {
                        // if this is a continuous read.... continue
                        if (lastMasterAk == MAK)
                        {
                            initHighLevel(HL_BYTE_FROM_MC); 
                        }
                        else
                        {
                            initHighLevel(HL_WAIT_FOR_HEADER); 
                        }
                        break;
                    }
                    default:
                    {
                        log.addLog("Microchip11AA010: done, HL_BYTE_FROM_MC-> command not found", LogPanel.ERROR);
                        doError();
                        break;
                    }
                    
                }                
                break;                
            }
            case HL_ADDRESS:
            {
                switch (currentCommand)
                {
                    case COMMAND_READ:
                    {
                        mc_address_register = mc_address_register % MAX_DATA_LEN;
                        log.addLog("Microchip11AA010: Address register set to: $"+String.format("%04X", mc_address_register), LogPanel.INFO);
                        log.addLog("Microchip11AA010: HL_ADDRESS->READ done", LogPanel.VERBOSE);
                        initHighLevel(HL_BYTE_FROM_MC); 
                        break;
                    }
                    case COMMAND_WRITE:
                    {
                        mc_address_register = mc_address_register % MAX_DATA_LEN;
                        log.addLog("Microchip11AA010: Address register set to: $"+String.format("%04X", mc_address_register), LogPanel.INFO);
                        log.addLog("Microchip11AA010: HL_ADDRESS->WRITE done", LogPanel.VERBOSE);

                        initHighLevel(HL_BYTE_TO_MC); 
                        break;
                    }
                    default:
                    {
                        log.addLog("Microchip11AA010: done, HL_ADDRESS-> command not found", LogPanel.ERROR);
                        doError();
                        break;
                    }
                    
                }                
                break;
            }
            
            case HL_COMMAND:
            {
                switch (currentCommand)
                {
                    case COMMAND_RDSR:
                    {
                        log.addLog("Microchip11AA010: HL_COMMAND->RDSR) done", LogPanel.VERBOSE);
                        initHighLevel(HL_BYTE_FROM_MC);
                        break;
                    }
                    case COMMAND_WRSR:
                    {
                        log.addLog("Microchip11AA010: HL_COMMAND->WRSR done", LogPanel.VERBOSE);
                        initHighLevel(HL_BYTE_TO_MC_NOMAK);
                        break;
                    }
                    case COMMAND_READ:
                    {
                        log.addLog("Microchip11AA010: HL_COMMAND->READ done", LogPanel.VERBOSE);
                        mc_address_register = 0;
                        initHighLevel(HL_ADDRESS);
                        break;
                    }
                    case COMMAND_WREN:
                    {
                        log.addLog("Microchip11AA010: HL_COMMAND->WREN done", LogPanel.VERBOSE);
                        
                        if (lastMasterAk == NOMAK)
                        {
                            initHighLevel(HL_WAIT_FOR_HEADER); 
                            mc_writeEnable = true;
                        }
                        else
                        {
                            log.addLog("Microchip11AA010: done, HL_COMMAND->WREN NOMAK not found!", LogPanel.ERROR);
                            doError();
                        }
                        break;
                    }
                    case COMMAND_WRDI:
                    {
                        log.addLog("Microchip11AA010: HL_COMMAND->WRDI done", LogPanel.VERBOSE);
                        if (lastMasterAk == NOMAK)
                        {
                            initHighLevel(HL_WAIT_FOR_HEADER); 
                            mc_writeEnable = false;
                        }
                        else
                        {
                            log.addLog("Microchip11AA010: done,  HL_COMMAND->WRDI NOMAK not found!", LogPanel.ERROR);
                            doError();
                        }
                        break;
                    }
                    
                    case COMMAND_WRITE:
                    {
                        log.addLog("Microchip11AA010: HL_COMMAND->WRITE done", LogPanel.VERBOSE);
                        mc_address_register = 0;
                        initHighLevel(HL_ADDRESS);
                        break;
                    }
                    
                    default:
                    {
                        log.addLog("Microchip11AA010: done, HL_COMMAND->command not found!", LogPanel.ERROR);
                        doError();
                        break;
                    }
                    
                }
                
                break;
            }
            default:
            {
                log.addLog("Microchip11AA010: ERROR unkown HL STATUS: "+highLevelState, LogPanel.ERROR);
                doError();
                break;
            }

        }
    }
    boolean isProtected(int block)
    {
        int reg = mc_status_register&0xc;
        if (mc_writeEnable) reg = reg | 0x02;
        if (mc_writeTimer>0) reg = reg | 0x01;

        if ((reg&0x02) == 0x00) return true; // write enable is disabled
        if ((reg&0x01) == 0x01) return true; // another write is still active
        
        
        int protBloc = reg>>2;
        if ((block == 3) && (protBloc>0)) return true;
        if ((block == 2) && (protBloc>1)) return true;
        if ((block == 1) && (protBloc>2)) return true;
        if ((block == 0) && (protBloc>2)) return true;
        return false;
    }
    public boolean isActive()
    {
        return highLevelState != HL_NONE;
    }
}

