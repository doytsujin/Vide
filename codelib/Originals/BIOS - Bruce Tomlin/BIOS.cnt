BANK 0
EQU $00 
LABEL $C800 Vec_Snd_Shadow
COMMENT_LABEL $C800 Shadow of sound chip registers (15 bytes)
LABEL $C80F Vec_Btn_State
COMMENT_LABEL $C80F Current state of all joystick buttons
LABEL $C810 Vec_Prev_Btns
COMMENT_LABEL $C810 Previous state of all joystick buttons
LABEL $C811 Vec_Buttons
COMMENT_LABEL $C811 Current toggle state of all buttons
LABEL $C812 Vec_Button_1_1
COMMENT_LABEL $C812 Current toggle state of stick 1 button 1
LABEL $C813 Vec_Button_1_2
COMMENT_LABEL $C813 Current toggle state of stick 1 button 2
LABEL $C814 Vec_Button_1_3
COMMENT_LABEL $C814 Current toggle state of stick 1 button 3
LABEL $C815 Vec_Button_1_4
COMMENT_LABEL $C815 Current toggle state of stick 1 button 4
LABEL $C816 Vec_Button_2_1
COMMENT_LABEL $C816 Current toggle state of stick 2 button 1
LABEL $C817 Vec_Button_2_2
COMMENT_LABEL $C817 Current toggle state of stick 2 button 2
LABEL $C818 Vec_Button_2_3
COMMENT_LABEL $C818 Current toggle state of stick 2 button 3
LABEL $C819 Vec_Button_2_4
COMMENT_LABEL $C819 Current toggle state of stick 2 button 4
LABEL $C81A Vec_Joy_Resltn
COMMENT_LABEL $C81A Joystick A/D resolution ($80=min $00=max)
LABEL $C81B Vec_Joy_1_X
COMMENT_LABEL $C81B Joystick 1 left/right
LABEL $C81C Vec_Joy_1_Y
COMMENT_LABEL $C81C Joystick 1 up/down
LABEL $C81D Vec_Joy_2_X
COMMENT_LABEL $C81D Joystick 2 left/right
LABEL $C81E Vec_Joy_2_Y
COMMENT_LABEL $C81E Joystick 2 up/down
LABEL $C81F Vec_Joy_Mux
COMMENT_LABEL $C81F Joystick enable/mux flags (4 bytes)
LABEL $C81F Vec_Joy_Mux_1_X
COMMENT_LABEL $C81F Joystick 1 X enable/mux flag (=1)
LABEL $C820 Vec_Joy_Mux_1_Y
COMMENT_LABEL $C820 Joystick 1 Y enable/mux flag (=3)
LABEL $C821 Vec_Joy_Mux_2_X
COMMENT_LABEL $C821 Joystick 2 X enable/mux flag (=5)
LABEL $C822 Vec_Joy_Mux_2_Y
COMMENT_LABEL $C822 Joystick 2 Y enable/mux flag (=7)
LABEL $C823 Vec_Misc_Count
COMMENT_LABEL $C823 Misc counter/flag byte, zero when not in use
LABEL $C824 Vec_0Ref_Enable
COMMENT_LABEL $C824 Check0Ref enable flag
LABEL $C825 Vec_Loop_Count
COMMENT_LABEL $C825 Loop counter word (incremented in Wait_Recal)
LABEL $C827 Vec_Brightness
COMMENT_LABEL $C827 Default brightness
LABEL $C828 Vec_Dot_Dwell
COMMENT_LABEL $C828 Dot dwell time?
LABEL $C829 Vec_Pattern
COMMENT_LABEL $C829 Dot pattern (bits)
LABEL $C82A Vec_Text_HW
COMMENT_LABEL $C82A Default text height and width
LABEL $C82A Vec_Text_Height
COMMENT_LABEL $C82A Default text height
LABEL $C82B Vec_Text_Width
COMMENT_LABEL $C82B Default text width
LABEL $C82C Vec_Str_Ptr
COMMENT_LABEL $C82C Temporary string pointer for Print_Str
LABEL $C82E Vec_Counters
COMMENT_LABEL $C82E Six bytes of counters
LABEL $C82E Vec_Counter_1
COMMENT_LABEL $C82E First  counter byte
LABEL $C82F Vec_Counter_2
COMMENT_LABEL $C82F Second counter byte
LABEL $C830 Vec_Counter_3
COMMENT_LABEL $C830 Third  counter byte
LABEL $C831 Vec_Counter_4
COMMENT_LABEL $C831 Fourth counter byte
LABEL $C832 Vec_Counter_5
COMMENT_LABEL $C832 Fifth  counter byte
LABEL $C833 Vec_Counter_6
COMMENT_LABEL $C833 Sixth  counter byte
LABEL $C834 Vec_RiseRun_Tmp
COMMENT_LABEL $C834 Temp storage word for rise/run
LABEL $C836 Vec_Angle
COMMENT_LABEL $C836 Angle for rise/run and rotation calculations
LABEL $C837 Vec_Run_Index
COMMENT_LABEL $C837 Index pair for run
LABEL $C839 Vec_Rise_Index
COMMENT_LABEL $C839 Index pair for rise
LABEL $C83B Vec_RiseRun_Len
COMMENT_LABEL $C83B length for rise/run
LABEL $C83D Vec_Rfrsh
COMMENT_LABEL $C83D Refresh time (divided by 1.5MHz)
LABEL $C83D Vec_Rfrsh_lo
COMMENT_LABEL $C83D Refresh time low byte
LABEL $C83E Vec_Rfrsh_hi
COMMENT_LABEL $C83E Refresh time high byte
LABEL $C83F Vec_Music_Work
COMMENT_LABEL $C83F Music work buffer (14 bytes, backwards?)
LABEL $C842 Vec_Music_Wk_A
COMMENT_LABEL $C842 register 10
LABEL $C845 Vec_Music_Wk_7
COMMENT_LABEL $C845 register 7
LABEL $C846 Vec_Music_Wk_6
COMMENT_LABEL $C846 register 6
LABEL $C847 Vec_Music_Wk_5
COMMENT_LABEL $C847 register 5
LABEL $C84B Vec_Music_Wk_1
COMMENT_LABEL $C84B register 1
LABEL $C84D Vec_Freq_Table
COMMENT_LABEL $C84D Pointer to note-to-frequency table (normally $FC8D)
LABEL $C84F Vec_Max_Players
COMMENT_LABEL $C84F Maximum number of players for Select_Game
LABEL $C850 Vec_Max_Games
COMMENT_LABEL $C850 Maximum number of games for Select_Game
LABEL $C84F Vec_ADSR_Table
COMMENT_LABEL $C84F Storage for first music header word (ADSR table)
LABEL $C851 Vec_Twang_Table
COMMENT_LABEL $C851 Storage for second music header word ('twang' table)
LABEL $C853 Vec_Music_Ptr
COMMENT_LABEL $C853 Music data pointer
LABEL $C853 Vec_Expl_ChanA
COMMENT_LABEL $C853 Used by Explosion_Snd - bit for first channel used?
LABEL $C854 Vec_Expl_Chans
COMMENT_LABEL $C854 Used by Explosion_Snd - bits for all channels used?
LABEL $C855 Vec_Music_Chan
COMMENT_LABEL $C855 Current sound channel number for Init_Music
LABEL $C856 Vec_Music_Flag
COMMENT_LABEL $C856 Music active flag ($00=off $01=start $80=on)
LABEL $C857 Vec_Duration
COMMENT_LABEL $C857 Duration counter for Init_Music
LABEL $C858 Vec_Music_Twang
COMMENT_LABEL $C858 3 word 'twang' table used by Init_Music
LABEL $C858 Vec_Expl_1
COMMENT_LABEL $C858 Four bytes copied from Explosion_Snd's U-reg parameters
LABEL $C859 Vec_Expl_2
LABEL $C85A Vec_Expl_3
LABEL $C85B Vec_Expl_4
LABEL $C85C Vec_Expl_Chan
COMMENT_LABEL $C85C Used by Explosion_Snd - channel number in use?
LABEL $C85D Vec_Expl_ChanB
COMMENT_LABEL $C85D Used by Explosion_Snd - bit for second channel used?
LABEL $C85E Vec_ADSR_Timers
COMMENT_LABEL $C85E ADSR timers for each sound channel (3 bytes)
LABEL $C861 Vec_Music_Freq
COMMENT_LABEL $C861 Storage for base frequency of each channel (3 words)
LABEL $C867 Vec_Expl_Flag
COMMENT_LABEL $C867 Explosion_Snd initialization flag?
LABEL $C877 Vec_Expl_Timer
COMMENT_LABEL $C877 Used by Explosion_Snd
LABEL $C879 Vec_Num_Players
COMMENT_LABEL $C879 Number of players selected in Select_Game
LABEL $C87A Vec_Num_Game
COMMENT_LABEL $C87A Game number selected in Select_Game
LABEL $C87B Vec_Seed_Ptr
COMMENT_LABEL $C87B Pointer to 3-byte random number seed (=$C87D)
LABEL $C87D Vec_Random_Seed
COMMENT_LABEL $C87D Default 3-byte random number seed
LABEL $CBEA Vec_Default_Stk
COMMENT_LABEL $CBEA Default top-of-stack
LABEL $CBEB Vec_High_Score
COMMENT_LABEL $CBEB High score storage (7 bytes)
LABEL $CBF2 Vec_SWI3_Vector
COMMENT_LABEL $CBF2 SWI2/SWI3 interrupt vector (3 bytes)
LABEL $CBF2 Vec_SWI2_Vector
COMMENT_LABEL $CBF2 SWI2/SWI3 interrupt vector (3 bytes)
LABEL $CBF5 Vec_FIRQ_Vector
COMMENT_LABEL $CBF5 FIRQ interrupt vector (3 bytes)
LABEL $CBF8 Vec_IRQ_Vector
COMMENT_LABEL $CBF8 IRQ interrupt vector (3 bytes)
LABEL $CBFB Vec_SWI_Vector
COMMENT_LABEL $CBFB SWI/NMI interrupt vector (3 bytes)
LABEL $CBFB Vec_NMI_Vector
COMMENT_LABEL $CBFB SWI/NMI interrupt vector (3 bytes)
LABEL $CBFE Vec_Cold_Flag
COMMENT_LABEL $CBFE Cold start flag (warm start if = $7321)
LABEL $D000 VIA_port_b
COMMENT_LABEL $D000 VIA port B data I/O register
LABEL $D001 VIA_port_a
COMMENT_LABEL $D001 VIA port A data I/O register (handshaking)
LABEL $D002 VIA_DDR_b
COMMENT_LABEL $D002 VIA port B data direction register (0=input 1=output)
LABEL $D003 VIA_DDR_a
COMMENT_LABEL $D003 VIA port A data direction register (0=input 1=output)
LABEL $D004 VIA_t1_cnt_lo
COMMENT_LABEL $D004 VIA timer 1 count register lo (scale factor)
LABEL $D005 VIA_t1_cnt_hi
COMMENT_LABEL $D005 VIA timer 1 count register hi
LABEL $D006 VIA_t1_lch_lo
COMMENT_LABEL $D006 VIA timer 1 latch register lo
LABEL $D007 VIA_t1_lch_hi
COMMENT_LABEL $D007 VIA timer 1 latch register hi
LABEL $D008 VIA_t2_lo
COMMENT_LABEL $D008 VIA timer 2 count/latch register lo (refresh)
LABEL $D009 VIA_t2_hi
COMMENT_LABEL $D009 VIA timer 2 count/latch register hi
LABEL $D00A VIA_shift_reg
COMMENT_LABEL $D00A VIA shift register
LABEL $D00B VIA_aux_cntl
COMMENT_LABEL $D00B VIA auxiliary control register
LABEL $D00C VIA_cntl
COMMENT_LABEL $D00C VIA control register
LABEL $D00D VIA_int_flags
COMMENT_LABEL $D00D VIA interrupt flags register
LABEL $D00E VIA_int_enable
COMMENT_LABEL $D00E VIA interrupt enable register
LABEL $D00F VIA_port_a_nohs
COMMENT_LABEL $D00F VIA port A data I/O register (no handshaking)
LABEL $F000 Start
LABEL $F18B Init_OS
LABEL $F06C Warm_Start
LABEL $F84F Clear_Score
LABEL $F01C LF01C
LABEL $F1AF DP_to_C8
LABEL $F029 LF029
LABEL $F0FD DF0FD
LABEL $FD0D Intro_Music
LABEL $F687 Init_Music_chk
LABEL $F192 Wait_Recal
LABEL $F289 Do_Sound
LABEL $F2A9 Intensity_7F
LABEL $F10C Vec_Title
LABEL $F052 LF052
LABEL $F118 Vec_Title_2
LABEL $F385 Print_List_hw
LABEL $F0E9 Intro_Boxes
LABEL $F058 LF058
LABEL $F308 Moveto_ix_FF
LABEL $F434 Draw_Pat_VL_a
LABEL $F101 Copyright_Str
LABEL $F084 LF084
LABEL $F097 LF097
LABEL $F092 LF092
LABEL $F09E LF09E
LABEL $F0A4 LF0A4
LABEL $F37A Print_Str_d
LABEL $F0D2 LF0D2
LABEL $F10C here__
EQU $0B Copyright_Len
LABEL $F14C Init_VIA
LABEL $F1AA DP_to_D0
LABEL $F354 Reset0Ref
LABEL $F1A2 Set_Refresh
LABEL $F164 Init_OS_RAM
LABEL $F53F Clear_x_b
LABEL $F173 LF173
LABEL $F272 Clear_Sound
LABEL $F19E LF19E
LABEL $F2E6 Recalibrate
LABEL $F1B4 Read_Btns_Mask
LABEL $F1BA Read_Btns
LABEL $F1EA LF1EA
LABEL $F1F5 Joy_Analog
LABEL $F1F8 Joy_Digital
LABEL $F1FB LF1FB
LABEL $F20B LF20B
LABEL $F1FF LF1FF
LABEL $F213 LF213
LABEL $F240 LF240
LABEL $F22D LF22D
LABEL $F236 LF236
LABEL $F235 LF235
LABEL $F23A LF23A
LABEL $F24C LF24C
LABEL $F256 Sound_Byte
LABEL $F259 Sound_Byte_x
LABEL $F25B Sound_Byte_raw
LABEL $F275 LF275
LABEL $F533 Init_Music_Buf
LABEL $F27D Sound_Bytes
LABEL $F284 Sound_Bytes_x
LABEL $F282 LF282
LABEL $F28C Do_Sound_x
LABEL $F291 LF291
LABEL $F299 LF299
LABEL $F29D Intensity_1F
LABEL $F2AB Intensity_a
LABEL $F2A1 Intensity_3F
LABEL $F2A5 Intensity_5F
LABEL $F2BE Dot_ix_b
LABEL $F2C1 Dot_ix
LABEL $F2C3 Dot_d
LABEL $F312 Moveto_d
LABEL $F2C5 Dot_here
LABEL $F2CC LF2CC
LABEL $F2D2 LF2D2
LABEL $F2D5 Dot_List
LABEL $F2DE Dot_List_Reset
LABEL $F9F0 Recal_Points
LABEL $F36B Reset0Int
LABEL $F310 Moveto_ix
LABEL $F2F2 Moveto_x_7F
LABEL $F2FC Moveto_d_7F
LABEL $F318 LF318
LABEL $F30E Moveto_ix_b
LABEL $F30C Moveto_ix_7F
LABEL $F584 Abs_a_b
LABEL $F345 LF345
LABEL $F33B LF33B
LABEL $F33D LF33D
LABEL $F341 LF341
LABEL $F34A Reset0Ref_D0
LABEL $F34F Check0Ref
LABEL $F36A LF36A_RTS
LABEL $F35B Reset_Pen
LABEL $F373 Print_Str_hwyx
LABEL $F378 Print_Str_yx
LABEL $F575 Delay_1
LABEL $F495 Print_Str
LABEL $F383 LF383
LABEL $F38A Print_List
LABEL $F38C Print_List_Chk
LABEL $F391 Print_Ships_x
LABEL $F393 Print_Ships
LABEL $F3A3 LF3A3
LABEL $F3AD Mov_Draw_VLc_a
LABEL $F3B9 Mov_Draw_VL_a
LABEL $F3B1 Mov_Draw_VL_b
LABEL $F3BC Mov_Draw_VL
LABEL $F3B5 Mov_Draw_VLcs
LABEL $F3B7 Mov_Draw_VL_ab
LABEL $F3BE Mov_Draw_VL_d
LABEL $F3ED LF3ED
LABEL $F3CE Draw_VLc
LABEL $F3DA Draw_VL_a
LABEL $F3D2 Draw_VL_b
LABEL $F3DD Draw_VL
LABEL $F3D6 Draw_VLcs
LABEL $F3D8 Draw_VL_ab
LABEL $F3DF Draw_Line_d
LABEL $F3F4 LF3F4
LABEL $F404 Draw_VLp_FF
LABEL $F40E Draw_VLp_b
LABEL $F408 Draw_VLp_7F
LABEL $F40C Draw_VLp_scale
LABEL $F410 Draw_VLp
LABEL $F425 LF425
LABEL $F433 LF433
LABEL $F437 Draw_Pat_VL
LABEL $F439 Draw_Pat_VL_d
LABEL $F45C LF45C
LABEL $F459 LF459
LABEL $F46E Draw_VL_mode
LABEL $F476 LF476
LABEL $F47E LF47E
LABEL $F485 LF485
LABEL $F48D LF48D
LABEL $F9F4 Char_Table
LABEL $F4A5 LF4A5
LABEL $F4CB LF4CB
LABEL $F4C7 LF4C7
LABEL $FBD4 Char_Table_End
LABEL $F50A LF50A
LABEL $F4EB LF4EB
LABEL $F511 Random_3
LABEL $F51A LF51A
LABEL $F517 Random
LABEL $F51D LF51D
LABEL $F548 Clear_x_d
LABEL $F542 Clear_C8_RAM
LABEL $F545 Clear_x_256
LABEL $F550 Clear_x_b_80
LABEL $F552 Clear_x_b_a
LABEL $F55A Dec_3_Counters
LABEL $F560 LF560
LABEL $F55E Dec_6_Counters
LABEL $F563 Dec_Counters
LABEL $F569 LF569
LABEL $F56D Delay_3
LABEL $F57A Delay_b
LABEL $F571 Delay_2
LABEL $F579 Delay_0
LABEL $F57D Delay_RTS
LABEL $F57E Bitmask_a
LABEL $F9DC Bit_Masks
LABEL $F58B Abs_b
LABEL $F592 LF592
LABEL $F593 Rise_Run_Angle
LABEL $F5B2 LF5B2
LABEL $F5B0 LF5B0
LABEL $FC24 DFC24
LABEL $FC2C DFC2C
LABEL $F5D0 LF5D0
LABEL $F5D3 LF5D3
LABEL $F5D9 Get_Rise_Idx
LABEL $F5DB Get_Run_Idx
LABEL $FC6D DFC6D
LABEL $F5E5 LF5E5
LABEL $F5EC LF5EC
LABEL $F5EF Rise_Run_Idx
LABEL $F5FF Rise_Run_X
LABEL $F601 Rise_Run_Y
LABEL $F603 Rise_Run_Len
LABEL $F65D Xform_Run
LABEL $F663 Xform_Rise
LABEL $F610 Rot_VL_ab
LABEL $F616 Rot_VL
LABEL $F637 LF637
LABEL $F61F Rot_VL_Mode
LABEL $F62B Rot_VL_M_dft
LABEL $F635 LF635
LABEL $F661 Xform_Rise_a
LABEL $F65B Xform_Run_a
LABEL $F665 LF665
LABEL $F66F LF66F
LABEL $F679 LF679
LABEL $F676 LF676
LABEL $F67E LF67E
LABEL $F67F Move_Mem_a_1
LABEL $F683 Move_Mem_a
LABEL $F686 LF686
LABEL $F6B3 LF6B3
LABEL $F68D Init_Music
LABEL $FC8D Freq_Table
LABEL $F692 Init_Music_dft
LABEL $F6EC LF6EC
LABEL $F6B8 LF6B8
LABEL $F6C0 LF6C0
LABEL $F6CA LF6CA
LABEL $F6D2 LF6D2
LABEL $F74E LF74E
LABEL $F6E3 LF6E3
LABEL $F6EA LF6EA
LABEL $F712 LF712
LABEL $F9E4 Music_Table_1
LABEL $F735 LF735
LABEL $F9EA Music_Table_2
LABEL $F748 LF748
LABEL $F759 LF759
LABEL $F766 LF766
LABEL $F76D LF76D
LABEL $F778 LF778
LABEL $F788 LF788
LABEL $F78C LF78C
LABEL $F793 LF793_RTS
LABEL $F794 Player_Str
LABEL $F79F Game_Str
LABEL $F7A9 Select_Game
LABEL $F7B1 LF7B1
LABEL $F7B6 LF7B6
LABEL $F82C LF82C
LABEL $F7C5 LF7C5
LABEL $F835 Display_Option
LABEL $F7F1 LF7F1
LABEL $F810 LF810
LABEL $F80C LF80C
LABEL $F821 LF821
LABEL $F82A LF82A
LABEL $F84E LF84E
LABEL $F85E Add_Score_a
LABEL $F861 LF861
LABEL $F86D LF86D
LABEL $F878 LF878
LABEL $F87C Add_Score_d
LABEL $F882 LF882
LABEL $F897 LF897
LABEL $F88F LF88F
LABEL $F895 LF895
LABEL $F8A5 LF8A5
LABEL $F8AE LF8AE
LABEL $F8B7 Strip_Zeros
LABEL $F8C6 LF8C6
LABEL $F8C7 Compare_Score
LABEL $F8CA LF8CA
LABEL $F8D6 LF8D6
LABEL $F8D5 LF8D5
LABEL $F8D8 New_High_Score
LABEL $F8E4 LF8E4
LABEL $F8DE LF8DE
LABEL $F8E5 Obj_Will_Hit_u
LABEL $F8EF LF8EF
LABEL $F903 LF903
LABEL $F8F3 Obj_Will_Hit
LABEL $F8FF Obj_Hit
LABEL $F906 LF906
LABEL $F90F LF90F
LABEL $F928 LF928
LABEL $F91B LF91B
LABEL $F92A LF92A
LABEL $F92E Explosion_Snd
LABEL $F95B LF95B
LABEL $F968 LF968
LABEL $F9C9 LF9C9_RTS
LABEL $F9CA LF9CA
LABEL $F97D LF97D
LABEL $F97B LF97B
LABEL $F987 LF987
LABEL $F991 LF991
LABEL $F98F LF98F
LABEL $F9C2 LF9C2
LABEL $F997 LF997
LABEL $F99E LF99E
LABEL $F9BC LF9BC
LABEL $F9CF LF9CF
LABEL $F9DB LF9DB_RTS
LABEL $FEE8 DFEE8
LABEL $FEB6 DFEB6
LABEL $FD1D DFD1D
LABEL $FD69 DFD69
LABEL $FD79 DFD79
LABEL $FD81 DFD81
LABEL $FDC3 DFDC3
LABEL $FDD3 DFDD3
LABEL $FE28 DFE28
LABEL $FE38 DFE38
LABEL $FE66 DFE66
LABEL $FE76 DFE76
LABEL $FEB2 DFEB2
LABEL $FEC6 DFEC6
LABEL $FEF8 DFEF8
LABEL $FF16 DFF16
LABEL $FF26 DFF26
LABEL $FF44 DFF44
LABEL $FF62 DFF62
LABEL $FF7A DFF7A
LABEL $FF8F DFF8F
LABEL $FF9F Draw_Grid_VL
LABEL $FFAB LFFAB
LABEL $FFA3 LFFA3
LABEL $FFAE LFFAE
LABEL $0000 *
LABEL $F000 *xfer
COMMENT_LINE $0000 4 KB Bios
COMMENT_LINE $0000 can be assembled correctly now
COMMENT_LINE $0000 corrected and compatibilty added by Malban
COMMENT_LINE $0000 assemble with comand line:
COMMENT_LINE $0000 .\ass\as09.exe -w200 -h0 -l -mcti bios.asm >error
COMMENT_LINE $0000 used the 6809 assembler:
COMMENT_LINE $0000 as09 [1.11].
COMMENT_LINE $0000 Copyright 1990-1994, Frank A. Vorstenbosch, Kingswood Software.
COMMENT_LINE $0000 Available at:
COMMENT_LINE $0000 http://www.falstaff.demon.co.uk/cross.html
COMMENT_LINE $F000 -----------------------------------------------------------------------;
COMMENT_LINE $F000 This disassembly of the Vectrex ROM was done by Bruce Tomlin          ;
COMMENT_LINE $F000 (btomlin@aol.com), and is based in part on a disassembly done by      ;
COMMENT_LINE $F000 Fred Taft (fred@hp-pcd.cv.hp.com).                                    ;
COMMENT_LINE $F000 -----------------------------------------------------------------------;
COMMENT_LINE $F000 $C839   ;Pointer to copyright string during startup
COMMENT_LINE $F000 $C83B   ;High score cold-start flag (=0 if valid)
COMMENT_LINE $F000 $C83C   ;temp byte
COMMENT_LINE $F000 $C843   ;        register 9
COMMENT_LINE $F000 $C844   ;        register 8
COMMENT_LINE $F000 $C848   ;        register 4
COMMENT_LINE $F000 $C849   ;        register 3
COMMENT_LINE $F000 $C84A   ;        register 2
COMMENT_LINE $F000 $C84C   ;        register 0
COMMENT_LINE $F000 $C85E   ;Scratch 'score' storage for Display_Option (7 bytes)
COMMENT_LINE $F000 $C868...$C876   ;Unused?
COMMENT_LINE $F000 $C878   ;Unused?
COMMENT_LINE $F000 $C880 - $CBEA is user RAM  ;
COMMENT_LINE $F000 0 sample/hold (0=enable  mux 1=disable mux)
COMMENT_LINE $F000 1 mux sel 0
COMMENT_LINE $F000 2 mux sel 1
COMMENT_LINE $F000 3 sound BC1
COMMENT_LINE $F000 4 sound BDIR
COMMENT_LINE $F000 5 comparator input
COMMENT_LINE $F000 6 external device (slot pin 35) initialized to input
COMMENT_LINE $F000 7 /RAMP
COMMENT_LINE $F000 0 PA latch enable
COMMENT_LINE $F000 1 PB latch enable
COMMENT_LINE $F000 2 \                     110=output to CB2 under control of phase 2 clock
COMMENT_LINE $F000 3  > shift register control     (110 is the only mode used by the Vectrex ROM)
COMMENT_LINE $F000 4 /
COMMENT_LINE $F000 5 0=t2 one shot                 1=t2 free running
COMMENT_LINE $F000 6 0=t1 one shot                 1=t1 free running
COMMENT_LINE $F000 7 0=t1 disable PB7 output       1=t1 enable PB7 output
COMMENT_LINE $F000 0 CA1 control     CA1 -> SW7    0=IRQ on low 1=IRQ on high
COMMENT_LINE $F000 1 \
COMMENT_LINE $F000 2  > CA2 control  CA2 -> /ZERO  110=low 111=high
COMMENT_LINE $F000 3 /
COMMENT_LINE $F000 4 CB1 control     CB1 -> NC     0=IRQ on low 1=IRQ on high
COMMENT_LINE $F000 5 \
COMMENT_LINE $F000 6  > CB2 control  CB2 -> /BLANK 110=low 111=high
COMMENT_LINE $F000 7 /
COMMENT_LINE $F000 bit                             cleared by
COMMENT_LINE $F000 0 CA2 interrupt flag            reading or writing port A I/O
COMMENT_LINE $F000 1 CA1 interrupt flag            reading or writing port A I/O
COMMENT_LINE $F000 2 shift register interrupt flag reading or writing shift register
COMMENT_LINE $F000 3 CB2 interrupt flag            reading or writing port B I/O
COMMENT_LINE $F000 4 CB1 interrupt flag            reading or writing port A I/O
COMMENT_LINE $F000 5 timer 2 interrupt flag        read t2 low or write t2 high
COMMENT_LINE $F000 6 timer 1 interrupt flag        read t1 count low or write t1 high
COMMENT_LINE $F000 7 IRQ status flag               write logic 0 to IER or IFR bit
COMMENT_LINE $F000 0 CA2 interrupt enable
COMMENT_LINE $F000 1 CA1 interrupt enable
COMMENT_LINE $F000 2 shift register interrupt enable
COMMENT_LINE $F000 3 CB2 interrupt enable
COMMENT_LINE $F000 4 CB1 interrupt enable
COMMENT_LINE $F000 5 timer 2 interrupt enable
COMMENT_LINE $F000 6 timer 1 interrupt enable
COMMENT_LINE $F000 7 IER set/clear control
COMMENT_LINE $F000 -----------------------------------------------------------------------;
COMMENT_LINE $F000 F000    Start                                                   ;
COMMENT_LINE $F000 ;
COMMENT_LINE $F000 Jump here to restart the Vectrex and re-initialize the OS.  If the    ;
COMMENT_LINE $F000 cold start flag is correct (it should be unless you just turned the   ;
COMMENT_LINE $F000 Vectrex on), the cold start code is skipped.                          ;
COMMENT_LINE $F000 ;
COMMENT_LINE $F000 On cold start, the high score is cleared, and the power-on screen     ;
COMMENT_LINE $F000 is displayed with the power-on music.                                 ;
COMMENT_LINE $F000 -----------------------------------------------------------------------;
COMMENT $F000 Set up stack pointer
FORCE_SYMBOL $F000 Vec_Default_Stk
COMMENT $F004 Initialize system
FORCE_SYMBOL $F004 Init_OS
COMMENT $F007 Check cold start flag
FORCE_NO_SYMBOL $F007
FORCE_SYMBOL $F00A Vec_Cold_Flag
COMMENT $F00E Branch if warm start
COMMENT $F010 Initialize cold start flag
FORCE_SYMBOL $F010 Vec_Cold_Flag
COMMENT $F013 Set high score invalid flag
FORCE_NO_SYMBOL $F013
COMMENT $F016 Clear high score
FORCE_SYMBOL $F016 Vec_High_Score
FORCE_SYMBOL $F019 Clear_Score
COMMENT_LINE $F01C First power-up loop.  This prints the "VECTREX"
COMMENT_LINE $F01C power-on screen and plays the power-on music.
COMMENT $F01C DP to RAM
FORCE_SYMBOL $F01C DP_to_C8
COMMENT $F01F When we have looped 257 times,
FORCE_SYMBOL $F01F Vec_Loop_Count
FORCE_NO_SYMBOL $F021
COMMENT $F027 start the intro music
FORCE_SYMBOL $F027 Vec_Music_Flag
COMMENT_LINE $F029 Get the line pattern for the boundary box lines
COMMENT $F029 Get line pattern from table
FORCE_NO_SYMBOL $F02A
FORCE_SYMBOL $F02C DF0FD
COMMENT $F031 Store pattern
FORCE_SYMBOL $F031 Vec_Pattern
COMMENT $F033 Set up counter for two boxes
FORCE_NO_SYMBOL $F033
FORCE_NO_SYMBOL $F035
COMMENT_LINE $F037 Play the intro music
COMMENT $F037 Get address of music
FORCE_SYMBOL $F037 Intro_Music
COMMENT $F03A Initialize the music
FORCE_SYMBOL $F03A Init_Music_chk
COMMENT $F03D Wait for next frame
FORCE_SYMBOL $F03D Wait_Recal
COMMENT $F040 Play music if active
FORCE_SYMBOL $F040 Do_Sound
COMMENT_LINE $F043 Display power-up message
COMMENT $F043 Normal brightness
FORCE_SYMBOL $F043 Intensity_7F
COMMENT $F046 Alternate size every 32 loops
FORCE_NO_SYMBOL $F046
COMMENT $F049 Load address of double high text
FORCE_SYMBOL $F049 Vec_Title
FORCE_NO_SYMBOL $F04C
COMMENT $F050 Skip double high text
COMMENT $F052 Print startup text
FORCE_SYMBOL $F052 Print_List_hw
COMMENT_LINE $F055 Draw the frame boxes
FORCE_SYMBOL $F055 Intro_Boxes
COMMENT $F058 Move to start of line
FORCE_SYMBOL $F058 Moveto_ix_FF
COMMENT $F05B Draw 4 lines
FORCE_NO_SYMBOL $F05B
FORCE_SYMBOL $F05D Draw_Pat_VL_a
COMMENT $F060 Go back for next box
FORCE_NO_SYMBOL $F060
FORCE_SYMBOL $F065 Vec_Loop_Count
COMMENT $F068 Repeat for 512 counts
FORCE_NO_SYMBOL $F068
COMMENT_LINE $F06C -----------------------------------------------------------------------;
COMMENT_LINE $F06C F06C    Warm_Start                                              ;
COMMENT_LINE $F06C ;
COMMENT_LINE $F06C Jump here to restart the Vectrex without re-initializing the OS.      ;
COMMENT_LINE $F06C -----------------------------------------------------------------------;
COMMENT_LINE $F06C Prepare for ROM check
COMMENT $F06C DP to RAM
FORCE_SYMBOL $F06C DP_to_C8
COMMENT $F06F Set new line pattern
FORCE_NO_SYMBOL $F06F
FORCE_SYMBOL $F071 Vec_Pattern
COMMENT $F073 Save copyright string addr
FORCE_SYMBOL $F073 Copyright_Str
FORCE_NO_SYMBOL $F076
COMMENT $F078 Clear loop counter
FORCE_SYMBOL $F078 Vec_Loop_Count
COMMENT_LINE $F07C Check for valid cartridge ROM
COMMENT $F07C Look at address zero
FORCE_NO_SYMBOL $F07C
FORCE_SYMBOL $F07F Copyright_Str
COMMENT $F082 11 bytes long
FORCE_NO_SYMBOL $F082
COMMENT $F084 Compare next byte
COMMENT $F088 Okay if match
COMMENT $F08A Not okay if last byte wrong
FORCE_NO_SYMBOL $F08A
COMMENT $F08E Okay if date wrong
FORCE_NO_SYMBOL $F08E
COMMENT $F092 Bad cart; load Mine Storm addr
FORCE_NO_SYMBOL $F092
COMMENT $F097 Go back for next byte
COMMENT $F09A Store zero as address of
FORCE_NO_SYMBOL $F09A
COMMENT $F09C copyright string
FORCE_NO_SYMBOL $F09C
COMMENT_LINE $F09E Prepare to play game start-up music
COMMENT $F09E Set music enable flag
FORCE_SYMBOL $F09E Vec_Music_Flag
COMMENT $F0A0 Save address of header
FORCE_SYMBOL $F0A0 Vec_Run_Index
COMMENT $F0A2 Get address of music
FORCE_NO_SYMBOL $F0A2
COMMENT_LINE $F0A4 Second power-up loop.  This prints the name of the
COMMENT_LINE $F0A4 game, the copyright, and plays the start-up music
COMMENT $F0A4 DP to RAM
FORCE_SYMBOL $F0A4 DP_to_C8
COMMENT $F0A7 ???
FORCE_NO_SYMBOL $F0A7
FORCE_SYMBOL $F0AA Vec_Text_HW
COMMENT $F0AC Initialize the music
FORCE_SYMBOL $F0AC Init_Music_chk
COMMENT $F0AF Wait for next frame
FORCE_SYMBOL $F0AF Wait_Recal
COMMENT $F0B2 Play the music if active
FORCE_SYMBOL $F0B2 Do_Sound
COMMENT_LINE $F0B5 Display cartridge GCE copyright string
COMMENT $F0B5 Normal brightness
FORCE_SYMBOL $F0B5 Intensity_7F
COMMENT $F0B8 Print copyright string
FORCE_NO_SYMBOL $F0B8
FORCE_NO_SYMBOL $F0BB
FORCE_SYMBOL $F0BE Print_Str_d
COMMENT_LINE $F0C1 Display current high score if any
COMMENT $F0C1 Skip if no high score
FORCE_NO_SYMBOL $F0C1
FORCE_SYMBOL $F0C7 Vec_High_Score
FORCE_NO_SYMBOL $F0CA
FORCE_NO_SYMBOL $F0CC
FORCE_SYMBOL $F0CF Print_Str_d
COMMENT_LINE $F0D2 Display cartridge name
COMMENT $F0D2 Get cartridge header addr
FORCE_SYMBOL $F0D2 Vec_Run_Index
COMMENT $F0D5 Skip music addr
FORCE_NO_SYMBOL $F0D5
COMMENT $F0D7 Print it
FORCE_SYMBOL $F0D7 Print_List_hw
COMMENT $F0DA Go back if music still playing
FORCE_SYMBOL $F0DA Vec_Music_Flag
COMMENT $F0DF Go back if count less than 126
FORCE_SYMBOL $F0DF Vec_Loop_Count
FORCE_NO_SYMBOL $F0E2
COMMENT $F0E7 Jump into cartridge
FORCE_NO_SYMBOL $F0E7
COMMENT_LINE $F0E9 Outer box (y,x)
COMMENT_LINE $F0F3 Inner box (y,x)
COMMENT_LINE $F0FD Line patterns for boundary boxes
COMMENT_LINE $F101 Copyright string
COMMENT_LINE $F10C Title strings
COMMENT $F10C Height, width
COMMENT $F10E Y,X
COMMENT $F118 Height, width
COMMENT $F11A Y,X
COMMENT $F124 Height, width
COMMENT $F126 Y,X
COMMENT $F12C Height, width
COMMENT $F12E Y,X
COMMENT $F13D Height, width
COMMENT $F13F Y,X
COMMENT_LINE $F14C -----------------------------------------------------------------------;
COMMENT_LINE $F14C F14C    Init_VIA                                                ;
COMMENT_LINE $F14C ;
COMMENT_LINE $F14C This routine is invoked during powerup, to initialize the VIA chip.   ;
COMMENT_LINE $F14C Among other things, it initializes the scale factor to 0x7F, and      ;
COMMENT_LINE $F14C sets up the direction for the port A and B data lines.                ;
COMMENT_LINE $F14C ;
COMMENT_LINE $F14C EXIT: DP = $D0                                                        ;
COMMENT_LINE $F14C ;
COMMENT_LINE $F14C D-reg, X-reg trashed                                            ;
COMMENT_LINE $F14C -----------------------------------------------------------------------;
COMMENT $F14E Port A=all output
FORCE_NO_SYMBOL $F14E
COMMENT $F151 Port B=OIIOOOOO
FORCE_SYMBOL $F151 VIA_DDR_b
COMMENT $F153 Port B sound BDIR=1
FORCE_NO_SYMBOL $F153
FORCE_SYMBOL $F156 VIA_port_b
COMMENT $F158 ACR=$98 T1->PB7 enabled
FORCE_NO_SYMBOL $F158
COMMENT $F15B auxiliary control register
FORCE_SYMBOL $F15B VIA_aux_cntl
COMMENT $F15D T1CL=$7F scale factor?
FORCE_SYMBOL $F15D VIA_t1_cnt_lo
FORCE_SYMBOL $F15F Reset0Ref
COMMENT_LINE $F164 -----------------------------------------------------------------------;
COMMENT_LINE $F164 F164    Init_OS_RAM                                             ;
COMMENT_LINE $F164 ;
COMMENT_LINE $F164 This routine first clears the block of RAM in the range $C800 to      ;
COMMENT_LINE $F164 $C87A, and then it initializes the dot dwell time, the refresh time,  ;
COMMENT_LINE $F164 and the joystick enable flags.                                        ;
COMMENT_LINE $F164 ;
COMMENT_LINE $F164 EXIT: DP = $C8                                                        ;
COMMENT_LINE $F164 ;
COMMENT_LINE $F164 D-reg, X-reg trashed                                            ;
COMMENT_LINE $F164 -----------------------------------------------------------------------;
COMMENT $F164 DP to RAM
COMMENT $F166 Clear $C800-$C87A
FORCE_NO_SYMBOL $F166
FORCE_NO_SYMBOL $F168
FORCE_SYMBOL $F16B Clear_x_b
COMMENT $F16E Point $C87B to $C87D
FORCE_SYMBOL $F16E Vec_Random_Seed
FORCE_SYMBOL $F171 Vec_Seed_Ptr
COMMENT $F173 Make sure random number
FORCE_SYMBOL $F173 Vec_Random_Seed
COMMENT $F175 seed is non-zero!
COMMENT $F177 Init dot dwell (brightness)
FORCE_NO_SYMBOL $F177
FORCE_SYMBOL $F179 Vec_Dot_Dwell
COMMENT $F17B Init refresh time to $7530
FORCE_NO_SYMBOL $F17B
FORCE_NO_SYMBOL $F17E
COMMENT $F180 Init joystick enable flags
FORCE_NO_SYMBOL $F180
FORCE_SYMBOL $F183 Vec_Joy_Mux_1_X
FORCE_NO_SYMBOL $F185
FORCE_SYMBOL $F188 Vec_Joy_Mux_2_X
COMMENT_LINE $F18B -----------------------------------------------------------------------;
COMMENT_LINE $F18B F18B    Init_OS                                                 ;
COMMENT_LINE $F18B ;
COMMENT_LINE $F18B This routine is responsible for setting up the initial system state,  ;
COMMENT_LINE $F18B each time the system is either reset or powered up.  It will          ;
COMMENT_LINE $F18B initialize the OS RAM area, initialize the VIA chip, and then clear   ;
COMMENT_LINE $F18B all the registers on the sound chip.                                  ;
COMMENT_LINE $F18B ;
COMMENT_LINE $F18B EXIT: DP = $D0                                                        ;
COMMENT_LINE $F18B ;
COMMENT_LINE $F18B D-reg, X-reg trashed                                            ;
COMMENT_LINE $F18B -----------------------------------------------------------------------;
FORCE_SYMBOL $F18F Clear_Sound
COMMENT_LINE $F192 -----------------------------------------------------------------------;
COMMENT_LINE $F192 F192    Wait_Recal                                              ;
COMMENT_LINE $F192 ;
COMMENT_LINE $F192 Wait for t2 (the refresh timer) to timeout, then restart it using     ;
COMMENT_LINE $F192 the value in $C83D.  then, recalibrate the vector generators to the   ;
COMMENT_LINE $F192 origin (0,0).  This routine MUST be called once every refresh         ;
COMMENT_LINE $F192 cycle, or your vectors will get out of whack.  This routine calls     ;
COMMENT_LINE $F192 Reset0Ref, so the integrators are left in zero mode.                  ;
COMMENT_LINE $F192 ;
COMMENT_LINE $F192 EXIT: DP = $D0                                                        ;
COMMENT_LINE $F192 ;
COMMENT_LINE $F192 D-reg, X-reg trashed                                            ;
COMMENT_LINE $F192 -----------------------------------------------------------------------;
COMMENT $F192 Increment loop counter
FORCE_SYMBOL $F192 Vec_Loop_Count
FORCE_NO_SYMBOL $F195
FORCE_SYMBOL $F197 Vec_Loop_Count
COMMENT $F19A DP to I/O
FORCE_NO_SYMBOL $F19C
COMMENT $F19E Wait for timer t2
FORCE_SYMBOL $F19E VIA_int_flags
COMMENT_LINE $F1A2 -----------------------------------------------------------------------;
COMMENT_LINE $F1A2 F1A2    Set_Refresh                                             ;
COMMENT_LINE $F1A2 ;
COMMENT_LINE $F1A2 This routine loads the refresh timer (t2) with the value in $C83D-    ;
COMMENT_LINE $F1A2 $C83E, and recalibrates the vector generators, thus causing the pen   ;
COMMENT_LINE $F1A2 to be left at the origin (0,0).  The high order byte for the timer    ;
COMMENT_LINE $F1A2 is loaded from $C83E, and the low order byte is loaded from $C83D.    ;
COMMENT_LINE $F1A2 The refresh rate is calculated as follows:                            ;
COMMENT_LINE $F1A2 ;
COMMENT_LINE $F1A2 rate = (C83E)(C83D) / 1.5 mhz                                       ;
COMMENT_LINE $F1A2 ;
COMMENT_LINE $F1A2 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F1A2 ;
COMMENT_LINE $F1A2 D-reg trashed                                           ;
COMMENT_LINE $F1A2 -----------------------------------------------------------------------;
COMMENT $F1A2 Store refresh value
FORCE_NO_SYMBOL $F1A2
COMMENT $F1A5 into timer t2
FORCE_SYMBOL $F1A5 VIA_t2_lo
FORCE_SYMBOL $F1A7 Recalibrate
COMMENT_LINE $F1AA -----------------------------------------------------------------------;
COMMENT_LINE $F1AA F1AA    DP_to_D0                                                ;
COMMENT_LINE $F1AA ;
COMMENT_LINE $F1AA Sets the DP register to $D0, so that all direct page addressing will  ;
COMMENT_LINE $F1AA start at $D000 (the hardware I/O area).                               ;
COMMENT_LINE $F1AA ;
COMMENT_LINE $F1AA EXIT: DP = $D0                                                        ;
COMMENT_LINE $F1AA A-reg = $D0                                                     ;
COMMENT_LINE $F1AA -----------------------------------------------------------------------;
FORCE_NO_SYMBOL $F1AA
COMMENT_LINE $F1AF -----------------------------------------------------------------------;
COMMENT_LINE $F1AF F1AF    DP_to_C8                                                ;
COMMENT_LINE $F1AF ;
COMMENT_LINE $F1AF Sets the DP register to $C8, so that all direct page addressing will  ;
COMMENT_LINE $F1AF start at $C800 (OS RAM area).                                         ;
COMMENT_LINE $F1AF ;
COMMENT_LINE $F1AF ;
COMMENT_LINE $F1AF EXIT: DP = $C8                                                        ;
COMMENT_LINE $F1AF A-reg = $C8                                                     ;
COMMENT_LINE $F1AF -----------------------------------------------------------------------;
FORCE_NO_SYMBOL $F1AF
COMMENT_LINE $F1B4 -----------------------------------------------------------------------;
COMMENT_LINE $F1B4 F1B4    Read_Btns_Mask                                          ;
COMMENT_LINE $F1B4 F1BA    Read_Btns                                               ;
COMMENT_LINE $F1B4 ;
COMMENT_LINE $F1B4 Both of these routines read the button states on the two joysticks,   ;
COMMENT_LINE $F1B4 and return their state in the following RAM locations:                ;
COMMENT_LINE $F1B4 ;
COMMENT_LINE $F1B4 joystick 1, button 1:  $C812 = $01                              ;
COMMENT_LINE $F1B4 button 2:  $C813 = $02                              ;
COMMENT_LINE $F1B4 button 3:  $C814 = $04                              ;
COMMENT_LINE $F1B4 button 4:  $C815 = $08                              ;
COMMENT_LINE $F1B4 joystick 2, button 1:  $C816 = $10                              ;
COMMENT_LINE $F1B4 button 2:  $C817 = $20                              ;
COMMENT_LINE $F1B4 button 3:  $C818 = $40                              ;
COMMENT_LINE $F1B4 button 4:  $C819 = $80                              ;
COMMENT_LINE $F1B4 ;
COMMENT_LINE $F1B4 C80F: Contains current state of all buttons;                    ;
COMMENT_LINE $F1B4 1 = depressed, 0 = not depressed                          ;
COMMENT_LINE $F1B4 ;
COMMENT_LINE $F1B4 C810: Contains state of all buttons from LAST time these        ;
COMMENT_LINE $F1B4 routines were called; if Read_Btns_Mask was called,       ;
COMMENT_LINE $F1B4 then this is AND'ed with the passed in mask.              ;
COMMENT_LINE $F1B4 ;
COMMENT_LINE $F1B4 C811: Contains the same information as $C812-$C819              ;
COMMENT_LINE $F1B4 ;
COMMENT_LINE $F1B4 Bit 7                                     Bit 0                ;
COMMENT_LINE $F1B4 +-----+-----+-----+-----+-----+-----+-----+-----+               ;
COMMENT_LINE $F1B4 | 2.4 | 2.3 | 2.2 | 2.1 | 1.4 | 2.3 | 1.2 | 1.1 |               ;
COMMENT_LINE $F1B4 +-----+-----+-----+-----+-----+-----+-----+-----+               ;
COMMENT_LINE $F1B4 ;
COMMENT_LINE $F1B4 If Read_Btns is called, the result will be the same as Read_Btns_Mask ;
COMMENT_LINE $F1B4 with a mask of $FF, and a 1 will only be returned if the button       ;
COMMENT_LINE $F1B4 has transitioned to being pressed.                                    ;
COMMENT_LINE $F1B4 ;
COMMENT_LINE $F1B4 If Read_Btns_Mask is called, then a mask, passed in in the A-reg      ;
COMMENT_LINE $F1B4 will be used to determine how the button state info is returned:      ;
COMMENT_LINE $F1B4 ;
COMMENT_LINE $F1B4 If a bit is 0, then the current state of the button is to be returned ;
COMMENT_LINE $F1B4 in the appropriate RAM location; 0 = not pressed, and 1 = pressed.    ;
COMMENT_LINE $F1B4 ;
COMMENT_LINE $F1B4 If a bit is 1, then the appropriate RAM location is = to 1 only     ;
COMMENT_LINE $F1B4 on the depression transition of the button; additional calls will     ;
COMMENT_LINE $F1B4 return 0, until the button is released and then depressed again.      ;
COMMENT_LINE $F1B4 ;
COMMENT_LINE $F1B4 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F1B4 A-reg = mask (for Read_Btns_Mask only)                          ;
COMMENT_LINE $F1B4 ;
COMMENT_LINE $F1B4 Exit: A-reg = button transition state (same as $C811)                 ;
COMMENT_LINE $F1B4 ;
COMMENT_LINE $F1B4 B-reg, X-reg trashed                                            ;
COMMENT_LINE $F1B4 -----------------------------------------------------------------------;
COMMENT $F1B4 Mask out "always" buttons
FORCE_SYMBOL $F1B4 Vec_Btn_State
FORCE_SYMBOL $F1B7 Vec_Btn_State
COMMENT $F1BA Point to button flags
FORCE_SYMBOL $F1BA Vec_Button_1_1
COMMENT $F1BD Save previous state
COMMENT $F1C1 Sound chip register 0E to port A
FORCE_NO_SYMBOL $F1C1
FORCE_SYMBOL $F1C3 VIA_port_a
COMMENT $F1C5 sound BDIR on, BC1 on, mux off
FORCE_NO_SYMBOL $F1C5
FORCE_SYMBOL $F1C8 VIA_port_b
COMMENT $F1CA pause
COMMENT $F1CB sound BDIR off, BC1 off, mux off
FORCE_SYMBOL $F1CB VIA_port_b
COMMENT $F1CD DDR A to input
FORCE_SYMBOL $F1CD VIA_DDR_a
COMMENT $F1CF sound BDIR off, BC1 on, mux off
FORCE_NO_SYMBOL $F1CF
FORCE_SYMBOL $F1D2 VIA_port_b
COMMENT $F1D4 pause
COMMENT $F1D5 Read buttons
FORCE_SYMBOL $F1D5 VIA_port_a
COMMENT $F1D7 Convert to active high
COMMENT $F1D8 Save buttons
COMMENT $F1DA sound BDIR off, BC1 off, mux off
FORCE_SYMBOL $F1DA VIA_port_b
FORCE_NO_SYMBOL $F1DC
COMMENT $F1DE DDR A to output
FORCE_SYMBOL $F1DE VIA_DDR_a
COMMENT $F1E0 Check for transitions
COMMENT $F1E4 Store transition result
COMMENT $F1E6 Save result for return value
COMMENT $F1E8 Initialize bit position
FORCE_NO_SYMBOL $F1E8
COMMENT $F1EA Mask out bit
FORCE_NO_SYMBOL $F1EC
COMMENT $F1EE Store masked bit
COMMENT $F1F0 Go back for next bit
COMMENT $F1F3 Get back transition bits and return
COMMENT_LINE $F1F5 -----------------------------------------------------------------------;
COMMENT_LINE $F1F5 F1F5    Joy_Analog                                              ;
COMMENT_LINE $F1F5 F1F8    Joy_Digital                                             ;
COMMENT_LINE $F1F5 ;
COMMENT_LINE $F1F5 These routines read the current positions of the two joysticks.       ;
COMMENT_LINE $F1F5 ;
COMMENT_LINE $F1F5 The joystick enable flags (C81F-C822) must be initialized to one of   ;
COMMENT_LINE $F1F5 the following values:                                                 ;
COMMENT_LINE $F1F5 ;
COMMENT_LINE $F1F5 0 - ignore; return no value.                                    ;
COMMENT_LINE $F1F5 1 - return state of console 1 left/right position.              ;
COMMENT_LINE $F1F5 3 - return state of console 1 up/down position.                 ;
COMMENT_LINE $F1F5 5 - return state of console 2 left/right position.              ;
COMMENT_LINE $F1F5 7 - return state of console 2 up/down position.                 ;
COMMENT_LINE $F1F5 ;
COMMENT_LINE $F1F5 The joystick values are returned in $C81B-$C81E, where the value      ;
COMMENT_LINE $F1F5 returned in $C81B corresponds to the mask = in in $C81F, and so     ;
COMMENT_LINE $F1F5 on and so forth.                                                      ;
COMMENT_LINE $F1F5 ;
COMMENT_LINE $F1F5 The joystick conversion is dependent on which routine is called.      ;
COMMENT_LINE $F1F5 Results for each routine are:                                         ;
COMMENT_LINE $F1F5 ;
COMMENT_LINE $F1F5 Joy_Digital:                                                    ;
COMMENT_LINE $F1F5 The return value will be:                               ;
COMMENT_LINE $F1F5 < 0 if joystick is left of down of center.            ;
COMMENT_LINE $F1F5 = 0 if joystick is centered.                          ;
COMMENT_LINE $F1F5 > 0 if joystick is right or up of center.             ;
COMMENT_LINE $F1F5 ;
COMMENT_LINE $F1F5 Joy_Analog:                                                     ;
COMMENT_LINE $F1F5 A successive approximation algorithm is used to read    ;
COMMENT_LINE $F1F5 the actual value of the joystick pot, a signed value.   ;
COMMENT_LINE $F1F5 In this case, $C81A must be = to a power of 2, to     ;
COMMENT_LINE $F1F5 to control conversion resolution; 0x80 is least         ;
COMMENT_LINE $F1F5 accurate, and 0x00is most accurate.                     ;
COMMENT_LINE $F1F5 ;
COMMENT_LINE $F1F5 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F1F5 ;
COMMENT_LINE $F1F5 D-reg, X-reg trashed                                            ;
COMMENT_LINE $F1F5 -----------------------------------------------------------------------;
COMMENT $F1F5 Set analog mode flag
FORCE_NO_SYMBOL $F1F5
COMMENT $F1F8 Point to first pot
FORCE_SYMBOL $F1F8 Vec_Joy_Mux_1_X
COMMENT $F1FB Read it if enabled
COMMENT $F1FF Go back untl all pots read
FORCE_NO_SYMBOL $F1FF
COMMENT $F204 X points to $C823, clear it
FORCE_NO_SYMBOL $F204
FORCE_NO_SYMBOL $F206
COMMENT $F208 disable mux
FORCE_SYMBOL $F208 VIA_port_b
COMMENT $F20B enable mux and select pot
FORCE_SYMBOL $F20B VIA_port_b
COMMENT $F20D output $00 to D/A
FORCE_SYMBOL $F20D VIA_port_a
COMMENT $F20F disable mux
FORCE_SYMBOL $F20F VIA_port_b
COMMENT $F211 delay and end up with B=$80
FORCE_NO_SYMBOL $F211
COMMENT $F216 check analog flag
FORCE_NO_SYMBOL $F216
COMMENT $F219 branch if analog pot
FORCE_NO_SYMBOL $F21B
COMMENT $F21D enable mux
FORCE_SYMBOL $F21D VIA_port_b
COMMENT $F21F test comparator
FORCE_SYMBOL $F21F VIA_port_b
COMMENT $F223 output $40 to D/A
FORCE_NO_SYMBOL $F223
FORCE_SYMBOL $F225 VIA_port_a
COMMENT $F227 test comparator
FORCE_SYMBOL $F227 VIA_port_b
COMMENT $F22D output $C0 to D/A
FORCE_NO_SYMBOL $F22D
FORCE_SYMBOL $F22F VIA_port_a
COMMENT $F231 test comparator
FORCE_SYMBOL $F231 VIA_port_b
COMMENT $F236 store A/D result
COMMENT $F238 go back for next pot
FORCE_SYMBOL $F23C VIA_port_a
FORCE_SYMBOL $F23E VIA_port_a
COMMENT $F240 test comparator
FORCE_NO_SYMBOL $F240
FORCE_SYMBOL $F242 VIA_port_b
COMMENT $F244 branch to go lower?
FORCE_SYMBOL $F248 VIA_port_a
FORCE_SYMBOL $F24A VIA_port_a
COMMENT $F24C try next bit position
COMMENT $F24D check for accuracy threshold
FORCE_SYMBOL $F24D Vec_Joy_Resltn
COMMENT $F250 go back if not finished
COMMENT $F252 read D/A value
FORCE_SYMBOL $F252 VIA_port_a
COMMENT $F254 go back to store it
COMMENT_LINE $F256 -----------------------------------------------------------------------;
COMMENT_LINE $F256 F256    Sound_Byte                                              ;
COMMENT_LINE $F256 F259    Sound_Byte_x                                            ;
COMMENT_LINE $F256 F25B    Sound_Byte_raw                                          ;
COMMENT_LINE $F256 ;
COMMENT_LINE $F256 All of these routines cause a byte of music data to be written to     ;
COMMENT_LINE $F256 the music chip.  Sound_Byte stores a shadow copy of the data into     ;
COMMENT_LINE $F256 $C800-$C80E, and Sound_Byte_x stores a shadow copy into a 15 byte     ;
COMMENT_LINE $F256 area pointed to by the X register.  Sound_Byte_raw does not store a   ;
COMMENT_LINE $F256 shadow copy of the data at all.                                       ;
COMMENT_LINE $F256 ;
COMMENT_LINE $F256 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F256 A-reg = which of the 15 sound chip registers to modify          ;
COMMENT_LINE $F256 B-reg = the byte of sound data                                  ;
COMMENT_LINE $F256 X-reg = 15 byte shadow area (Sound_Byte_x only)                 ;
COMMENT_LINE $F256 ;
COMMENT_LINE $F256 EXIT: X-reg = $C800 (Sound_Byte only)                                 ;
COMMENT_LINE $F256 ;
COMMENT_LINE $F256 D-reg trashed                                                   ;
COMMENT_LINE $F256 -----------------------------------------------------------------------;
COMMENT $F256 point to shadow memory
FORCE_SYMBOL $F256 Vec_Snd_Shadow
COMMENT $F25B store register select byte
FORCE_SYMBOL $F25B VIA_port_a
COMMENT $F25D sound BDIR on, BC1 on, mux off
FORCE_NO_SYMBOL $F25D
FORCE_SYMBOL $F25F VIA_port_b
COMMENT $F261 sound BDIR off, BC1 off, mux off
FORCE_NO_SYMBOL $F261
FORCE_SYMBOL $F263 VIA_port_b
COMMENT $F265 read sound chip status (?)
FORCE_SYMBOL $F265 VIA_port_a
COMMENT $F267 store data byte
FORCE_SYMBOL $F267 VIA_port_a
COMMENT $F269 sound BDIR on, BC1 off, mux off
FORCE_NO_SYMBOL $F269
FORCE_SYMBOL $F26B VIA_port_b
COMMENT $F26D sound BDIR off, BC1 off, mux off
FORCE_NO_SYMBOL $F26D
FORCE_SYMBOL $F26F VIA_port_b
COMMENT_LINE $F272 -----------------------------------------------------------------------;
COMMENT_LINE $F272 F272    Clear_Sound                                             ;
COMMENT_LINE $F272 ;
COMMENT_LINE $F272 This routine clears the 15 registers on the music chip and the soft   ;
COMMENT_LINE $F272 copy of their values (C800-C80E), by writing a byte of 0 to each      ;
COMMENT_LINE $F272 register.  This causes the sound chip to not make any sounds.         ;
COMMENT_LINE $F272 ;
COMMENT_LINE $F272 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F272 ;
COMMENT_LINE $F272 D-reg, X-reg trashed                                            ;
COMMENT_LINE $F272 -----------------------------------------------------------------------;
FORCE_NO_SYMBOL $F272
FORCE_SYMBOL $F27A Init_Music_Buf
COMMENT_LINE $F27D -----------------------------------------------------------------------;
COMMENT_LINE $F27D F27D    Sound_Bytes                                             ;
COMMENT_LINE $F27D F284    Sound_Bytes_x? (apparently never used)                  ;
COMMENT_LINE $F27D ;
COMMENT_LINE $F27D This routine copies a block of sound information into the sound       ;
COMMENT_LINE $F27D chip buffer (at $C800-$C80E) and into the registers on the music      ;
COMMENT_LINE $F27D chip.  The format for the block of sound data is as follows:          ;
COMMENT_LINE $F27D ;
COMMENT_LINE $F27D (register number), (music data),                                    ;
COMMENT_LINE $F27D (register number), (music data),                                    ;
COMMENT_LINE $F27D .                  .                                          ;
COMMENT_LINE $F27D .                  .                                          ;
COMMENT_LINE $F27D 0xFF                                                            ;
COMMENT_LINE $F27D ;
COMMENT_LINE $F27D As long as the register number is >= 0, then the music data will be   ;
COMMENT_LINE $F27D copied; however, as soon as a register number < 0 is encountered,     ;
COMMENT_LINE $F27D the copy will stop.                                                   ;
COMMENT_LINE $F27D ;
COMMENT_LINE $F27D ENTRY DP = $D0                                                        ;
COMMENT_LINE $F27D U-reg = pointer to the block of sound data                      ;
COMMENT_LINE $F27D ;
COMMENT_LINE $F27D D-reg, X-reg, U-reg trashed                                     ;
COMMENT_LINE $F27D -----------------------------------------------------------------------;
COMMENT $F27D Point to shadow memory
FORCE_SYMBOL $F27D Vec_Snd_Shadow
COMMENT $F282 Update the sound register
COMMENT $F284 Get next next pair of bytes
COMMENT $F286 Go back if not end of list
COMMENT_LINE $F289 -----------------------------------------------------------------------;
COMMENT_LINE $F289 F289    Do_Sound                                                ;
COMMENT_LINE $F289 F28C    Do_Sound_x? (apparently never used)                     ;
COMMENT_LINE $F289 ;
COMMENT_LINE $F289 This routine will start/continue making the sound which was first     ;
COMMENT_LINE $F289 = up by your call to Init_Music.  This routine should normally      ;
COMMENT_LINE $F289 be called right after your call to Wait_Recal.  It takes the next     ;
COMMENT_LINE $F289 music information, contained in the music buffer $C83F-$C84C, and     ;
COMMENT_LINE $F289 updates only those registers which differ from the last data written  ;
COMMENT_LINE $F289 to the sound chip.                                                    ;
COMMENT_LINE $F289 ;
COMMENT_LINE $F289 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F289 ;
COMMENT_LINE $F289 D-reg, X-reg, U-reg trashed                                     ;
COMMENT_LINE $F289 -----------------------------------------------------------------------;
COMMENT $F289 point to shadow memory
FORCE_SYMBOL $F289 Vec_Snd_Shadow
COMMENT $F28C point to sound buffer
FORCE_SYMBOL $F28C Vec_Music_Work
COMMENT $F28F init count for 14 registers
FORCE_NO_SYMBOL $F28F
COMMENT $F291 get next register
COMMENT $F293 skip if unchanged
COMMENT $F297 else update register
COMMENT $F299 go back for next register
COMMENT_LINE $F29D -----------------------------------------------------------------------;
COMMENT_LINE $F29D F29D    Intensity_1F                                            ;
COMMENT_LINE $F29D F2A1    Intensity_3F                                            ;
COMMENT_LINE $F29D F2A5    Intensity_5F                                            ;
COMMENT_LINE $F29D F2A9    Intensity_7F                                            ;
COMMENT_LINE $F29D F2AB    Intensity_a                                             ;
COMMENT_LINE $F29D ;
COMMENT_LINE $F29D Each of these routines are responsible for setting the vector/dot     ;
COMMENT_LINE $F29D intensity (commonly used to denote the z axis) to a specific value.   ;
COMMENT_LINE $F29D 0x00 is the lowest intensity, and 0xFF is the brightest intensity.    ;
COMMENT_LINE $F29D The intensity must be reset to the desired value after each call      ;
COMMENT_LINE $F29D to Wait_Recal; however, it can also be changed at any other time.     ;
COMMENT_LINE $F29D A copy of the new intensity value is saved in $C827.                  ;
COMMENT_LINE $F29D ;
COMMENT_LINE $F29D ENTRY DP = $D0                                                        ;
COMMENT_LINE $F29D A-reg = intensity (Intensity_a only)                            ;
COMMENT_LINE $F29D ;
COMMENT_LINE $F29D D-reg trashed                                                   ;
COMMENT_LINE $F29D -----------------------------------------------------------------------;
FORCE_NO_SYMBOL $F29D
FORCE_NO_SYMBOL $F2A1
FORCE_NO_SYMBOL $F2A5
FORCE_NO_SYMBOL $F2A9
COMMENT $F2AB Store intensity in D/A
FORCE_SYMBOL $F2AB VIA_port_a
COMMENT $F2AD Save intensity in $C827
FORCE_SYMBOL $F2AD Vec_Brightness
COMMENT $F2B0 mux disabled channel 2
FORCE_NO_SYMBOL $F2B0
FORCE_SYMBOL $F2B3 VIA_port_b
COMMENT $F2B5 mux enabled channel 2
FORCE_SYMBOL $F2B5 VIA_port_b
COMMENT $F2B7 do it again just because
FORCE_SYMBOL $F2B7 VIA_port_b
FORCE_NO_SYMBOL $F2B9
COMMENT $F2BB turn off mux
FORCE_SYMBOL $F2BB VIA_port_b
COMMENT_LINE $F2BE -----------------------------------------------------------------------;
COMMENT_LINE $F2BE F2BE    Dot_ix_b                                                ;
COMMENT_LINE $F2BE F2C1    Dot_ix                                                  ;
COMMENT_LINE $F2BE ;
COMMENT_LINE $F2BE These routines draw a dot at the relative y and relative x            ;
COMMENT_LINE $F2BE position pointed to by the X register.  Afterwards, the X register    ;
COMMENT_LINE $F2BE is incremented by 2.                                                  ;
COMMENT_LINE $F2BE ;
COMMENT_LINE $F2BE ENTRY DP = $D0                                                        ;
COMMENT_LINE $F2BE X-reg points to the (y,x) coordinate pair                       ;
COMMENT_LINE $F2BE B-reg contains the intensity (Dot_ix_b only)                    ;
COMMENT_LINE $F2BE $C828 contains the intensity (Dot_ix only)                      ;
COMMENT_LINE $F2BE ;
COMMENT_LINE $F2BE EXIT  X-reg incremented by 2                                          ;
COMMENT_LINE $F2BE ;
COMMENT_LINE $F2BE D-reg trashed                                                   ;
COMMENT_LINE $F2BE -----------------------------------------------------------------------;
FORCE_SYMBOL $F2BE Vec_Dot_Dwell
COMMENT_LINE $F2C3 -----------------------------------------------------------------------;
COMMENT_LINE $F2C3 F2C3    Dot_d                                                   ;
COMMENT_LINE $F2C3 ;
COMMENT_LINE $F2C3 This routine draws a dot at the relative y and relative x position    ;
COMMENT_LINE $F2C3 contained in the D register.  The intensity used is the value         ;
COMMENT_LINE $F2C3 already stored in $C828.                                              ;
COMMENT_LINE $F2C3 ;
COMMENT_LINE $F2C3 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F2C3 A-reg = relative Y coordinate                                   ;
COMMENT_LINE $F2C3 B-reg = relative X coordinate                                   ;
COMMENT_LINE $F2C3 ;
COMMENT_LINE $F2C3 D-reg trashed                                                   ;
COMMENT_LINE $F2C3 -----------------------------------------------------------------------;
COMMENT_LINE $F2C5 -----------------------------------------------------------------------;
COMMENT_LINE $F2C5 F2C5    Dot_here                                                ;
COMMENT_LINE $F2C5 ;
COMMENT_LINE $F2C5 This routine draws a dot at the current pen position.                 ;
COMMENT_LINE $F2C5 The intensity used is the value already stored in $C828.              ;
COMMENT_LINE $F2C5 ;
COMMENT_LINE $F2C5 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F2C5 ;
COMMENT_LINE $F2C5 D-reg trashed                                                   ;
COMMENT_LINE $F2C5 -----------------------------------------------------------------------;
COMMENT $F2C5 Set pattern to all 1's
FORCE_NO_SYMBOL $F2C5
COMMENT $F2C7 Store in VIA shift register
FORCE_SYMBOL $F2C7 VIA_shift_reg
COMMENT $F2C9 Get dot dwell (brightness)
FORCE_SYMBOL $F2C9 Vec_Dot_Dwell
COMMENT $F2CC Delay leaving beam in place
COMMENT $F2CF Blank beam in VIA shift register
FORCE_SYMBOL $F2CF VIA_shift_reg
COMMENT_LINE $F2D2 -----------------------------------------------------------------------;
COMMENT_LINE $F2D2 F2D5    Dot_List                                                ;
COMMENT_LINE $F2D2 ;
COMMENT_LINE $F2D2 This routine draws a series of dots, using the intensity already      ;
COMMENT_LINE $F2D2 = up in $C828.  The format for the dot list, which is pointed to    ;
COMMENT_LINE $F2D2 by the X register, is:                                                ;
COMMENT_LINE $F2D2 ;
COMMENT_LINE $F2D2 ( rel y, rel x), (rel y, rel x), .....                            ;
COMMENT_LINE $F2D2 ;
COMMENT_LINE $F2D2 The number of dots to draw is specified in $C823.                     ;
COMMENT_LINE $F2D2 ;
COMMENT_LINE $F2D2 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F2D2 X-reg points to the list of dot coordinates                     ;
COMMENT_LINE $F2D2 $C823 specifies the number of dots to draw                      ;
COMMENT_LINE $F2D2 ;
COMMENT_LINE $F2D2 EXIT: X-reg points to next byte after list                            ;
COMMENT_LINE $F2D2 $C823 cleared                                                   ;
COMMENT_LINE $F2D2 ;
COMMENT_LINE $F2D2 D-reg trashed                                                   ;
COMMENT_LINE $F2D2 -----------------------------------------------------------------------;
COMMENT $F2D2 Decrement counter
FORCE_NO_SYMBOL $F2D2
COMMENT $F2D5 Draw next dot
COMMENT $F2D7 Check counter
FORCE_NO_SYMBOL $F2D7
COMMENT $F2DA Go back until finished
COMMENT $F2DC Go to Reset0Ref
COMMENT_LINE $F2DE -----------------------------------------------------------------------;
COMMENT_LINE $F2DE F2DE    Dot_List_Reset                                          ;
COMMENT_LINE $F2DE ;
COMMENT_LINE $F2DE This routine draws a series of dots, specified by the list pointed    ;
COMMENT_LINE $F2DE to by the X register.  The list has the following format:             ;
COMMENT_LINE $F2DE ;
COMMENT_LINE $F2DE mode, relative y, relative x,                                     ;
COMMENT_LINE $F2DE mode, relative y, relative x,                                     ;
COMMENT_LINE $F2DE .      .           .                                            ;
COMMENT_LINE $F2DE .      .           .                                            ;
COMMENT_LINE $F2DE mode, relative y, relative x                                      ;
COMMENT_LINE $F2DE 0x01                                                              ;
COMMENT_LINE $F2DE ;
COMMENT_LINE $F2DE This routine will continue to traverse the list, until a mode > 0     ;
COMMENT_LINE $F2DE is encountered; at that point, it will reset the zero reference       ;
COMMENT_LINE $F2DE (the integrators).                                                    ;
COMMENT_LINE $F2DE ;
COMMENT_LINE $F2DE ENTRY DP = $D0                                                        ;
COMMENT_LINE $F2DE X-reg points to the dot list                                    ;
COMMENT_LINE $F2DE ;
COMMENT_LINE $F2DE EXIT: X-reg points to next byte after the terminator                  ;
COMMENT_LINE $F2DE ;
COMMENT_LINE $F2DE D-reg trashed                                                   ;
COMMENT_LINE $F2DE -----------------------------------------------------------------------;
COMMENT $F2DE get mode byte
COMMENT $F2E0 if >0 go to Reset0Ref
COMMENT $F2E2 plot the dot
COMMENT $F2E4 dot_list@x_&_reset
COMMENT_LINE $F2E6 -----------------------------------------------------------------------;
COMMENT_LINE $F2E6 F2E6    Recalibrate                                             ;
COMMENT_LINE $F2E6 ;
COMMENT_LINE $F2E6 Recalibrate the vector generators.                              ;
COMMENT_LINE $F2E6 ;
COMMENT_LINE $F2E6 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F2E6 ;
COMMENT_LINE $F2E6 D-reg, X-reg trashed                                            ;
COMMENT_LINE $F2E6 -----------------------------------------------------------------------;
COMMENT $F2E6 $7F7F
FORCE_SYMBOL $F2E6 Recal_Points
FORCE_SYMBOL $F2EB Reset0Int
COMMENT $F2EE $8080
COMMENT_LINE $F2F2 -----------------------------------------------------------------------;
COMMENT_LINE $F2F2 F2F2    Moveto_x_7F                                             ;
COMMENT_LINE $F2F2 ;
COMMENT_LINE $F2F2 This routine forces the scale factor to 0x7F, and then moves the      ;
COMMENT_LINE $F2F2 pen to the location pointed to by the X register.  The relative y     ;
COMMENT_LINE $F2F2 and relative x coordinates are both 2 byte quantities; however,       ;
COMMENT_LINE $F2F2 only the most signicant byte of each is of any interest.  The values  ;
COMMENT_LINE $F2F2 pointed to by the X register have the following format:               ;
COMMENT_LINE $F2F2 ;
COMMENT_LINE $F2F2 X => (rel y hi),(rel y lo), (rel x hi), (rel x lo)                ;
COMMENT_LINE $F2F2 ;
COMMENT_LINE $F2F2 The position moved to is obtained by y=(0,x) & x=(2,x).               ;
COMMENT_LINE $F2F2 ;
COMMENT_LINE $F2F2 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F2F2 X-reg points to double-sized coordinate pair                    ;
COMMENT_LINE $F2F2 ;
COMMENT_LINE $F2F2 D-reg trashed                                                   ;
COMMENT_LINE $F2F2 -----------------------------------------------------------------------;
COMMENT $F2F2 Set scale factor to $7F
FORCE_NO_SYMBOL $F2F2
FORCE_SYMBOL $F2F4 VIA_t1_cnt_lo
COMMENT $F2F6 Get y high
FORCE_NO_SYMBOL $F2F6
COMMENT $F2F8 Get x high
FORCE_NO_SYMBOL $F2F8
COMMENT_LINE $F2FC -----------------------------------------------------------------------;
COMMENT_LINE $F2FC F2FC    Moveto_d_7F                                             ;
COMMENT_LINE $F2FC ;
COMMENT_LINE $F2FC This routine forces the scale factor to 0x7F, and then moves the      ;
COMMENT_LINE $F2FC pen to the position specified in the D register.                      ;
COMMENT_LINE $F2FC ;
COMMENT_LINE $F2FC ENTRY DP = $D0                                                        ;
COMMENT_LINE $F2FC A-reg = relative Y coordinate                                   ;
COMMENT_LINE $F2FC B-reg = relative X coordinate                                   ;
COMMENT_LINE $F2FC ;
COMMENT_LINE $F2FC D-reg trashed                                                   ;
COMMENT_LINE $F2FC -----------------------------------------------------------------------;
COMMENT $F2FC Store Y in D/A register
FORCE_SYMBOL $F2FC VIA_port_a
COMMENT $F2FE Save D-register on stack
COMMENT $F300 Set scale factor to $7F
FORCE_NO_SYMBOL $F300
FORCE_SYMBOL $F302 VIA_t1_cnt_lo
COMMENT $F304 Enable mux
FORCE_SYMBOL $F304 VIA_port_b
COMMENT_LINE $F308 -----------------------------------------------------------------------;
COMMENT_LINE $F308 F308    Moveto_ix_FF                                            ;
COMMENT_LINE $F308 F30C    Moveto_ix_7F                                            ;
COMMENT_LINE $F308 F30E    Moveto_ix_b                                             ;
COMMENT_LINE $F308 ;
COMMENT_LINE $F308 These routines force the scale factor to 0xFF, 0X7F, or the           ;
COMMENT_LINE $F308 A register, and then move the pen to the (y,x) position pointed to    ;
COMMENT_LINE $F308 by the X-register.  The X-register is then incremented by 2.          ;
COMMENT_LINE $F308 ;
COMMENT_LINE $F308 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F308 X-reg points to the (y,x) coordinate pair                       ;
COMMENT_LINE $F308 B-reg contains the scale factor (Moveto_ix_b only)              ;
COMMENT_LINE $F308 ;
COMMENT_LINE $F308 EXIT: X-reg has been incremented by 2                                 ;
COMMENT_LINE $F308 ;
COMMENT_LINE $F308 D-reg trashed                                                   ;
COMMENT_LINE $F308 -----------------------------------------------------------------------;
FORCE_NO_SYMBOL $F308
FORCE_NO_SYMBOL $F30C
COMMENT $F30E Set scale factor
FORCE_SYMBOL $F30E VIA_t1_cnt_lo
COMMENT_LINE $F310 -----------------------------------------------------------------------;
COMMENT_LINE $F310 F310    Moveto_ix                                               ;
COMMENT_LINE $F310 ;
COMMENT_LINE $F310 This routine uses the current scale factor, and moves the pen to the  ;
COMMENT_LINE $F310 (y,x) position pointed to by the X register.  The X register is then  ;
COMMENT_LINE $F310 incremented by 2.                                                     ;
COMMENT_LINE $F310 ;
COMMENT_LINE $F310 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F310 X-reg points to the (y,x) coordinate pair                       ;
COMMENT_LINE $F310 ;
COMMENT_LINE $F310 EXIT: X-reg has been incremented by 2                                 ;
COMMENT_LINE $F310 ;
COMMENT_LINE $F310 D-reg trashed                                                   ;
COMMENT_LINE $F310 -----------------------------------------------------------------------;
COMMENT_LINE $F312 -----------------------------------------------------------------------;
COMMENT_LINE $F312 F312    Moveto_d                                                ;
COMMENT_LINE $F312 ;
COMMENT_LINE $F312 This routine uses the current scale factor, and moves the pen to the  ;
COMMENT_LINE $F312 (y,x) position specified in D register.                               ;
COMMENT_LINE $F312 ;
COMMENT_LINE $F312 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F312 A-reg = Y coordinate                                            ;
COMMENT_LINE $F312 B-reg = X coordinate                                            ;
COMMENT_LINE $F312 ;
COMMENT_LINE $F312 D-reg trashed                                                   ;
COMMENT_LINE $F312 -----------------------------------------------------------------------;
COMMENT $F312 Store Y in D/A register
FORCE_SYMBOL $F312 VIA_port_a
COMMENT $F314 Enable mux
FORCE_SYMBOL $F314 VIA_port_b
COMMENT $F316 Save D-register on stack
COMMENT $F318 Blank low, zero high?
FORCE_NO_SYMBOL $F318
FORCE_SYMBOL $F31A VIA_cntl
COMMENT $F31C Clear shift regigster
FORCE_SYMBOL $F31C VIA_shift_reg
COMMENT $F31E Disable mux
FORCE_SYMBOL $F31E VIA_port_b
COMMENT $F320 Store X in D/A register
FORCE_SYMBOL $F320 VIA_port_a
COMMENT $F322 timer 1 count high
FORCE_SYMBOL $F322 VIA_t1_cnt_hi
COMMENT $F324 Get back D-reg
FORCE_SYMBOL $F326 Abs_a_b
FORCE_NO_SYMBOL $F32D
FORCE_NO_SYMBOL $F32F
FORCE_NO_SYMBOL $F333
FORCE_NO_SYMBOL $F337
COMMENT $F33B Wait for timer 1
FORCE_NO_SYMBOL $F33B
FORCE_SYMBOL $F33D VIA_int_flags
COMMENT $F341 Delay a moment
COMMENT $F345 Wait for timer 1
FORCE_SYMBOL $F345 VIA_int_flags
COMMENT_LINE $F34A -----------------------------------------------------------------------;
COMMENT_LINE $F34A F34A    Reset0Ref_D0                                            ;
COMMENT_LINE $F34A ;
COMMENT_LINE $F34A This routine sets the DP register to D0, and then resets the          ;
COMMENT_LINE $F34A integrators.                                                          ;
COMMENT_LINE $F34A ;
COMMENT_LINE $F34A EXIT: DP = $D0                                                        ;
COMMENT_LINE $F34A ;
COMMENT_LINE $F34A D-reg trashed                                                   ;
COMMENT_LINE $F34A -----------------------------------------------------------------------;
FORCE_SYMBOL $F34A DP_to_D0
COMMENT_LINE $F34F -----------------------------------------------------------------------;
COMMENT_LINE $F34F F34F    Check0Ref                                               ;
COMMENT_LINE $F34F ;
COMMENT_LINE $F34F This routine will check to see if the Reset0Ref enable flag ($C824)   ;
COMMENT_LINE $F34F is set, and if it is, then it will reset the integrators by calling   ;
COMMENT_LINE $F34F Reset0Ref.                                                            ;
COMMENT_LINE $F34F ;
COMMENT_LINE $F34F ENTRY DP = $D0                                                        ;
COMMENT_LINE $F34F $C824 = enable flag                                             ;
COMMENT_LINE $F34F ;
COMMENT_LINE $F34F D-reg trashed                                                   ;
COMMENT_LINE $F34F -----------------------------------------------------------------------;
FORCE_SYMBOL $F34F Vec_0Ref_Enable
COMMENT_LINE $F354 -----------------------------------------------------------------------;
COMMENT_LINE $F354 F354    Reset0Ref                                               ;
COMMENT_LINE $F354 ;
COMMENT_LINE $F354 This routine zeros the integrators, and resets the pen back to the    ;
COMMENT_LINE $F354 origin.  It leaves the integrators in zero mode, so nothing can be    ;
COMMENT_LINE $F354 drawn until a move is done, or $D00C is = to 0xCE to bring /ZERO    ;
COMMENT_LINE $F354 high.  This routine must be called every so often, to prevent your    ;
COMMENT_LINE $F354 vectors from getting out of whack.                                    ;
COMMENT_LINE $F354 ;
COMMENT_LINE $F354 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F354 ;
COMMENT_LINE $F354 D-reg trashed                                                   ;
COMMENT_LINE $F354 -----------------------------------------------------------------------;
FORCE_NO_SYMBOL $F354
COMMENT $F357 /BLANK low and /ZERO low
FORCE_SYMBOL $F357 VIA_cntl
COMMENT $F359 clear shift register
FORCE_SYMBOL $F359 VIA_shift_reg
COMMENT_LINE $F35B -----------------------------------------------------------------------;
COMMENT_LINE $F35B F35B    Reset_Pen                                               ;
COMMENT_LINE $F35B ;
COMMENT_LINE $F35B Reset the pen to the origin.                                    ;
COMMENT_LINE $F35B ;
COMMENT_LINE $F35B ENTRY DP = $D0                                                        ;
COMMENT_LINE $F35B ;
COMMENT_LINE $F35B D-reg trashed                                                   ;
COMMENT_LINE $F35B -----------------------------------------------------------------------;
FORCE_NO_SYMBOL $F35B
COMMENT $F35E clear D/A register
FORCE_SYMBOL $F35E VIA_port_a
COMMENT $F360 mux=1, disable mux
FORCE_SYMBOL $F360 VIA_port_b
COMMENT $F362 mux=1, enable mux
FORCE_SYMBOL $F362 VIA_port_b
COMMENT $F364 do it again
FORCE_SYMBOL $F364 VIA_port_b
FORCE_NO_SYMBOL $F366
COMMENT $F368 disable mux
FORCE_SYMBOL $F368 VIA_port_b
COMMENT_LINE $F36B -----------------------------------------------------------------------;
COMMENT_LINE $F36B F36B    Reset0Int                                               ;
COMMENT_LINE $F36B ;
COMMENT_LINE $F36B This routine resets the integrators to zero.  It leaves the           ;
COMMENT_LINE $F36B integrators in zero mode, so nothing can be drawn until a move is     ;
COMMENT_LINE $F36B done, or D00C is = to 0xCE.                                         ;
COMMENT_LINE $F36B ;
COMMENT_LINE $F36B ENTRY DP = $D0                                                        ;
COMMENT_LINE $F36B ;
COMMENT_LINE $F36B D-reg trashed                                                   ;
COMMENT_LINE $F36B -----------------------------------------------------------------------;
FORCE_NO_SYMBOL $F36B
COMMENT $F36E blank low and zero low
FORCE_SYMBOL $F36E VIA_cntl
COMMENT $F370 clear shift register
FORCE_SYMBOL $F370 VIA_shift_reg
COMMENT_LINE $F373 -----------------------------------------------------------------------;
COMMENT_LINE $F373 F373    Print_Str_hwyx                                          ;
COMMENT_LINE $F373 ;
COMMENT_LINE $F373 This routine prints a single string (up to an 0x80).  The parameter   ;
COMMENT_LINE $F373 block describing the string is pointed to by the U register.  The     ;
COMMENT_LINE $F373 format for the parameter block is as follows:                         ;
COMMENT_LINE $F373 ;
COMMENT_LINE $F373 height, width, rel y, rel x, string, 0x80                       ;
COMMENT_LINE $F373 ;
COMMENT_LINE $F373 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F373 U-reg points to the string list                                 ;
COMMENT_LINE $F373 ;
COMMENT_LINE $F373 EXIT: U-reg points to the byte after the terminating 0x80             ;
COMMENT_LINE $F373 ;
COMMENT_LINE $F373 D-reg, X-reg trashed                                            ;
COMMENT_LINE $F373 -----------------------------------------------------------------------;
FORCE_SYMBOL $F375 Vec_Text_HW
COMMENT_LINE $F378 -----------------------------------------------------------------------;
COMMENT_LINE $F378 F378    Print_Str_yx                                            ;
COMMENT_LINE $F378 ;
COMMENT_LINE $F378 This routine prints a single string (up to an 0x80), using the        ;
COMMENT_LINE $F378 default height and width, as stored in $C82A.  The parameter block    ;
COMMENT_LINE $F378 describing the string is pointed to by the U register.  The format    ;
COMMENT_LINE $F378 for the parameter block is as follows:                                ;
COMMENT_LINE $F378 ;
COMMENT_LINE $F378 rel y, rel x, string, 0x80                                      ;
COMMENT_LINE $F378 ;
COMMENT_LINE $F378 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F378 U-reg points to the string list                                 ;
COMMENT_LINE $F378 ;
COMMENT_LINE $F378 EXIT: U-reg points to the byte after the terminating 0x80             ;
COMMENT_LINE $F378 ;
COMMENT_LINE $F378 D-reg, X-reg trashed                                            ;
COMMENT_LINE $F378 -----------------------------------------------------------------------;
COMMENT_LINE $F37A -----------------------------------------------------------------------;
COMMENT_LINE $F37A F37A    Print_Str_d                                             ;
COMMENT_LINE $F37A ;
COMMENT_LINE $F37A This routine prints a single string (up to an 0x80), using the        ;
COMMENT_LINE $F37A default height and width, as stored in $C82A, and at the pen position ;
COMMENT_LINE $F37A specified in the D register.  The parameter block describing the      ;
COMMENT_LINE $F37A string is pointed to by the U register.  The format for the           ;
COMMENT_LINE $F37A parameter block is as follows:                                        ;
COMMENT_LINE $F37A ;
COMMENT_LINE $F37A string, 0x80                                                      ;
COMMENT_LINE $F37A ;
COMMENT_LINE $F37A ENTRY DP = $D0                                                        ;
COMMENT_LINE $F37A U-reg points to string list                                     ;
COMMENT_LINE $F37A A-reg = relative Y position                                     ;
COMMENT_LINE $F37A B-reg = relative X position                                     ;
COMMENT_LINE $F37A ;
COMMENT_LINE $F37A EXIT: U-reg points to the byte after the terminating 0x80             ;
COMMENT_LINE $F37A ;
COMMENT_LINE $F37A D-reg, X-reg trashed                                            ;
COMMENT_LINE $F37A -----------------------------------------------------------------------;
COMMENT $F37A neccessary for assembling, this jsr is allways
COMMENT_LINE $F37A optimized to a short branch otherwise
FORCE_SYMBOL $F37A Moveto_d_7F
FORCE_SYMBOL $F37D Delay_1
FORCE_SYMBOL $F380 Print_Str
COMMENT_LINE $F383 -----------------------------------------------------------------------;
COMMENT_LINE $F383 F385    Print_List_hw                                           ;
COMMENT_LINE $F383 ;
COMMENT_LINE $F383 This displays the group of strings described by the parameter block   ;
COMMENT_LINE $F383 which is pointed to by the U register.  The string parameter block    ;
COMMENT_LINE $F383 has the following format:                                             ;
COMMENT_LINE $F383 ;
COMMENT_LINE $F383 height, width, rel y, rel x, string, 0x80,                        ;
COMMENT_LINE $F383 height, width, rel y, rel x, string, 0x80,                        ;
COMMENT_LINE $F383 0x00                                                              ;
COMMENT_LINE $F383 ;
COMMENT_LINE $F383 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F383 U-reg points to string list                                     ;
COMMENT_LINE $F383 ;
COMMENT_LINE $F383 EXIT: U-reg points to null terminator byte                            ;
COMMENT_LINE $F383 ;
COMMENT_LINE $F383 D-reg, X-reg trashed                                            ;
COMMENT_LINE $F383 -----------------------------------------------------------------------;
FORCE_NO_SYMBOL $F385
COMMENT_LINE $F38A -----------------------------------------------------------------------;
COMMENT_LINE $F38A F38A    Print_List                                              ;
COMMENT_LINE $F38A F38C    Print_List_chk                                          ;
COMMENT_LINE $F38A ;
COMMENT_LINE $F38A This displays the group of strings described by the parameter block   ;
COMMENT_LINE $F38A which is pointed to by the U register.  The string parameter block    ;
COMMENT_LINE $F38A has the following format:                                             ;
COMMENT_LINE $F38A ;
COMMENT_LINE $F38A rel y, rel x, string, 0x80,                                     ;
COMMENT_LINE $F38A rel y, rel x, string, 0x80,                                     ;
COMMENT_LINE $F38A 0x00                                                            ;
COMMENT_LINE $F38A ;
COMMENT_LINE $F38A The current string height and width to which the hardware is = will ;
COMMENT_LINE $F38A be used.                                                              ;
COMMENT_LINE $F38A ;
COMMENT_LINE $F38A Print_List routine will first print the passed-in string, and THEN    ;
COMMENT_LINE $F38A check for the end of the string list.  Print_List_Chk will check for  ;
COMMENT_LINE $F38A the end of the string list first.                                     ;
COMMENT_LINE $F38A ;
COMMENT_LINE $F38A ENTRY DP = $D0                                                        ;
COMMENT_LINE $F38A U-reg points to string list                                     ;
COMMENT_LINE $F38A ;
COMMENT_LINE $F38A EXIT: U-reg points to null terminator byte                            ;
COMMENT_LINE $F38A ;
COMMENT_LINE $F38A D-reg, X-reg trashed                                            ;
COMMENT_LINE $F38A -----------------------------------------------------------------------;
FORCE_NO_SYMBOL $F38C
COMMENT_LINE $F391 -----------------------------------------------------------------------;
COMMENT_LINE $F391 F391    Print_Ships_x                                           ;
COMMENT_LINE $F391 F393    Print_Ships                                             ;
COMMENT_LINE $F391 ;
COMMENT_LINE $F391 This routine displays the number of ships passed in the B register    ;
COMMENT_LINE $F391 followed by a minus sign and the ship icon character passed in the    ;
COMMENT_LINE $F391 A register at the (y,x) coordinates passed in the X register.  If     ;
COMMENT_LINE $F391 the B-register > 9, then the infinity symbol is displayed.            ;
COMMENT_LINE $F391 ;
COMMENT_LINE $F391 Note: This routine uses bytes at a negative offset from the stack as  ;
COMMENT_LINE $F391 temporary storage, so hopefully an IRQ won't happen until the   ;
COMMENT_LINE $F391 string is finished bring printed!                               ;
COMMENT_LINE $F391 ;
COMMENT_LINE $F391 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F391 A-reg = ship icon character                                     ;
COMMENT_LINE $F391 B-reg = number of ships                                         ;
COMMENT_LINE $F391 X-reg = (y,x) coordinates (Print_Ships only)                    ;
COMMENT_LINE $F391 X-reg points to (y,x) coordinates (Print_Ships_x only)          ;
COMMENT_LINE $F391 ;
COMMENT_LINE $F391 D-reg, X-reg, U-reg trashed                                     ;
COMMENT_LINE $F391 -----------------------------------------------------------------------;
FORCE_NO_SYMBOL $F391
COMMENT $F393 Save B-reg
FORCE_NO_SYMBOL $F395
COMMENT $F397 Point U into the stack
COMMENT $F399 Save A-reg and a terminator
COMMENT $F39B Get back B-reg
COMMENT $F39D If B-reg >9 then
FORCE_NO_SYMBOL $F39D
COMMENT $F3A1 load $6C = infinty symbol
FORCE_NO_SYMBOL $F3A3
COMMENT $F3A7 Push digit and minus sign
COMMENT $F3A9 Push (y,x) coordinates
COMMENT $F3AB Print it
COMMENT_LINE $F3AD -----------------------------------------------------------------------;
COMMENT_LINE $F3AD F3AD    Mov_Draw_VLc_a                                          ;
COMMENT_LINE $F3AD ;
COMMENT_LINE $F3AD This routine moves to the first location specified in vector list,    ;
COMMENT_LINE $F3AD and then draws lines between the rest of coordinates in the list.     ;
COMMENT_LINE $F3AD The number of vectors to draw is specified as the first byte in the   ;
COMMENT_LINE $F3AD vector list.  The current scale factor is used.  The vector list has  ;
COMMENT_LINE $F3AD the following format:                                                 ;
COMMENT_LINE $F3AD ;
COMMENT_LINE $F3AD count, rel y, rel x, rel y, rel x, ...                          ;
COMMENT_LINE $F3AD ;
COMMENT_LINE $F3AD ENTRY DP = $D0                                                        ;
COMMENT_LINE $F3AD X-reg points to the vector list                                 ;
COMMENT_LINE $F3AD ;
COMMENT_LINE $F3AD EXIT: X-reg points to next byte after list                            ;
COMMENT_LINE $F3AD ;
COMMENT_LINE $F3AD D-reg trashed                                                   ;
COMMENT_LINE $F3AD -----------------------------------------------------------------------;
COMMENT_LINE $F3B1 -----------------------------------------------------------------------;
COMMENT_LINE $F3B1 F3B1    Mov_Draw_VL_b                                           ;
COMMENT_LINE $F3B1 ;
COMMENT_LINE $F3B1 This routine moves to the first location specified in vector list,    ;
COMMENT_LINE $F3B1 and then draws lines between the rest of coordinates in the list.     ;
COMMENT_LINE $F3B1 The vector list has the following format:                             ;
COMMENT_LINE $F3B1 ;
COMMENT_LINE $F3B1 rel y, rel x, rel y, rel x, ...                                 ;
COMMENT_LINE $F3B1 ;
COMMENT_LINE $F3B1 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F3B1 B-reg = scale factor                                            ;
COMMENT_LINE $F3B1 $C823 = number of vectors to draw                               ;
COMMENT_LINE $F3B1 X-reg points to the vector list                                 ;
COMMENT_LINE $F3B1 ;
COMMENT_LINE $F3B1 EXIT: $C823 is cleared                                                ;
COMMENT_LINE $F3B1 ;
COMMENT_LINE $F3B1 EXIT: X-reg points to next byte after list                            ;
COMMENT_LINE $F3B1 ;
COMMENT_LINE $F3B1 D-reg trashed                                                   ;
COMMENT_LINE $F3B1 -----------------------------------------------------------------------;
COMMENT $F3B1 Set scale factor
FORCE_SYMBOL $F3B1 VIA_t1_cnt_lo
COMMENT_LINE $F3B5 -----------------------------------------------------------------------;
COMMENT_LINE $F3B5 F3B5    Mov_Draw_VLcs                                           ;
COMMENT_LINE $F3B5 ;
COMMENT_LINE $F3B5 This routine moves to the first location specified in vector list,    ;
COMMENT_LINE $F3B5 and then draws lines between the rest of coordinates in the list.     ;
COMMENT_LINE $F3B5 The number of vectors to draw is specified as the first byte in the   ;
COMMENT_LINE $F3B5 vector list, and the scale factor is the second byte in the vector    ;
COMMENT_LINE $F3B5 list.  The vector list has the following format:                      ;
COMMENT_LINE $F3B5 ;
COMMENT_LINE $F3B5 count, scale, rel y, rel x, rel y, rel x, ...                   ;
COMMENT_LINE $F3B5 ;
COMMENT_LINE $F3B5 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F3B5 X-reg points to the vector list                                 ;
COMMENT_LINE $F3B5 ;
COMMENT_LINE $F3B5 EXIT: X-reg points to next byte after list                            ;
COMMENT_LINE $F3B5 ;
COMMENT_LINE $F3B5 D-reg trashed                                                   ;
COMMENT_LINE $F3B5 -----------------------------------------------------------------------;
COMMENT_LINE $F3B7 -----------------------------------------------------------------------;
COMMENT_LINE $F3B7 F3B7    Mov_Draw_VL_ab                                          ;
COMMENT_LINE $F3B7 F3B9    Mov_Draw_VL_a                                           ;
COMMENT_LINE $F3B7 ;
COMMENT_LINE $F3B7 This routine moves to the first location specified in vector list,    ;
COMMENT_LINE $F3B7 and then draws lines between the rest of coordinates in the list.     ;
COMMENT_LINE $F3B7 The vector list has the  following format:                            ;
COMMENT_LINE $F3B7 ;
COMMENT_LINE $F3B7 rel y, rel x, rel y, rel x, ...                                 ;
COMMENT_LINE $F3B7 ;
COMMENT_LINE $F3B7 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F3B7 A-reg = number of vectors to draw                               ;
COMMENT_LINE $F3B7 B-reg = scale factor to use (Draw_VL_ab only)                   ;
COMMENT_LINE $F3B7 X-reg points to the vector list                                 ;
COMMENT_LINE $F3B7 ;
COMMENT_LINE $F3B7 EXIT: X-reg points to next byte after list                            ;
COMMENT_LINE $F3B7 ;
COMMENT_LINE $F3B7 D-reg trashed                                                   ;
COMMENT_LINE $F3B7 -----------------------------------------------------------------------;
COMMENT $F3B7 Set scale factor
FORCE_SYMBOL $F3B7 VIA_t1_cnt_lo
FORCE_NO_SYMBOL $F3B9
COMMENT_LINE $F3BC -----------------------------------------------------------------------;
COMMENT_LINE $F3BC F3BC    Mov_Draw_VL                                             ;
COMMENT_LINE $F3BC F3BE    Mov_Draw_VL_d                                           ;
COMMENT_LINE $F3BC ;
COMMENT_LINE $F3BC This routine moves to the first location specified in vector list,    ;
COMMENT_LINE $F3BC and then draws lines between the rest of coordinates in the list.     ;
COMMENT_LINE $F3BC The vector list has the following format:                             ;
COMMENT_LINE $F3BC ;
COMMENT_LINE $F3BC rel y, rel x, rel y, rel x, ...                                 ;
COMMENT_LINE $F3BC ;
COMMENT_LINE $F3BC Draw_VL_d starts at the (y,x) coordinates specified in the D register ;
COMMENT_LINE $F3BC and ignores the first pair of coordinates in the vector list.         ;
COMMENT_LINE $F3BC ;
COMMENT_LINE $F3BC ENTRY DP = $D0                                                        ;
COMMENT_LINE $F3BC $C823 = number of vectors to draw                               ;
COMMENT_LINE $F3BC D-reg = start coordinate (Draw_VL_d only)                       ;
COMMENT_LINE $F3BC X-reg points to the vector list (2,X for Mov_Draw_VL_d)         ;
COMMENT_LINE $F3BC ;
COMMENT_LINE $F3BC EXIT: $C823 is cleared                                                ;
COMMENT_LINE $F3BC ;
COMMENT_LINE $F3BC EXIT: X-reg points to next byte after list                            ;
COMMENT_LINE $F3BC ;
COMMENT_LINE $F3BC D-reg trashed                                                   ;
COMMENT_LINE $F3BC -----------------------------------------------------------------------;
COMMENT $F3BC Get next coordinate pair
FORCE_NO_SYMBOL $F3BC
COMMENT $F3BE Send Y to A/D
FORCE_SYMBOL $F3BE VIA_port_a
COMMENT $F3C0 Enable mux
FORCE_SYMBOL $F3C0 VIA_port_b
COMMENT $F3C2 Point to next coordinate pair
FORCE_NO_SYMBOL $F3C2
COMMENT $F3C4 Wait a moment
COMMENT $F3C5 Disable mux
FORCE_SYMBOL $F3C5 VIA_port_b
COMMENT $F3C7 Send X to A/D
FORCE_SYMBOL $F3C7 VIA_port_a
COMMENT $F3C9 Shift reg=0 (no draw), T1H=0
FORCE_NO_SYMBOL $F3C9
COMMENT $F3CC A->D00A, B->D005
COMMENT_LINE $F3CE -----------------------------------------------------------------------;
COMMENT_LINE $F3CE F3CE    Draw_VLc                                                ;
COMMENT_LINE $F3CE ;
COMMENT_LINE $F3CE This routine draws vectors between the = of (y,x) points pointed    ;
COMMENT_LINE $F3CE to by the X register.  The number of vectors to draw is specified     ;
COMMENT_LINE $F3CE as the first byte in the vector list.  The current scale factor is    ;
COMMENT_LINE $F3CE used.  The vector list has the following format:                      ;
COMMENT_LINE $F3CE ;
COMMENT_LINE $F3CE count, rel y, rel x, rel y, rel x, ...                          ;
COMMENT_LINE $F3CE ;
COMMENT_LINE $F3CE ENTRY DP = $D0                                                        ;
COMMENT_LINE $F3CE X-reg points to the vector list                                 ;
COMMENT_LINE $F3CE ;
COMMENT_LINE $F3CE EXIT: X-reg points to next byte after list                            ;
COMMENT_LINE $F3CE ;
COMMENT_LINE $F3CE D-reg trashed                                                   ;
COMMENT_LINE $F3CE -----------------------------------------------------------------------;
COMMENT_LINE $F3D2 -----------------------------------------------------------------------;
COMMENT_LINE $F3D2 F3D2    Draw_VL_b                                               ;
COMMENT_LINE $F3D2 ;
COMMENT_LINE $F3D2 This routine draws vectors between the = of (y,x) points pointed to ;
COMMENT_LINE $F3D2 by the X register.  The vector list has the following format:         ;
COMMENT_LINE $F3D2 ;
COMMENT_LINE $F3D2 rel y, rel x, rel y, rel x, ...                                 ;
COMMENT_LINE $F3D2 ;
COMMENT_LINE $F3D2 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F3D2 B-reg = the scale factor                                        ;
COMMENT_LINE $F3D2 X-reg points to the vector list                                 ;
COMMENT_LINE $F3D2 ;
COMMENT_LINE $F3D2 EXIT: X-reg points to next byte after list                            ;
COMMENT_LINE $F3D2 ;
COMMENT_LINE $F3D2 D-reg trashed                                                   ;
COMMENT_LINE $F3D2 -----------------------------------------------------------------------;
COMMENT $F3D2 Set scale factor
FORCE_SYMBOL $F3D2 VIA_t1_cnt_lo
COMMENT_LINE $F3D6 -----------------------------------------------------------------------;
COMMENT_LINE $F3D6 F3D6    Draw_VLcs                                               ;
COMMENT_LINE $F3D6 ;
COMMENT_LINE $F3D6 This routine draws vectors between the = of (y,x) points pointed    ;
COMMENT_LINE $F3D6 to by the X register.  The number of vectors to draw is specified     ;
COMMENT_LINE $F3D6 as the first byte in the vector list.  The scale factor is specified  ;
COMMENT_LINE $F3D6 as the second byte in the vector list. The vector list has the        ;
COMMENT_LINE $F3D6 following format:                                                     ;
COMMENT_LINE $F3D6 ;
COMMENT_LINE $F3D6 count, scale, rel y, rel x, rel y, rel x, ...                   ;
COMMENT_LINE $F3D6 ;
COMMENT_LINE $F3D6 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F3D6 X-reg points to the vector list                                 ;
COMMENT_LINE $F3D6 ;
COMMENT_LINE $F3D6 EXIT: X-reg points to next byte after list                            ;
COMMENT_LINE $F3D6 ;
COMMENT_LINE $F3D6 D-reg trashed                                                   ;
COMMENT_LINE $F3D6 -----------------------------------------------------------------------;
COMMENT_LINE $F3D8 -----------------------------------------------------------------------;
COMMENT_LINE $F3D8 F3D8    Draw_VL_ab                                              ;
COMMENT_LINE $F3D8 ;
COMMENT_LINE $F3D8 This routine draws vectors between the = of (y,x) points pointed    ;
COMMENT_LINE $F3D8 to by the X register.  The vector list has the following format:      ;
COMMENT_LINE $F3D8 ;
COMMENT_LINE $F3D8 rel y, rel x, rel y, rel x, ...                                 ;
COMMENT_LINE $F3D8 ;
COMMENT_LINE $F3D8 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F3D8 A-reg = the number of vectors to draw                           ;
COMMENT_LINE $F3D8 B-reg = the scale factor                                        ;
COMMENT_LINE $F3D8 X-reg points to the vector list                                 ;
COMMENT_LINE $F3D8 ;
COMMENT_LINE $F3D8 EXIT: X-reg points to next byte after list                            ;
COMMENT_LINE $F3D8 ;
COMMENT_LINE $F3D8 D-reg trashed                                                   ;
COMMENT_LINE $F3D8 -----------------------------------------------------------------------;
FORCE_SYMBOL $F3D8 VIA_t1_cnt_lo
COMMENT_LINE $F3DA -----------------------------------------------------------------------;
COMMENT_LINE $F3DA F3DA    Draw_VL_a                                               ;
COMMENT_LINE $F3DA ;
COMMENT_LINE $F3DA This routine draws vectors between the = of (y,x) points pointed    ;
COMMENT_LINE $F3DA to by the register.  The current scale factor is used.  The vector    ;
COMMENT_LINE $F3DA list has the following format:                                        ;
COMMENT_LINE $F3DA ;
COMMENT_LINE $F3DA rel y, rel x, rel y, rel x, ...                                 ;
COMMENT_LINE $F3DA ;
COMMENT_LINE $F3DA ENTRY DP = $D0                                                        ;
COMMENT_LINE $F3DA A-reg = the number of vectors to draw                           ;
COMMENT_LINE $F3DA X-reg points to the vector list                                 ;
COMMENT_LINE $F3DA ;
COMMENT_LINE $F3DA EXIT: X-reg points to next byte after list                            ;
COMMENT_LINE $F3DA ;
COMMENT_LINE $F3DA D-reg trashed                                                   ;
COMMENT_LINE $F3DA -----------------------------------------------------------------------;
FORCE_NO_SYMBOL $F3DA
COMMENT_LINE $F3DD -----------------------------------------------------------------------;
COMMENT_LINE $F3DD F3DD    Draw_VL                                                 ;
COMMENT_LINE $F3DD ;
COMMENT_LINE $F3DD This routine draws vectors between the = of (y,x) points pointed    ;
COMMENT_LINE $F3DD to by the X register.  The number of vectors to draw must already be  ;
COMMENT_LINE $F3DD specified in $C823.  The current scale factor is used.  The vector    ;
COMMENT_LINE $F3DD list has the following format:                                        ;
COMMENT_LINE $F3DD ;
COMMENT_LINE $F3DD rel y, rel x, rel y, rel x, ...                                 ;
COMMENT_LINE $F3DD ;
COMMENT_LINE $F3DD ENTRY DP = $D0                                                        ;
COMMENT_LINE $F3DD X-reg points to the vector list                                 ;
COMMENT_LINE $F3DD ;
COMMENT_LINE $F3DD EXIT: X-reg points to next byte after list                            ;
COMMENT_LINE $F3DD ;
COMMENT_LINE $F3DD D-reg trashed                                                   ;
COMMENT_LINE $F3DD -----------------------------------------------------------------------;
FORCE_NO_SYMBOL $F3DD
COMMENT_LINE $F3DF -----------------------------------------------------------------------;
COMMENT_LINE $F3DF F3DF    Draw_Line_d                                             ;
COMMENT_LINE $F3DF ;
COMMENT_LINE $F3DF This routine will draw a line from the current pen position, to the   ;
COMMENT_LINE $F3DF point specified by the (y,x) pair specified in the D register.  The   ;
COMMENT_LINE $F3DF current scale factor is used.  Before calling this routine, $C823     ;
COMMENT_LINE $F3DF should be = 0, so that only the one vector will be drawn.             ;
COMMENT_LINE $F3DF ;
COMMENT_LINE $F3DF ENTRY DP = $D0                                                        ;
COMMENT_LINE $F3DF A-reg = relative y position                                     ;
COMMENT_LINE $F3DF B-reg = relative x position                                     ;
COMMENT_LINE $F3DF ;
COMMENT_LINE $F3DF EXIT: X-reg is incremented by 2                                       ;
COMMENT_LINE $F3DF ;
COMMENT_LINE $F3DF D-reg trashed                                                   ;
COMMENT_LINE $F3DF -----------------------------------------------------------------------;
COMMENT $F3DF Send Y to A/D
FORCE_SYMBOL $F3DF VIA_port_a
COMMENT $F3E1 Enable mux
FORCE_SYMBOL $F3E1 VIA_port_b
COMMENT $F3E3 Point to next coordinate pair
FORCE_NO_SYMBOL $F3E3
COMMENT $F3E5 Wait a moment
COMMENT $F3E6 Disable mux
FORCE_SYMBOL $F3E6 VIA_port_b
COMMENT $F3E8 Send X to A/D
FORCE_SYMBOL $F3E8 VIA_port_a
COMMENT $F3EA Shift reg=$FF (solid line), T1H=0
FORCE_NO_SYMBOL $F3EA
COMMENT $F3ED Put pattern in shift register
FORCE_SYMBOL $F3ED VIA_shift_reg
COMMENT $F3EF Set T1H (scale factor?)
FORCE_SYMBOL $F3EF VIA_t1_cnt_hi
COMMENT $F3F1 B-reg = T1 interrupt bit
FORCE_NO_SYMBOL $F3F1
COMMENT $F3F4 Wait for T1 to time out
FORCE_SYMBOL $F3F4 VIA_int_flags
COMMENT $F3F8 Wait a moment more
COMMENT $F3F9 Clear shift register (blank output)
FORCE_SYMBOL $F3F9 VIA_shift_reg
COMMENT $F3FB Decrement line count
FORCE_NO_SYMBOL $F3FB
COMMENT $F3FF Go back for more points
COMMENT $F401 Reset zero reference if necessary
FORCE_SYMBOL $F401 Check0Ref
COMMENT_LINE $F404 -----------------------------------------------------------------------;
COMMENT_LINE $F404 F404    Draw_VLp_FF                                             ;
COMMENT_LINE $F404 F408    Draw_VLp_7F                                             ;
COMMENT_LINE $F404 ;
COMMENT_LINE $F404 These routines force the scale factor to 0xFF or 0x7F, and then       ;
COMMENT_LINE $F404 process the vector list pointed to by the X register.  The vector     ;
COMMENT_LINE $F404 list has the following format:                                        ;
COMMENT_LINE $F404 ;
COMMENT_LINE $F404 pattern, rel y, rel x                                           ;
COMMENT_LINE $F404 pattern, rel y, rel x                                           ;
COMMENT_LINE $F404 .      .      .                                              ;
COMMENT_LINE $F404 .      .      .                                              ;
COMMENT_LINE $F404 pattern, rel y, rel x                                           ;
COMMENT_LINE $F404 0x01                                                            ;
COMMENT_LINE $F404 ;
COMMENT_LINE $F404 The list is terminated by a pattern byte with the high bit cleared.   ;
COMMENT_LINE $F404 ;
COMMENT_LINE $F404 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F404 X-reg points to the vector list                                 ;
COMMENT_LINE $F404 ;
COMMENT_LINE $F404 EXIT: X-reg points to the terminator byte                             ;
COMMENT_LINE $F404 ;
COMMENT_LINE $F404 D-reg trashed                                                   ;
COMMENT_LINE $F404 -----------------------------------------------------------------------;
FORCE_NO_SYMBOL $F404
FORCE_NO_SYMBOL $F408
COMMENT_LINE $F40C -----------------------------------------------------------------------;
COMMENT_LINE $F40C F40C    Draw_VLp_scale                                          ;
COMMENT_LINE $F40C ;
COMMENT_LINE $F40C This routine processes the vector list pointed to by the X register.  ;
COMMENT_LINE $F40C The first byte in the vector list is the scale factor.  The vector    ;
COMMENT_LINE $F40C list has the following format:                                        ;
COMMENT_LINE $F40C ;
COMMENT_LINE $F40C scale                                                           ;
COMMENT_LINE $F40C pattern, rel y, rel x                                           ;
COMMENT_LINE $F40C pattern, rel y, rel x                                           ;
COMMENT_LINE $F40C .      .      .                                              ;
COMMENT_LINE $F40C .      .      .                                              ;
COMMENT_LINE $F40C pattern, rel y, rel x                                           ;
COMMENT_LINE $F40C 0x01                                                            ;
COMMENT_LINE $F40C ;
COMMENT_LINE $F40C The list is terminated by a pattern byte with the high bit cleared.   ;
COMMENT_LINE $F40C ;
COMMENT_LINE $F40C ENTRY DP = $D0                                                        ;
COMMENT_LINE $F40C X-reg points to the vector list                                 ;
COMMENT_LINE $F40C ;
COMMENT_LINE $F40C EXIT: X-reg points to the terminator byte                             ;
COMMENT_LINE $F40C ;
COMMENT_LINE $F40C D-reg trashed                                                   ;
COMMENT_LINE $F40C -----------------------------------------------------------------------;
COMMENT_LINE $F40E -----------------------------------------------------------------------;
COMMENT_LINE $F40E F40E    Draw_VLp_b                                              ;
COMMENT_LINE $F40E ;
COMMENT_LINE $F40E This routine draws patterned lines using the vector list pointed to   ;
COMMENT_LINE $F40E by the X register.  The vector list has the following format:         ;
COMMENT_LINE $F40E ;
COMMENT_LINE $F40E pattern, rel y, rel x                                           ;
COMMENT_LINE $F40E pattern, rel y, rel x                                           ;
COMMENT_LINE $F40E .      .      .                                              ;
COMMENT_LINE $F40E .      .      .                                              ;
COMMENT_LINE $F40E pattern, rel y, rel x                                           ;
COMMENT_LINE $F40E 0x01                                                            ;
COMMENT_LINE $F40E ;
COMMENT_LINE $F40E The list is terminated by a pattern byte with the high bit cleared.   ;
COMMENT_LINE $F40E ;
COMMENT_LINE $F40E ENTRY DP = $D0                                                        ;
COMMENT_LINE $F40E B-reg = the scale factor                                        ;
COMMENT_LINE $F40E X-reg points to the vector list                                 ;
COMMENT_LINE $F40E ;
COMMENT_LINE $F40E EXIT: X-reg points to the terminator byte                             ;
COMMENT_LINE $F40E ;
COMMENT_LINE $F40E D-reg trashed                                                   ;
COMMENT_LINE $F40E -----------------------------------------------------------------------;
COMMENT $F40E Set scale factor
FORCE_SYMBOL $F40E VIA_t1_cnt_lo
COMMENT_LINE $F410 -----------------------------------------------------------------------;
COMMENT_LINE $F410 F410    Draw_VLp                                                ;
COMMENT_LINE $F410 ;
COMMENT_LINE $F410 This routine draws patterned lines using the vector list pointed to   ;
COMMENT_LINE $F410 by the X-register.  The current scale factor is used.  The vector     ;
COMMENT_LINE $F410 list has the following format:                                        ;
COMMENT_LINE $F410 ;
COMMENT_LINE $F410 pattern, rel y, rel x                                           ;
COMMENT_LINE $F410 pattern, rel y, rel x                                           ;
COMMENT_LINE $F410 .      .      .                                              ;
COMMENT_LINE $F410 .      .      .                                              ;
COMMENT_LINE $F410 pattern, rel y, rel x                                           ;
COMMENT_LINE $F410 0x01                                                            ;
COMMENT_LINE $F410 ;
COMMENT_LINE $F410 The list is terminated by a pattern byte with the high bit cleared.   ;
COMMENT_LINE $F410 ;
COMMENT_LINE $F410 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F410 X-reg points to the vector list                                 ;
COMMENT_LINE $F410 ;
COMMENT_LINE $F410 EXIT: X-reg points to the terminator byte                             ;
COMMENT_LINE $F410 ;
COMMENT_LINE $F410 D-reg trashed                                                   ;
COMMENT_LINE $F410 -----------------------------------------------------------------------;
COMMENT $F410 Get next coordinate pair
FORCE_NO_SYMBOL $F410
COMMENT $F412 Send Y to A/D
FORCE_SYMBOL $F412 VIA_port_a
COMMENT $F414 Enable mux
FORCE_SYMBOL $F414 VIA_port_b
COMMENT $F416 Get pattern byte?
FORCE_NO_SYMBOL $F416
COMMENT $F418 Advance to next point in list
FORCE_NO_SYMBOL $F418
COMMENT $F41A Disable mux
FORCE_SYMBOL $F41A VIA_port_b
COMMENT $F41C Send X to A/D
FORCE_SYMBOL $F41C VIA_port_a
COMMENT $F41E Store pattern in shift register
FORCE_SYMBOL $F41E VIA_shift_reg
COMMENT $F420 Clear T1H
FORCE_SYMBOL $F420 VIA_t1_cnt_hi
COMMENT $F422 B-reg = T1 interrupt bit
FORCE_NO_SYMBOL $F422
COMMENT $F425 Wait for T1 to time out
FORCE_SYMBOL $F425 VIA_int_flags
COMMENT $F429 Wait a moment more
COMMENT $F42A Clear shift register (blank output)
FORCE_SYMBOL $F42A VIA_shift_reg
COMMENT $F42C Get next pattern byte
FORCE_NO_SYMBOL $F42C
COMMENT $F42E Go back if high bit of pattern is set
FORCE_SYMBOL $F430 Check0Ref
COMMENT_LINE $F433 -----------------------------------------------------------------------;
COMMENT_LINE $F433 F434    Draw_Pat_VL_a                                           ;
COMMENT_LINE $F433 F437    Draw_Pat_VL                                             ;
COMMENT_LINE $F433 F439    Draw_Pat_VL_d                                           ;
COMMENT_LINE $F433 ;
COMMENT_LINE $F433 All of these routines draw a series of patterned vectors.  The        ;
COMMENT_LINE $F433 pattern to use must already be specified in $C829.  When using        ;
COMMENT_LINE $F433 Draw_Pat_VL or Draw_Pat_VL_d, the number of vectors to draw minus 1   ;
COMMENT_LINE $F433 must be specified in $C823; when using Draw_Pat_VL_a, the number of   ;
COMMENT_LINE $F433 vectors to draw minus 1 must be passed in in the A register.          ;
COMMENT_LINE $F433 The vector list, pointed to by the X register, has the following      ;
COMMENT_LINE $F433 format:                                                               ;
COMMENT_LINE $F433 ;
COMMENT_LINE $F433 rel y, rel x, rel y, rel x, ...                                 ;
COMMENT_LINE $F433 ;
COMMENT_LINE $F433 Draw_Pat_VL_d starts at the (y,x) coordinates specified in the        ;
COMMENT_LINE $F433 D register and ignores the first pair of coordinates in the vector    ;
COMMENT_LINE $F433 list.                                                                 ;
COMMENT_LINE $F433 ;
COMMENT_LINE $F433 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F433 X-reg points to the vector list                                 ;
COMMENT_LINE $F433 A-reg = the number of vectors to draw (Draw_Pat_VL_a only)      ;
COMMENT_LINE $F433 D-reg = start (Y,X) coordinate (Draw_Pat_VL_d only)             ;
COMMENT_LINE $F433 $C829 contains the line pattern.                                ;
COMMENT_LINE $F433 ;
COMMENT_LINE $F433 EXIT: X-reg points to next byte after list                            ;
COMMENT_LINE $F433 ;
COMMENT_LINE $F433 D-reg trashed                                                   ;
COMMENT_LINE $F433 -----------------------------------------------------------------------;
FORCE_NO_SYMBOL $F434
COMMENT $F437 Get next coordinate pair
FORCE_NO_SYMBOL $F437
COMMENT $F439 Send Y to A/D
FORCE_SYMBOL $F439 VIA_port_a
COMMENT $F43B Enable mux
FORCE_SYMBOL $F43B VIA_port_b
COMMENT $F43D Point to next coordinate pair
FORCE_NO_SYMBOL $F43D
COMMENT $F43F Disable mux
FORCE_SYMBOL $F43F VIA_port_b
COMMENT $F441 Send X to A/D
FORCE_SYMBOL $F441 VIA_port_a
COMMENT $F443 Get default pattern
FORCE_SYMBOL $F443 Vec_Pattern
COMMENT $F446 B-reg = T1 interrupt bit
FORCE_NO_SYMBOL $F446
COMMENT $F448 Put pattern in shift register
FORCE_SYMBOL $F448 VIA_shift_reg
COMMENT $F44A Clear T1H (scale factor?)
FORCE_SYMBOL $F44A VIA_t1_cnt_hi
COMMENT $F44C Check if T1 timed out (note wasted byte)
FORCE_SYMBOL $F44C VIA_int_flags
COMMENT $F44F Update pattern if not
COMMENT_LINE $F451 Don't reset the zero reference if last line is really short?
COMMENT $F451 Clear shift register (blank output)
FORCE_SYMBOL $F451 VIA_shift_reg
COMMENT $F453 Get line counter
FORCE_NO_SYMBOL $F453
COMMENT $F456 Go back for more points
COMMENT_LINE $F459 This code is for lines that are not really short lines
COMMENT $F459 Get default pattern
FORCE_SYMBOL $F459 Vec_Pattern
COMMENT $F45C Update pattern register
FORCE_SYMBOL $F45C VIA_shift_reg
COMMENT $F45E Wait a moment
COMMENT $F45F Check if T1 timed out
FORCE_SYMBOL $F45F VIA_int_flags
COMMENT $F461 Update pattern again if not
COMMENT $F463 Get line counter
FORCE_NO_SYMBOL $F463
COMMENT $F466 Clear shift register (blank output)
FORCE_SYMBOL $F466 VIA_shift_reg
COMMENT $F468 Go back if more lines to draw
COMMENT $F46B Reset zero reference if necessary
FORCE_SYMBOL $F46B Check0Ref
COMMENT_LINE $F46E -----------------------------------------------------------------------;
COMMENT_LINE $F46E F46E    Draw_VL_mode                                            ;
COMMENT_LINE $F46E ;
COMMENT_LINE $F46E This routine processes the vector list pointed to by the X register.  ;
COMMENT_LINE $F46E The current scale factor is used.  The vector list has the following  ;
COMMENT_LINE $F46E format:                                                               ;
COMMENT_LINE $F46E ;
COMMENT_LINE $F46E mode, rel y, rel x,                                             ;
COMMENT_LINE $F46E mode, rel y, rel x,                                             ;
COMMENT_LINE $F46E .      .      .                                                ;
COMMENT_LINE $F46E .      .      .                                                ;
COMMENT_LINE $F46E mode, rel y, rel x,                                             ;
COMMENT_LINE $F46E 0x01                                                            ;
COMMENT_LINE $F46E ;
COMMENT_LINE $F46E where mode has the following meaning:                                 ;
COMMENT_LINE $F46E ;
COMMENT_LINE $F46E < 0  use the pattern in $C829                                   ;
COMMENT_LINE $F46E = 0  move to specified endpoint                                 ;
COMMENT_LINE $F46E = 1  end of list, so return                                     ;
COMMENT_LINE $F46E > 1  draw to specified endpoint                                 ;
COMMENT_LINE $F46E ;
COMMENT_LINE $F46E ENTRY DP = $D0                                                        ;
COMMENT_LINE $F46E X-reg points to the vector list                                 ;
COMMENT_LINE $F46E $C829 contains the line pattern.                                ;
COMMENT_LINE $F46E ;
COMMENT_LINE $F46E EXIT: X-reg points to next byte after terminator                      ;
COMMENT_LINE $F46E ;
COMMENT_LINE $F46E D-reg trashed                                                   ;
COMMENT_LINE $F46E -----------------------------------------------------------------------;
COMMENT $F46E Save old Check0Ref flag
FORCE_SYMBOL $F46E Vec_0Ref_Enable
COMMENT $F473 Don't reset the zero reference yet
FORCE_SYMBOL $F473 Vec_0Ref_Enable
COMMENT $F476 Get the next mode byte
COMMENT $F47A If <0, draw a patterned line
COMMENT $F480 If =0, move to the next point
FORCE_SYMBOL $F480 Mov_Draw_VL
COMMENT $F488 If <>1, draw a solid line
FORCE_SYMBOL $F488 Draw_VL
COMMENT $F48D If =1, exit
COMMENT $F48F Restore old Check0Ref flag
FORCE_SYMBOL $F48F Vec_0Ref_Enable
COMMENT $F492 Reset zero reference if necessary
FORCE_SYMBOL $F492 Check0Ref
COMMENT_LINE $F495 -----------------------------------------------------------------------;
COMMENT_LINE $F495 F495    Print_Str                                               ;
COMMENT_LINE $F495 ;
COMMENT_LINE $F495 This is the routine which does the actual printing of a string.  The  ;
COMMENT_LINE $F495 U register points to the start of the string, while $C82A contains    ;
COMMENT_LINE $F495 the height of the character, cell, and $C82B contains the width of    ;
COMMENT_LINE $F495 the character cell.  The string is terminated with an 0x80.           ;
COMMENT_LINE $F495 ;
COMMENT_LINE $F495 The string is displayed by drawing 7 horizontal rows of dots.  The    ;
COMMENT_LINE $F495 first row is drawn for each character, then the second, etc.  The     ;
COMMENT_LINE $F495 character generation table is located at ($F9D4 + $20).  Only         ;
COMMENT_LINE $F495 characters 0x20-0x6F (upper case) are defined; the lower case         ;
COMMENT_LINE $F495 characters a-o produce special icons.                                 ;
COMMENT_LINE $F495 ;
COMMENT_LINE $F495 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F495 U-reg points to the start of the string                         ;
COMMENT_LINE $F495 ;
COMMENT_LINE $F495 EXIT: U-reg points to next byte after terminator                      ;
COMMENT_LINE $F495 ;
COMMENT_LINE $F495 D-reg, X-reg trashed                                            ;
COMMENT_LINE $F495 -----------------------------------------------------------------------;
COMMENT $F495 Save string pointer
FORCE_SYMBOL $F495 Vec_Str_Ptr
COMMENT $F498 Point to start of chargen bitmaps
COMMENT $F49B $8x = enable RAMP?
FORCE_NO_SYMBOL $F49B
COMMENT $F49E Clear D/A output
FORCE_SYMBOL $F49E VIA_port_a
COMMENT $F4A0 Shift reg mode = 110, T1 PB7 enabled
FORCE_SYMBOL $F4A0 VIA_aux_cntl
COMMENT $F4A2 Point to start of chargen bitmaps
COMMENT $F4A5 Update RAMP, = mux to channel 1
FORCE_SYMBOL $F4A5 VIA_port_b
COMMENT $F4A7 Enable mux
FORCE_SYMBOL $F4A7 VIA_port_b
FORCE_NO_SYMBOL $F4A9
COMMENT $F4AC Wait a moment
COMMENT $F4AD Disable mux
FORCE_SYMBOL $F4AD VIA_port_b
COMMENT $F4AF Enable RAMP, set mux to channel 0
FORCE_SYMBOL $F4AF VIA_port_b
COMMENT $F4B1 Enable mux
FORCE_SYMBOL $F4B1 VIA_port_b
COMMENT $F4B3 I think this is a delay only
FORCE_NO_SYMBOL $F4B3
COMMENT $F4B6 Enable RAMP, disable mux
FORCE_SYMBOL $F4B6 VIA_port_b
COMMENT $F4B8 Get text width
FORCE_SYMBOL $F4B8 Vec_Text_Width
COMMENT $F4BB Send it to the D/A
FORCE_SYMBOL $F4BB VIA_port_a
FORCE_NO_SYMBOL $F4BD
COMMENT $F4C0 Point to start of text string
FORCE_SYMBOL $F4C0 Vec_Str_Ptr
COMMENT $F4C3 Disable RAMP, disable mux
FORCE_SYMBOL $F4C3 VIA_port_b
COMMENT $F4C7 Get bitmap from chargen table
COMMENT $F4C9 Save in shift register
FORCE_SYMBOL $F4C9 VIA_shift_reg
COMMENT $F4CB Get next character
COMMENT $F4CD Go back if not terminator
FORCE_NO_SYMBOL $F4CF
COMMENT $F4D1 Enable RAMP, disable mux
FORCE_SYMBOL $F4D1 VIA_port_b
COMMENT $F4D3 Negate text width to D/A
FORCE_SYMBOL $F4D3 VIA_port_a
FORCE_NO_SYMBOL $F4D5
COMMENT $F4D7 Disable RAMP, disable mux
FORCE_SYMBOL $F4D7 VIA_port_b
COMMENT $F4D9 Check for last row
COMMENT $F4DC Branch if last row
COMMENT $F4DE Point to next chargen row
FORCE_NO_SYMBOL $F4DE
COMMENT $F4E1 Get string length
FORCE_SYMBOL $F4E3 Vec_Str_Ptr
COMMENT $F4E6 -  2
FORCE_NO_SYMBOL $F4E6
COMMENT $F4E8 *  2
COMMENT $F4E9 Delay a moment
FORCE_NO_SYMBOL $F4EB
COMMENT $F4EF Delay some more in a loop
COMMENT $F4F1 Enable RAMP, disable mux
FORCE_SYMBOL $F4F1 VIA_port_b
COMMENT $F4F3 Get text height
FORCE_SYMBOL $F4F3 Vec_Text_Height
COMMENT $F4F6 Store text height in D/A
FORCE_SYMBOL $F4F6 VIA_port_a
COMMENT $F4F8 Enable mux
FORCE_SYMBOL $F4F8 VIA_port_b
FORCE_NO_SYMBOL $F4FA
COMMENT $F4FD Wait a moment
COMMENT $F4FE Enable RAMP, disable mux
FORCE_SYMBOL $F4FE VIA_port_b
COMMENT $F500 Clear D/A
FORCE_SYMBOL $F500 VIA_port_a
COMMENT $F502 Disable RAMP, disable mux
FORCE_SYMBOL $F502 VIA_port_b
COMMENT $F504 Enable RAMP, disable mux
FORCE_SYMBOL $F504 VIA_port_b
COMMENT $F506 $0x = disable RAMP?
FORCE_NO_SYMBOL $F506
COMMENT $F508 Go back for next scan line
FORCE_NO_SYMBOL $F50A
COMMENT $F50C T1->PB7 enabled
FORCE_SYMBOL $F50C VIA_aux_cntl
COMMENT $F50E Reset the zero reference
FORCE_SYMBOL $F50E Reset0Ref
COMMENT_LINE $F511 -----------------------------------------------------------------------;
COMMENT_LINE $F511 F511    Random_3                                                ;
COMMENT_LINE $F511 F517    Random                                                  ;
COMMENT_LINE $F511 ;
COMMENT_LINE $F511 This routine generates a random 1-byte number, and places it in the   ;
COMMENT_LINE $F511 A register.  Random_3 runs through the random number generator        ;
COMMENT_LINE $F511 algorithm three times.  The random number seed is stored in the       ;
COMMENT_LINE $F511 three bytes pointed to by $C87B.                                      ;
COMMENT_LINE $F511 ;
COMMENT_LINE $F511 EXIT: A-reg contains the generated random number                      ;
COMMENT_LINE $F511 ;
COMMENT_LINE $F511 All other registers are preserved.                              ;
COMMENT_LINE $F511 -----------------------------------------------------------------------;
FORCE_NO_SYMBOL $F513
FORCE_SYMBOL $F51A Vec_Seed_Ptr
FORCE_NO_SYMBOL $F51D
FORCE_NO_SYMBOL $F523
FORCE_NO_SYMBOL $F526
FORCE_NO_SYMBOL $F528
FORCE_NO_SYMBOL $F52A
FORCE_NO_SYMBOL $F52F
COMMENT_LINE $F533 -----------------------------------------------------------------------;
COMMENT_LINE $F533 F533    Init_Music_Buf                                          ;
COMMENT_LINE $F533 ;
COMMENT_LINE $F533 This routine clears out the music work buffer, located at             ;
COMMENT_LINE $F533 $C83F-$C84C.                                                          ;
COMMENT_LINE $F533 ;
COMMENT_LINE $F533 X-reg, D-reg trashed                                            ;
COMMENT_LINE $F533 -----------------------------------------------------------------------;
FORCE_NO_SYMBOL $F533
FORCE_SYMBOL $F535 Vec_Music_Work
FORCE_NO_SYMBOL $F53A
FORCE_NO_SYMBOL $F53C
COMMENT_LINE $F53F -----------------------------------------------------------------------;
COMMENT_LINE $F53F F53F    Clear_x_b                                               ;
COMMENT_LINE $F53F ;
COMMENT_LINE $F53F This routine clears to 0 the block of memory starting at the          ;
COMMENT_LINE $F53F address contained in the X register, and continuing for the number    ;
COMMENT_LINE $F53F of bytes specified by B+1.                                            ;
COMMENT_LINE $F53F ;
COMMENT_LINE $F53F ENTRY X-reg points to the start of the RAM to be cleared.             ;
COMMENT_LINE $F53F B-reg = number of bytes minus 1 to clear.                       ;
COMMENT_LINE $F53F ;
COMMENT_LINE $F53F EXIT: D-reg = $FFFF                                                   ;
COMMENT_LINE $F53F -----------------------------------------------------------------------;
COMMENT_LINE $F542 -----------------------------------------------------------------------;
COMMENT_LINE $F542 F542    Clear_C8_RAM    (never used by GCE carts?)              ;
COMMENT_LINE $F542 ;
COMMENT_LINE $F542 This routine clears to 0 the block of memory in the range             ;
COMMENT_LINE $F542 $C800-$C8FF.                                                          ;
COMMENT_LINE $F542 ;
COMMENT_LINE $F542 EXIT: X-reg = $C800                                                   ;
COMMENT_LINE $F542 D-reg = $FFFF                                                   ;
COMMENT_LINE $F542 -----------------------------------------------------------------------;
FORCE_NO_SYMBOL $F542
COMMENT_LINE $F545 -----------------------------------------------------------------------;
COMMENT_LINE $F545 F545    Clear_x_256                                             ;
COMMENT_LINE $F545 F548    Clear_x_d                                               ;
COMMENT_LINE $F545 ;
COMMENT_LINE $F545 This routine clears the block of memory starting at the contained     ;
COMMENT_LINE $F545 in the X register to zero.                                            ;
COMMENT_LINE $F545 ;
COMMENT_LINE $F545 ENTRY X-reg points to the start of RAM to be cleared                  ;
COMMENT_LINE $F545 D-reg = number of bytes to clear minus 1 (Clear_x_d only)       ;
COMMENT_LINE $F545 ;
COMMENT_LINE $F545 EXIT: D-reg = $FFFF                                                   ;
COMMENT_LINE $F545 -----------------------------------------------------------------------;
FORCE_NO_SYMBOL $F545
FORCE_NO_SYMBOL $F54A
COMMENT_LINE $F550 -----------------------------------------------------------------------;
COMMENT_LINE $F550 F550    Clear_x_b_80                                            ;
COMMENT_LINE $F550 F552    Clear_x_b_a                                             ;
COMMENT_LINE $F550 ;
COMMENT_LINE $F550 This routine sets the block of memory pointed to by the X register    ;
COMMENT_LINE $F550 to $80 or the A register.  The B register specifies the number of     ;
COMMENT_LINE $F550 bytes to be cleared.                                                  ;
COMMENT_LINE $F550 ;
COMMENT_LINE $F550 ENTRY A-reg = byte to be stored (Clear_x_b_a only)                    ;
COMMENT_LINE $F550 B-reg = number of bytes to clear ($00 = 256)                    ;
COMMENT_LINE $F550 X-reg points to start of memory block to clear                  ;
COMMENT_LINE $F550 ;
COMMENT_LINE $F550 EXIT: A-reg = $80 (Clear_x_b_80 only)                                 ;
COMMENT_LINE $F550 B-reg = $00                                                     ;
COMMENT_LINE $F550 ;
COMMENT_LINE $F550 All other registers preserved.                                  ;
COMMENT_LINE $F550 -----------------------------------------------------------------------;
FORCE_NO_SYMBOL $F550
FORCE_NO_SYMBOL $F557
COMMENT_LINE $F55A -----------------------------------------------------------------------;
COMMENT_LINE $F55A F55A    Dec_3_Counters                                          ;
COMMENT_LINE $F55A F55E    Dec_6_Counters                                          ;
COMMENT_LINE $F55A ;
COMMENT_LINE $F55A These routines check either the first three or all six of the         ;
COMMENT_LINE $F55A default counters at $C82E-$C833 and decrements those which are not    ;
COMMENT_LINE $F55A already zero.                                                         ;
COMMENT_LINE $F55A ;
COMMENT_LINE $F55A EXIT: X-reg points to the default counters at $C82E                   ;
COMMENT_LINE $F55A B-reg = $FF                                                     ;
COMMENT_LINE $F55A ;
COMMENT_LINE $F55A All other registers preserved.                                  ;
COMMENT_LINE $F55A -----------------------------------------------------------------------;
FORCE_NO_SYMBOL $F55A
FORCE_NO_SYMBOL $F55E
FORCE_SYMBOL $F560 Vec_Counters
COMMENT_LINE $F563 -----------------------------------------------------------------------;
COMMENT_LINE $F563 F563    Dec_Counters                                            ;
COMMENT_LINE $F563 ;
COMMENT_LINE $F563 This routine checks the counters pointed to by the X register and     ;
COMMENT_LINE $F563 decrements those which are not already zero.                          ;
COMMENT_LINE $F563 ;
COMMENT_LINE $F563 ENTRY B-reg = number of counters minus 1                              ;
COMMENT_LINE $F563 X-reg points to counter bytes                                   ;
COMMENT_LINE $F563 ;
COMMENT_LINE $F563 EXIT: B-reg = $FF                                                     ;
COMMENT_LINE $F563 ;
COMMENT_LINE $F563 All other registers preserved.                                  ;
COMMENT_LINE $F563 -----------------------------------------------------------------------;
COMMENT_LINE $F56D -----------------------------------------------------------------------;
COMMENT_LINE $F56D F56D    Delay_3         30 cycles                               ;
COMMENT_LINE $F56D F571    Delay_2         25 cycles                               ;
COMMENT_LINE $F56D F575    Delay_1         20 cycles                               ;
COMMENT_LINE $F56D F579    Delay_0         12 cycles                               ;
COMMENT_LINE $F56D F57A    Delay_b         5;B + 10 cycles                         ;
COMMENT_LINE $F56D F57D    Delay_RTS       5 cycles                                ;
COMMENT_LINE $F56D ;
COMMENT_LINE $F56D Each of these routines loads the B-register with the indicated        ;
COMMENT_LINE $F56D value, and then loops until the B register value has decremented      ;
COMMENT_LINE $F56D below zero.  Delay_RTS is just an RTS instruction, but at least       ;
COMMENT_LINE $F56D one GCE cartridge calls it.                                           ;
COMMENT_LINE $F56D ;
COMMENT_LINE $F56D Cycle counts do not include timing of the instructions used to        ;
COMMENT_LINE $F56D call the delay routines.                                              ;
COMMENT_LINE $F56D ;
COMMENT_LINE $F56D ENTRY B-reg = delay count (Delay_b only)                              ;
COMMENT_LINE $F56D ;
COMMENT_LINE $F56D EXIT: B-reg = $FF (except Delay_RTS)                                  ;
COMMENT_LINE $F56D -----------------------------------------------------------------------;
COMMENT $F56D 2 cycles
FORCE_NO_SYMBOL $F56D
COMMENT $F56F 3 cycles
COMMENT $F571 2 cycles
FORCE_NO_SYMBOL $F571
COMMENT $F573 3 cycles
COMMENT $F575 2 cycles
FORCE_NO_SYMBOL $F575
COMMENT $F577 3 cycles
COMMENT $F579 2 cycles
COMMENT $F57A 2 cycles
COMMENT $F57B 3 cycles
COMMENT $F57D 5 cycles
COMMENT_LINE $F57E -----------------------------------------------------------------------;
COMMENT_LINE $F57E F57E    Bitmask_a                                               ;
COMMENT_LINE $F57E ;
COMMENT_LINE $F57E This routine takes a bit number, specified in the A register, and     ;
COMMENT_LINE $F57E returns a bit mask with only the specified bit set.                   ;
COMMENT_LINE $F57E ;
COMMENT_LINE $F57E ENTRY A-reg contains the bit number                                   ;
COMMENT_LINE $F57E ;
COMMENT_LINE $F57E EXIT: A-reg contains the bit mask                                     ;
COMMENT_LINE $F57E ;
COMMENT_LINE $F57E X-reg trashed                                                   ;
COMMENT_LINE $F57E -----------------------------------------------------------------------;
FORCE_SYMBOL $F57E Bit_Masks
COMMENT_LINE $F584 -----------------------------------------------------------------------;
COMMENT_LINE $F584 F584    Abs_a_b                                                 ;
COMMENT_LINE $F584 F58B    Abs_b                                                   ;
COMMENT_LINE $F584 ;
COMMENT_LINE $F584 This routine returns the absolute value of the two single byte        ;
COMMENT_LINE $F584 numbers passed in in the A and B registers.  Abs_b only uses the B    ;
COMMENT_LINE $F584 register.  There is a special case: 0x80 is returned as 0x7F.         ;
COMMENT_LINE $F584 ;
COMMENT_LINE $F584 ENTRY A-reg contains first value                                      ;
COMMENT_LINE $F584 B-reg contains second value (Abs_a_b only)                      ;
COMMENT_LINE $F584 ;
COMMENT_LINE $F584 EXIT: A-reg contains absolute value of first value                    ;
COMMENT_LINE $F584 B-reg contains absolute value of second value (Abs_a_b only)    ;
COMMENT_LINE $F584 ;
COMMENT_LINE $F584 All other registers preserved.                                  ;
COMMENT_LINE $F584 -----------------------------------------------------------------------;
COMMENT_LINE $F593 -----------------------------------------------------------------------;
COMMENT_LINE $F593 F593    Rise_Run_Angle                                          ;
COMMENT_LINE $F593 ;
COMMENT_LINE $F593 Given a (rise,run) pair, this routine calculates the angle which      ;
COMMENT_LINE $F593 corresponds to that (rise,run) pair.  The returned angle is relative  ;
COMMENT_LINE $F593 to the x-axis (+ is CCW), so to convert it to a Vectrex angle         ;
COMMENT_LINE $F593 (relative to the y-axis, + is CCW), you must subtract the number 0x10 ;
COMMENT_LINE $F593 (90 degrees) from the returned value.                                 ;
COMMENT_LINE $F593 ;
COMMENT_LINE $F593 ENTRY DP = $C8                                                        ;
COMMENT_LINE $F593 A-reg = rise value                                              ;
COMMENT_LINE $F593 B-reg = run value                                               ;
COMMENT_LINE $F593 ;
COMMENT_LINE $F593 EXIT: A-reg = the angle from the x-axis                               ;
COMMENT_LINE $F593 B-reg = the angle from the x-axis                               ;
COMMENT_LINE $F593 ;
COMMENT_LINE $F593 All other registers preserved.                                  ;
COMMENT_LINE $F593 -----------------------------------------------------------------------;
FORCE_SYMBOL $F595 Vec_RiseRun_Tmp
FORCE_NO_SYMBOL $F598
FORCE_SYMBOL $F59E Vec_Angle
FORCE_SYMBOL $F5A0 Vec_RiseRun_Tmp
FORCE_SYMBOL $F5A4 Vec_RiseRun_Tmp
FORCE_SYMBOL $F5A6 Vec_RiseRun_Tmp
FORCE_SYMBOL $F5AA Vec_Angle
FORCE_NO_SYMBOL $F5B2
FORCE_SYMBOL $F5B6 Vec_RiseRun_Tmp
FORCE_SYMBOL $F5B8 Vec_Angle
FORCE_SYMBOL $F5BA DFC24
FORCE_SYMBOL $F5BF DFC2C
FORCE_NO_SYMBOL $F5C4
FORCE_NO_SYMBOL $F5C6
FORCE_NO_SYMBOL $F5C8
FORCE_SYMBOL $F5D3 Vec_Angle
FORCE_SYMBOL $F5D5 Vec_Angle
COMMENT_LINE $F5D9 -----------------------------------------------------------------------;
COMMENT_LINE $F5D9 F5D9    Get_Rise_Idx                                            ;
COMMENT_LINE $F5D9 F5DB    Get_Run_Idx                                             ;
COMMENT_LINE $F5D9 ;
COMMENT_LINE $F5D9 These routines are responsible for generating the two index pairs     ;
COMMENT_LINE $F5D9 which are required by the rest of the rotation routines.  Each index  ;
COMMENT_LINE $F5D9 pair is two bytes long, and has the following format:                 ;
COMMENT_LINE $F5D9 ;
COMMENT_LINE $F5D9 The high byte is obtained by masking the anglewith 0x1F (this   ;
COMMENT_LINE $F5D9 forces the angle to be between 0 and 180 degrees), and then     ;
COMMENT_LINE $F5D9 using this value to index into the multiplier table.            ;
COMMENT_LINE $F5D9 ;
COMMENT_LINE $F5D9 The lower byte contains information about whether the angle     ;
COMMENT_LINE $F5D9 lies along either the x or y axis, and whether the rise/run     ;
COMMENT_LINE $F5D9 will be positive or negative.                                   ;
COMMENT_LINE $F5D9 ;
COMMENT_LINE $F5D9 0 => positive rise, not on an axis, or                  ;
COMMENT_LINE $F5D9 negative run, not on an axis.                      ;
COMMENT_LINE $F5D9 0x80 => negative rise, not on an axis, or                  ;
COMMENT_LINE $F5D9 positive run, not on an axis.                      ;
COMMENT_LINE $F5D9 1 => positive rise, on an axis, or                      ;
COMMENT_LINE $F5D9 negative run, on an axis.                          ;
COMMENT_LINE $F5D9 0x81 => negative rise, on an axis, or                      ;
COMMENT_LINE $F5D9 positive run, on an axis.                          ;
COMMENT_LINE $F5D9 ;
COMMENT_LINE $F5D9 ENTRY A-reg = the angle value                                         ;
COMMENT_LINE $F5D9 ;
COMMENT_LINE $F5D9 EXIT: A-reg = slope?                                                  ;
COMMENT_LINE $F5D9 B-reg = slope direction?                                        ;
COMMENT_LINE $F5D9 ;
COMMENT_LINE $F5D9 X-reg trashed                                                   ;
COMMENT_LINE $F5D9 -----------------------------------------------------------------------;
COMMENT $F5D9 Offset angle by 90 degrees
FORCE_NO_SYMBOL $F5D9
COMMENT $F5DB Get address of slope table
FORCE_SYMBOL $F5DB DFC6D
COMMENT $F5DF If angle in 180-360,
FORCE_NO_SYMBOL $F5DF
COMMENT $F5E3 flag negative rise or positive run
FORCE_NO_SYMBOL $F5E3
COMMENT $F5E5 Mask to multiple of 180 degrees
FORCE_NO_SYMBOL $F5E5
COMMENT $F5E7 If 90 degrees
FORCE_NO_SYMBOL $F5E7
COMMENT $F5EB then rise or run is on an axis
COMMENT $F5EC Get slope from slope table
COMMENT_LINE $F5EF -----------------------------------------------------------------------;
COMMENT_LINE $F5EF F5EF    Rise_Run_Idx                                            ;
COMMENT_LINE $F5EF ;
COMMENT_LINE $F5EF This routine gets the index pair for both the rise and run, using     ;
COMMENT_LINE $F5EF the passed-in angle value.                                            ;
COMMENT_LINE $F5EF ;
COMMENT_LINE $F5EF ENTRY DP = $C8                                                        ;
COMMENT_LINE $F5EF $C836 contains the angle value                                  ;
COMMENT_LINE $F5EF ;
COMMENT_LINE $F5EF EXIT: $C837-$C838 contains the index pair for the run                 ;
COMMENT_LINE $F5EF $C839-$C83A contains the index pair for the rise                ;
COMMENT_LINE $F5EF ;
COMMENT_LINE $F5EF D-reg trashed                                                   ;
COMMENT_LINE $F5EF -----------------------------------------------------------------------;
COMMENT $F5EF Save X-reg
COMMENT $F5F1 Get angle
FORCE_SYMBOL $F5F1 Vec_Angle
COMMENT $F5F3 Get run index pair for angle
FORCE_SYMBOL $F5F5 Vec_Run_Index
COMMENT $F5F7 Get angle
FORCE_SYMBOL $F5F7 Vec_Angle
COMMENT $F5F9 Get rise index pair for angle
FORCE_SYMBOL $F5FB Vec_Rise_Index
COMMENT $F5FD Restore X-reg and return
COMMENT_LINE $F5FF -----------------------------------------------------------------------;
COMMENT_LINE $F5FF F5FF    Rise_Run_X                                              ;
COMMENT_LINE $F5FF F601    Rise_Run_Y                                              ;
COMMENT_LINE $F5FF F603    Rise_Run_Len                                            ;
COMMENT_LINE $F5FF ;
COMMENT_LINE $F5FF This routine takes an angle value which is relative to the x- or      ;
COMMENT_LINE $F5FF y-axis, and calculates the rise and run for that angle, relative to a ;
COMMENT_LINE $F5FF passed-in scalar velocity value.  A large scalar value will cause an  ;
COMMENT_LINE $F5FF object to move quickly, while a small scalar value will cause an      ;
COMMENT_LINE $F5FF object to move more slowly.                                           ;
COMMENT_LINE $F5FF ;
COMMENT_LINE $F5FF Keep in mind that most games store x & y coordinates as 2 bytes each, ;
COMMENT_LINE $F5FF with the upper byte being the actual coordinate, and the lower byte   ;
COMMENT_LINE $F5FF being that which is usually added to the rise/run value; when the     ;
COMMENT_LINE $F5FF lower byte overflows into the hi byte, then the object will 'move'.   ;
COMMENT_LINE $F5FF The rise/run values returned here are meant to be added to the low    ;
COMMENT_LINE $F5FF byte -- NOT the hi byte!!                                             ;
COMMENT_LINE $F5FF ;
COMMENT_LINE $F5FF ENTRY DP = $C8                                                        ;
COMMENT_LINE $F5FF A-reg = the scalar velocity value (except Rise_Run_Len)         ;
COMMENT_LINE $F5FF B-reg = the Vectrex angle value                                 ;
COMMENT_LINE $F5FF ;
COMMENT_LINE $F5FF EXIT: A-reg = the rise value                                          ;
COMMENT_LINE $F5FF B-reg = the run value                                           ;
COMMENT_LINE $F5FF ;
COMMENT_LINE $F5FF All other registers are saved.                                  ;
COMMENT_LINE $F5FF -----------------------------------------------------------------------;
FORCE_NO_SYMBOL $F5FF
FORCE_SYMBOL $F601 Vec_Angle
FORCE_SYMBOL $F603 Vec_RiseRun_Len
COMMENT $F605 Get index pair of angle
COMMENT $F607 Get run value
COMMENT $F60A Save run value
COMMENT $F60C Get rise value
COMMENT $F60E Restore run value and return
COMMENT_LINE $F610 -----------------------------------------------------------------------;
COMMENT_LINE $F610 F610    Rot_VL_ab                                               ;
COMMENT_LINE $F610 F616    Rot_VL                                                  ;
COMMENT_LINE $F610 ;
COMMENT_LINE $F610 This routine rotates a vector list of length 'n+1', where 'n' is      ;
COMMENT_LINE $F610 specified by the value in the B register.  The A register contains    ;
COMMENT_LINE $F610 the rotation value, and the X contains a pointer to the vector list.  ;
COMMENT_LINE $F610 The U register contains a pointer to a buffer into which the          ;
COMMENT_LINE $F610 transformed points are to be saved.  The vector list has the          ;
COMMENT_LINE $F610 following format:                                                     ;
COMMENT_LINE $F610 ;
COMMENT_LINE $F610 rel y, rel x, rel y, rel x, ...                                 ;
COMMENT_LINE $F610 ;
COMMENT_LINE $F610 ENTRY A-reg = rotation angle value (Rot_VL_ab only)                   ;
COMMENT_LINE $F610 $C836 = rotation angle value (Rot_VL only)                      ;
COMMENT_LINE $F610 B-reg = number of points - 1 (Rot_VL_ab only)                   ;
COMMENT_LINE $F610 $C823 = number of points - 1 (Rot_VL only)                      ;
COMMENT_LINE $F610 X-reg points to original vector list                            ;
COMMENT_LINE $F610 U-reg points to rotated vector list                             ;
COMMENT_LINE $F610 ;
COMMENT_LINE $F610 EXIT: DP = $C8                                                        ;
COMMENT_LINE $F610 X-reg points to next byte after list                            ;
COMMENT_LINE $F610 U-reg points to next byte after rotated list                    ;
COMMENT_LINE $F610 ;
COMMENT_LINE $F610 D-reg trashed                                                   ;
COMMENT_LINE $F610 -----------------------------------------------------------------------;
FORCE_SYMBOL $F610 Vec_Angle
FORCE_NO_SYMBOL $F613
FORCE_SYMBOL $F618 DP_to_C8
COMMENT_LINE $F61F -----------------------------------------------------------------------;
COMMENT_LINE $F61F F61F    Rot_VL_Mode                                             ;
COMMENT_LINE $F61F F62B    Rot_VL_M_dft                                            ;
COMMENT_LINE $F61F ;
COMMENT_LINE $F61F This routine rotates a vector list having the following format:       ;
COMMENT_LINE $F61F ;
COMMENT_LINE $F61F mode, rel y, rel x,                                             ;
COMMENT_LINE $F61F mode, rel y, rel x,                                             ;
COMMENT_LINE $F61F .     .      .                                                ;
COMMENT_LINE $F61F .     .      .                                                ;
COMMENT_LINE $F61F mode, rel y, rel x,                                             ;
COMMENT_LINE $F61F 0x01                                                            ;
COMMENT_LINE $F61F ;
COMMENT_LINE $F61F The A register contains the rotation value, and the X contains a      ;
COMMENT_LINE $F61F pointer to the vector list.  The U register contains a pointer to a   ;
COMMENT_LINE $F61F buffer into which the transformed points are to be saved.             ;
COMMENT_LINE $F61F ;
COMMENT_LINE $F61F ENTRY DP = $C8                                                        ;
COMMENT_LINE $F61F A-reg = rotation angle value (Rot_VL_Mode only)                 ;
COMMENT_LINE $F61F X-reg points to original vector list                            ;
COMMENT_LINE $F61F U-reg points to rotated vector list                             ;
COMMENT_LINE $F61F ;
COMMENT_LINE $F61F EXIT: X-reg points to next byte after list                            ;
COMMENT_LINE $F61F U-reg points to next byte after rotated list                    ;
COMMENT_LINE $F61F ;
COMMENT_LINE $F61F D-reg trashed                                                   ;
COMMENT_LINE $F61F -----------------------------------------------------------------------;
COMMENT $F61F Save angle
FORCE_SYMBOL $F61F Vec_Angle
COMMENT $F622 Save DP register
COMMENT $F624 DP to RAM
FORCE_SYMBOL $F624 DP_to_C8
COMMENT $F627 Store $C8 (negative value) into $C823
FORCE_NO_SYMBOL $F627
COMMENT $F629 Get index pair of angle
COMMENT $F62B Get mode byte
COMMENT $F62D Copy to destination
COMMENT $F62F Rotate if not end of list
COMMENT $F631 Exit with $C823 cleared
FORCE_NO_SYMBOL $F631
COMMENT $F633 Restore DP register and return
COMMENT $F635 Decrement count for (y,x) list
FORCE_NO_SYMBOL $F635
COMMENT $F637 Get y coordinate
COMMENT $F63B Store partial y coordinate
FORCE_NO_SYMBOL $F63B
COMMENT $F63D Get x coordinate
FORCE_NO_SYMBOL $F63D
COMMENT $F641 Add to partial y coordinate
FORCE_NO_SYMBOL $F641
COMMENT $F643 Store rotated y coordinate
COMMENT $F645 Get y coordinate
COMMENT $F649 Store partial x coordinate
FORCE_NO_SYMBOL $F649
COMMENT $F64B Get x coordinate
COMMENT $F64F Add to partial x coordinate
FORCE_NO_SYMBOL $F64F
COMMENT $F651 Store rotated x coordinate
COMMENT $F653 Get counter
FORCE_NO_SYMBOL $F653
COMMENT $F655 If negative, go back to mode list loop
COMMENT $F657 If non-zero, go back to (y,x) list loop
COMMENT_LINE $F65B -----------------------------------------------------------------------;
COMMENT_LINE $F65B F65B    Xform_Run_a                                             ;
COMMENT_LINE $F65B F65D    Xform_Run                                               ;
COMMENT_LINE $F65B ;
COMMENT_LINE $F65B These two routines generate a run value, using the run index pair in  ;
COMMENT_LINE $F65B $C837-$C838.  For Xform_Run_a the scalar value is passed in the       ;
COMMENT_LINE $F65B A register, while for Xform_Run, the scalar value must already be in  ;
COMMENT_LINE $F65B $C83B.  The transformed value is return in the A register.            ;
COMMENT_LINE $F65B ;
COMMENT_LINE $F65B ENTRY DP = $C8                                                        ;
COMMENT_LINE $F65B A-reg = length for rise/run (Xform_Rise_a only)                 ;
COMMENT_LINE $F65B ;
COMMENT_LINE $F65B EXIT: A-reg = run value                                               ;
COMMENT_LINE $F65B ;
COMMENT_LINE $F65B B-reg trashed                                                   ;
COMMENT_LINE $F65B -----------------------------------------------------------------------;
FORCE_SYMBOL $F65B Vec_RiseRun_Len
FORCE_SYMBOL $F65D Vec_Run_Index
COMMENT_LINE $F661 -----------------------------------------------------------------------;
COMMENT_LINE $F661 F661    Xform_Rise_a                                            ;
COMMENT_LINE $F661 F663    Xform_Rise                                              ;
COMMENT_LINE $F661 ;
COMMENT_LINE $F661 These two routines generate a rise value, using the rise index pair   ;
COMMENT_LINE $F661 in $C839-$C83A.  For Xform_Rise_a the scalar value is passed in the   ;
COMMENT_LINE $F661 A register, while for Xform_Rise, the scalar value must already be    ;
COMMENT_LINE $F661 in $C83B.  The transformed value is return in the A register.         ;
COMMENT_LINE $F661 ;
COMMENT_LINE $F661 ENTRY DP = $C8                                                        ;
COMMENT_LINE $F661 A-reg = length for rise/run (Xform_Run_a only)                  ;
COMMENT_LINE $F661 ;
COMMENT_LINE $F661 EXIT: A-reg = rise value                                              ;
COMMENT_LINE $F661 ;
COMMENT_LINE $F661 B-reg trashed                                                   ;
COMMENT_LINE $F661 -----------------------------------------------------------------------;
FORCE_SYMBOL $F661 Vec_RiseRun_Len
FORCE_SYMBOL $F663 Vec_Rise_Index
FORCE_NO_SYMBOL $F665
FORCE_NO_SYMBOL $F667
FORCE_SYMBOL $F66B Vec_RiseRun_Len
FORCE_SYMBOL $F66F Vec_RiseRun_Len
FORCE_NO_SYMBOL $F673
FORCE_NO_SYMBOL $F677
FORCE_NO_SYMBOL $F679
COMMENT_LINE $F67F -----------------------------------------------------------------------;
COMMENT_LINE $F67F F67F    Move_Mem_a_1                                            ;
COMMENT_LINE $F67F F683    Move_Mem_a                                              ;
COMMENT_LINE $F67F ;
COMMENT_LINE $F67F This routine copies a block of memory, starting at the hi address,    ;
COMMENT_LINE $F67F and working down to the low address.  The base of the source address  ;
COMMENT_LINE $F67F is specified in the U register, and the base of the destination       ;
COMMENT_LINE $F67F address is  specified in the X register.  The A register contains     ;
COMMENT_LINE $F67F the number of bytes to copy; 0x80 is the maximum value which can      ;
COMMENT_LINE $F67F be specified.                                                         ;
COMMENT_LINE $F67F ;
COMMENT_LINE $F67F ENTRY A-reg = byte count (Move_Mem_a only)                            ;
COMMENT_LINE $F67F A-reg = byte count minus 1 (Move_Mem_a_1 only)                  ;
COMMENT_LINE $F67F X-reg points to the destination                                 ;
COMMENT_LINE $F67F U-reg points to the source                                      ;
COMMENT_LINE $F67F ;
COMMENT_LINE $F67F EXIT  A-reg = $FF                                                     ;
COMMENT_LINE $F67F B-reg = first byte of source                                    ;
COMMENT_LINE $F67F -----------------------------------------------------------------------;
COMMENT $F67F Copy the byte
COMMENT $F683 Decrement the count
COMMENT $F684 Go back until finished
COMMENT_LINE $F687 -----------------------------------------------------------------------;
COMMENT_LINE $F687 F687    Init_Music_chk                                          ;
COMMENT_LINE $F687 F68D    Init_Music                                              ;
COMMENT_LINE $F687 F692    Init_Music_dft                                          ;
COMMENT_LINE $F687 ;
COMMENT_LINE $F687 These routines are responsible for filling the music work buffer      ;
COMMENT_LINE $F687 while a sound is being made.  It should be called once during each    ;
COMMENT_LINE $F687 refresh cycle.  If you want to start a new sound, then you must =   ;
COMMENT_LINE $F687 $C856 to 0x01, and point the U-register to the sound block.  If no    ;
COMMENT_LINE $F687 sound is in progress ($C856 = 0), then it returns immediately         ;
COMMENT_LINE $F687 (unless you called Init_Music or Init_Music_dft, which do not make    ;
COMMENT_LINE $F687 this check).  When a sound is in progress, $C856 will be = to 0x80. ;
COMMENT_LINE $F687 ;
COMMENT_LINE $F687 These routines process a single note at a time, and calculate the     ;
COMMENT_LINE $F687 amplitude and course/fine tuning values for the 3 sound channels.     ;
COMMENT_LINE $F687 The values calculated are stored in the music work buffer, at         ;
COMMENT_LINE $F687 $C83F-$C84C.                                                          ;
COMMENT_LINE $F687 ;
COMMENT_LINE $F687 Music data format:                                                    ;
COMMENT_LINE $F687 ;
COMMENT_LINE $F687 header word -> $C84F  32 nibble ADSR table                      ;
COMMENT_LINE $F687 header word -> $C851  8-byte "twang" table                      ;
COMMENT_LINE $F687 data bytes                                                      ;
COMMENT_LINE $F687 ;
COMMENT_LINE $F687 The ADSR table is simply 32 nibbles (16 bytes) of amplitude values.   ;
COMMENT_LINE $F687 ;
COMMENT_LINE $F687 The twang table is 8 signed bytes to modify the base frequency of     ;
COMMENT_LINE $F687 each note being played.  Each channel has a different limit to its    ;
COMMENT_LINE $F687 twang table index (6-8) to keep them out of phase to each other.      ;
COMMENT_LINE $F687 ;
COMMENT_LINE $F687 Music data bytes:                                                     ;
COMMENT_LINE $F687 Bits 0-5 = frequency                                            ;
COMMENT_LINE $F687 Bit 6 clear = tone                                              ;
COMMENT_LINE $F687 Bit 6 = = noise                                               ;
COMMENT_LINE $F687 Bit 7 = = next music data byte is for next channel            ;
COMMENT_LINE $F687 Bit 7 clear, play note with duration in next music data byte:   ;
COMMENT_LINE $F687 bits 0-5 = duration                                     ;
COMMENT_LINE $F687 bit 6 = unused                                          ;
COMMENT_LINE $F687 bit 7 = = end of music                                ;
COMMENT_LINE $F687 ;
COMMENT_LINE $F687 ENTRY DP = $C8                                                        ;
COMMENT_LINE $F687 U-reg points to the start of the music data                     ;
COMMENT_LINE $F687 $C84D points to frequency table (Init_Music_dft only)           ;
COMMENT_LINE $F687 $C856 may need to be set.                                       ;
COMMENT_LINE $F687 ;
COMMENT_LINE $F687 D-reg, X-reg, Y-reg, U-reg trashed                              ;
COMMENT_LINE $F687 -----------------------------------------------------------------------;
COMMENT $F687 Test sound active flag
FORCE_SYMBOL $F687 Vec_Music_Flag
COMMENT $F689 Continue sound if active
COMMENT $F68B Return if sound not active
COMMENT $F68D Save pointer to frequency table
FORCE_SYMBOL $F68D Freq_Table
FORCE_SYMBOL $F690 Vec_Freq_Table
COMMENT $F692 Set sound active flag
FORCE_NO_SYMBOL $F692
FORCE_SYMBOL $F694 Vec_Music_Flag
COMMENT $F696 Save address of ADSR table
FORCE_SYMBOL $F698 Vec_ADSR_Table
COMMENT $F69A Save address of twang table
FORCE_SYMBOL $F69C Vec_Twang_Table
COMMENT $F69E Save pointer to music data
FORCE_SYMBOL $F69E Vec_Music_Ptr
COMMENT $F6A0 Initialize music buffer
FORCE_SYMBOL $F6A0 Init_Music_Buf
FORCE_NO_SYMBOL $F6A3
COMMENT $F6A6 Init ADSR timers of chans 2 & 3
FORCE_NO_SYMBOL $F6A8
COMMENT $F6AB Clear frequency of channel 2
COMMENT $F6AD Clear frequency of channel 3
COMMENT $F6AF A-reg = 0 (sound channel number?)
FORCE_SYMBOL $F6AF Vec_Music_Chan
COMMENT_LINE $F6B3 Continue currently playing sound here
COMMENT $F6B3 Get address of ADSR timers
FORCE_SYMBOL $F6B3 Vec_ADSR_Timers
COMMENT $F6B6 Count for three channels
FORCE_NO_SYMBOL $F6B6
COMMENT $F6B8 Get the channel's ADSR timer
FORCE_NO_SYMBOL $F6BA
COMMENT $F6BC Skip if at maximum
COMMENT $F6BE Else increment the timer
COMMENT $F6C0 Go back for the other channels
FORCE_SYMBOL $F6C3 Vec_Twang_Table
FORCE_SYMBOL $F6C5 Vec_Music_Twang
COMMENT $F6C8 Twang limit is 6-8 depending on channel
FORCE_NO_SYMBOL $F6C8
COMMENT $F6CA Increment twang counter
FORCE_NO_SYMBOL $F6CA
COMMENT $F6CC Check against limit
FORCE_NO_SYMBOL $F6CC
COMMENT $F6D0 Clear it if limit exceeded
FORCE_NO_SYMBOL $F6D0
COMMENT $F6D2 Get twang count
COMMENT $F6D4 Mask out low 3 bits
FORCE_NO_SYMBOL $F6D4
COMMENT $F6D6 Get twang value from table
COMMENT $F6D8 Update current twang value
COMMENT $F6DA Increment twang limit
FORCE_NO_SYMBOL $F6DB
COMMENT $F6DD Go back until all three channels done
COMMENT $F6DF Decrement the duration timer
FORCE_SYMBOL $F6DF Vec_Duration
COMMENT $F6E1 Update ADSR while note still playing
COMMENT $F6E3 Go to next music channel
FORCE_SYMBOL $F6E3 Vec_Music_Chan
COMMENT $F6E6 If < 0, set it to 2
FORCE_NO_SYMBOL $F6E8
FORCE_SYMBOL $F6EA Vec_Music_Chan
COMMENT $F6EC Get next byte of music data
FORCE_SYMBOL $F6EC Vec_Music_Ptr
COMMENT $F6F0 Clear ADSR timer for this channel
FORCE_SYMBOL $F6F0 Vec_ADSR_Timers
COMMENT $F6F5 If $40 bit of music data set,
FORCE_NO_SYMBOL $F6F5
COMMENT $F6F7 we're going to make some noise
COMMENT $F6F9 Get bit mask for this channel
FORCE_SYMBOL $F6F9 Music_Table_1
COMMENT $F6FE Turn channel bit off for register 7
FORCE_SYMBOL $F6FE Vec_Music_Wk_7
FORCE_SYMBOL $F700 Vec_Music_Wk_7
COMMENT $F702 Set current channel bit in register 7
FORCE_SYMBOL $F702 Vec_Music_Chan
FORCE_NO_SYMBOL $F704
FORCE_SYMBOL $F708 Vec_Music_Wk_7
FORCE_SYMBOL $F70A Vec_Music_Wk_7
COMMENT $F70C Mask off low 5 bits of music data
FORCE_NO_SYMBOL $F70C
COMMENT $F70E and store in register 6
FORCE_SYMBOL $F70E Vec_Music_Wk_6
COMMENT $F712 If $40 bit of music data was cleared,
FORCE_SYMBOL $F712 Music_Table_2
COMMENT $F715 Get bit mask for this channel
COMMENT $F717 Turn channel bit off for register 7
FORCE_SYMBOL $F717 Vec_Music_Wk_7
FORCE_SYMBOL $F719 Vec_Music_Wk_7
COMMENT $F71B Set current channel bit in register 7
FORCE_SYMBOL $F71B Vec_Music_Chan
FORCE_NO_SYMBOL $F71D
FORCE_SYMBOL $F721 Vec_Music_Wk_7
FORCE_SYMBOL $F723 Vec_Music_Wk_7
COMMENT $F725 Get $C855 * 2 + 3
FORCE_SYMBOL $F725 Vec_Music_Chan
COMMENT $F72A Point U-reg to #$C861 + $C855 * 2
COMMENT $F72C Mask off low 6 bits of music data,
FORCE_NO_SYMBOL $F72C
COMMENT $F72E multiply by 2
COMMENT $F72F Get pointer to note-to-frequency table
FORCE_SYMBOL $F72F Vec_Freq_Table
COMMENT $F731 Get note table data
COMMENT $F733 Store in word at $C861-$C866
FORCE_NO_SYMBOL $F733
COMMENT $F735 Re-get byte of music data
FORCE_SYMBOL $F735 Vec_Music_Ptr
COMMENT $F739 Update music data pointer
FORCE_SYMBOL $F739 Vec_Music_Ptr
COMMENT $F73C If byte>=$80, advance to next channel
COMMENT $F73E Get second byte of music data
COMMENT $F740 If >=$80, (terminator)
COMMENT $F742 clear music buffer,
FORCE_SYMBOL $F742 Init_Music_Buf
COMMENT $F745 clear music flag,
FORCE_SYMBOL $F745 Vec_Music_Flag
COMMENT $F747 and exit
COMMENT $F748 Update music data pointer
FORCE_SYMBOL $F748 Vec_Music_Ptr
COMMENT $F74A Duration in low 6 bits of second byte
FORCE_NO_SYMBOL $F74A
COMMENT $F74C Store duration counter
FORCE_SYMBOL $F74C Vec_Duration
COMMENT $F74E Get pointer to ADSR table
FORCE_SYMBOL $F74E Vec_ADSR_Table
COMMENT $F751 Point to ADSR timer table
FORCE_SYMBOL $F751 Vec_ADSR_Timers
FORCE_SYMBOL $F754 Vec_Music_Wk_A
COMMENT $F757 Count for three channels
FORCE_NO_SYMBOL $F757
COMMENT $F759 Get channel timer?
COMMENT $F75B Test low bit of ADSR index
FORCE_NO_SYMBOL $F75B
COMMENT $F75F If odd, divide ADSR index by by 2
COMMENT $F760 Get low nibble from ADSR table
FORCE_NO_SYMBOL $F762
COMMENT $F766 If even, divide ADSR index by 2
COMMENT $F767 Get high nibble from ADSR table
COMMENT $F76D Store ADSR value in regs 10-12
COMMENT $F76F Decrement channel counter
COMMENT $F770 Go back for next channel
COMMENT $F772 Point to base frequency table
COMMENT $F775 Point to twang table
FORCE_SYMBOL $F775 Vec_Music_Wk_5
COMMENT $F778 Get next base frequency
COMMENT $F77A Test twang value
COMMENT $F77E If <0, negate twang table entry
COMMENT $F780 Subtract negated value from frequency
COMMENT $F782 Propagate borrow to high byte
FORCE_NO_SYMBOL $F782
COMMENT $F784 Un-negate twang entry
COMMENT $F788 If >0 add twang to base frequency
COMMENT $F78A Propagate carry to high byte
FORCE_NO_SYMBOL $F78A
COMMENT $F78C Store freq in regs 5/4, 3/2, 1/0
COMMENT_LINE $F794 -----------------------------------------------------------------------;
COMMENT_LINE $F794 F7A9    Select_Game                                             ;
COMMENT_LINE $F794 ;
COMMENT_LINE $F794 This routine provides a game with the means for allowing the player   ;
COMMENT_LINE $F794 to choose the game number he would like to play, and the number of    ;
COMMENT_LINE $F794 players.  The game indicates the number of game versions available,   ;
COMMENT_LINE $F794 by placing the  value in the B register.  The number of players       ;
COMMENT_LINE $F794 allowed is specified in the A register.  If a parameter is passed in  ;
COMMENT_LINE $F794 with a value of 0, then the corresponding question will not be asked. ;
COMMENT_LINE $F794 The number of players selected is returned in $C879, while the game   ;
COMMENT_LINE $F794 number selected is returned in $C87A.                                 ;
COMMENT_LINE $F794 ;
COMMENT_LINE $F794 This routine performs most of the work involved in allowing the       ;
COMMENT_LINE $F794 player to select a game version and the number of players.  It        ;
COMMENT_LINE $F794 displays the game # and player options, and allows the player a       ;
COMMENT_LINE $F794 certain amount of time to modify their values.  Anytime one of the    ;
COMMENT_LINE $F794 buttons is used to modify a value, the timer will be restarted.       ;
COMMENT_LINE $F794 When a button is pressed, the associated value is modified,           ;
COMMENT_LINE $F794 and then redisplayed on the screen.  This routine will return when    ;
COMMENT_LINE $F794 either the timer expires, or button 4 is pressed.                     ;
COMMENT_LINE $F794 ;
COMMENT_LINE $F794 ENTRY A-reg = maximum number of players allowed                       ;
COMMENT_LINE $F794 B-reg = number of game versions available                       ;
COMMENT_LINE $F794 ;
COMMENT_LINE $F794 EXIT: DP = $C8                                                        ;
COMMENT_LINE $F794 $C879 contains number of players selected                       ;
COMMENT_LINE $F794 $C87A contains the game version selected                        ;
COMMENT_LINE $F794 ;
COMMENT_LINE $F794 D-reg, X-reg, Y-reg trashed                                     ;
COMMENT_LINE $F794 -----------------------------------------------------------------------;
COMMENT $F7A9 Save max players and games
FORCE_SYMBOL $F7A9 Vec_Max_Players
COMMENT $F7AC If non-zero players specified,
COMMENT $F7AF set selection to 1
FORCE_NO_SYMBOL $F7AF
COMMENT $F7B1 If non-zero games specified,
COMMENT $F7B4 set selection to 1
FORCE_NO_SYMBOL $F7B4
COMMENT $F7B6 Save default selection
FORCE_SYMBOL $F7B6 Vec_Num_Players
COMMENT $F7B9 DP to RAM
FORCE_SYMBOL $F7B9 DP_to_C8
FORCE_NO_SYMBOL $F7BC
FORCE_SYMBOL $F7BF Vec_Text_HW
COMMENT $F7C1 Set $C83C flag to non-zero
FORCE_NO_SYMBOL $F7C1
COMMENT $F7C5 Start with a fresh frame, DP to I/O
FORCE_SYMBOL $F7C5 Wait_Recal
COMMENT $F7C8 Read buttons, all in direct mode
FORCE_SYMBOL $F7C9 Read_Btns_Mask
FORCE_SYMBOL $F7CC Dec_3_Counters
COMMENT $F7CF Brightness to normal
FORCE_SYMBOL $F7CF Intensity_7F
COMMENT $F7D2 Display number of players
FORCE_SYMBOL $F7D2 Vec_Num_Players
FORCE_SYMBOL $F7D5 Player_Str
COMMENT $F7DB Display currently selected game
FORCE_SYMBOL $F7DB Vec_Num_Game
FORCE_SYMBOL $F7DE Game_Str
COMMENT $F7E4 DP to RAM
FORCE_SYMBOL $F7E4 DP_to_C8
COMMENT $F7E7 If $C83C=0, check buttons
FORCE_NO_SYMBOL $F7E7
FORCE_SYMBOL $F7EB Vec_Btn_State
COMMENT $F7ED If any button pressed, reset timers
COMMENT $F7EF Clear $C83C flag
FORCE_NO_SYMBOL $F7EF
COMMENT $F7F1 Return if counter 2 timed out
FORCE_SYMBOL $F7F1 Vec_Counter_2
COMMENT $F7F5 If repeat timer not timed out,
FORCE_SYMBOL $F7F5 Vec_Counter_1
COMMENT $F7F7 ignore the buttons
FORCE_SYMBOL $F7F9 Vec_Button_1_4
COMMENT $F7FB Return if button 4 pressed
FORCE_SYMBOL $F7FD Vec_Button_1_1
COMMENT $F801 Ignore if no players option
FORCE_SYMBOL $F801 Vec_Num_Players
COMMENT $F803 If button 1 pressed,
COMMENT $F805 increment number of players
FORCE_SYMBOL $F806 Vec_Max_Players
COMMENT $F80A Reset to 1 if max players exceeded
FORCE_NO_SYMBOL $F80A
COMMENT $F80C Update number of players
FORCE_SYMBOL $F80C Vec_Num_Players
COMMENT $F80E Update timers and go back to the loop
COMMENT $F810 Return to the loop if no game options
FORCE_SYMBOL $F810 Vec_Num_Game
FORCE_SYMBOL $F814 Vec_Button_1_2
COMMENT $F818 If button 2 down, increment game
FORCE_SYMBOL $F819 Vec_Max_Games
COMMENT $F81D Reset to 1 if maximum exceeded
FORCE_NO_SYMBOL $F81D
FORCE_SYMBOL $F821 Vec_Button_1_3
COMMENT $F825 If button 3 down, decrement game
COMMENT $F828 Reset to max if zero reached
FORCE_SYMBOL $F828 Vec_Max_Games
FORCE_SYMBOL $F82A Vec_Num_Game
COMMENT $F82C Reset timers
FORCE_NO_SYMBOL $F82C
FORCE_SYMBOL $F82E Vec_Counter_2
FORCE_SYMBOL $F831 Vec_Counter_1
COMMENT $F833 Go back to the loop
COMMENT_LINE $F835 -----------------------------------------------------------------------;
COMMENT_LINE $F835 F835    Display_Option  (not called by GCE cartridges)          ;
COMMENT_LINE $F835 ;
COMMENT_LINE $F835 This routine displays the player or game option string, along with    ;
COMMENT_LINE $F835 the current value for that option.  The A-register contains the       ;
COMMENT_LINE $F835 value of the option, while the Y-register points to a block of the    ;
COMMENT_LINE $F835 following form:                                                       ;
COMMENT_LINE $F835 ;
COMMENT_LINE $F835 rel y, rel x,      ( for value )                                ;
COMMENT_LINE $F835 rel y, rel x,      ( for option string)                         ;
COMMENT_LINE $F835 option string,                                                  ;
COMMENT_LINE $F835 0x80                                                            ;
COMMENT_LINE $F835 ;
COMMENT_LINE $F835 ENTRY DP = $D0                                                        ;
COMMENT_LINE $F835 A-reg=the option value.                                         ;
COMMENT_LINE $F835 Y-reg points to the string block.                               ;
COMMENT_LINE $F835 ;
COMMENT_LINE $F835 D-reg, U-reg, X-reg trashed                                     ;
COMMENT_LINE $F835 -----------------------------------------------------------------------;
COMMENT $F835 Point to temp storage
FORCE_NO_SYMBOL $F835
COMMENT $F838 Save option
COMMENT $F83A Clear scratch score accumulator
COMMENT $F83C Get option back
COMMENT $F83E Exit printing nothing if option = zero
COMMENT $F840 Put option in scratch score accumulator
COMMENT $F842 Transfer X to be printed
COMMENT $F844 Get (y,x) of value
COMMENT $F846 Print value
FORCE_SYMBOL $F846 Print_Str_d
COMMENT $F849 Transfer Y to be printed
COMMENT $F84B Print option string
FORCE_SYMBOL $F84B Print_Str_yx
COMMENT_LINE $F84F -----------------------------------------------------------------------;
COMMENT_LINE $F84F F84F    Clear_Score                                             ;
COMMENT_LINE $F84F ;
COMMENT_LINE $F84F This routine will initialize the passed-in score string (pointed to   ;
COMMENT_LINE $F84F by the X-register) to the following value:                            ;
COMMENT_LINE $F84F ;
COMMENT_LINE $F84F "     0",0x80                                                   ;
COMMENT_LINE $F84F ;
COMMENT_LINE $F84F ENTRY X-reg points to seven byte score accumulator                    ;
COMMENT_LINE $F84F ;
COMMENT_LINE $F84F D-reg trashed                                                   ;
COMMENT_LINE $F84F -----------------------------------------------------------------------;
COMMENT $F84F Store the leading blanks
FORCE_NO_SYMBOL $F852
FORCE_NO_SYMBOL $F854
FORCE_NO_SYMBOL $F856
COMMENT $F858 Store the zero and terminator byte
FORCE_NO_SYMBOL $F85B
COMMENT_LINE $F85E -----------------------------------------------------------------------;
COMMENT_LINE $F85E F85E    Add_Score_a                                             ;
COMMENT_LINE $F85E F87C    Add_Score_d                                             ;
COMMENT_LINE $F85E ;
COMMENT_LINE $F85E These routines take the BCD value in the D-register or the binary     ;
COMMENT_LINE $F85E value in the A-register, and add it to the 6-byte ASCII number        ;
COMMENT_LINE $F85E pointed by the X-register.                                            ;
COMMENT_LINE $F85E ;
COMMENT_LINE $F85E ENTRY A-reg = binary value (Add_Score_a only)                         ;
COMMENT_LINE $F85E D-reg = BCD value (Add_Score_d only)                            ;
COMMENT_LINE $F85E U-reg = BCD conversion of A-reg (Add_Score_a only)              ;
COMMENT_LINE $F85E X-reg points to six byte ASCII score accumulator                ;
COMMENT_LINE $F85E ;
COMMENT_LINE $F85E D-reg trashed                                                   ;
COMMENT_LINE $F85E -----------------------------------------------------------------------;
COMMENT $F85E Initialize BCD result to zero
FORCE_NO_SYMBOL $F85E
COMMENT $F861 Add in the hundreds
FORCE_NO_SYMBOL $F861
FORCE_NO_SYMBOL $F865
FORCE_NO_SYMBOL $F867
COMMENT $F86D Add in the tens
FORCE_NO_SYMBOL $F86D
FORCE_NO_SYMBOL $F871
FORCE_NO_SYMBOL $F873
COMMENT $F878 Add in the ones
COMMENT $F87A Move it to the D-register
COMMENT $F87C Save BCD on stack in reverse order
FORCE_NO_SYMBOL $F880
COMMENT $F882 Add zero to 10000 and 100000 digits
FORCE_NO_SYMBOL $F883
COMMENT $F887 Add right nibble to hundreds and ones
FORCE_NO_SYMBOL $F887
FORCE_NO_SYMBOL $F88B
COMMENT $F88F Add left nibble to thousands and tens
COMMENT $F895 Isolate desired nibble
FORCE_NO_SYMBOL $F895
COMMENT $F897 Add in carry ($C823 is normally zero)
FORCE_NO_SYMBOL $F897
COMMENT $F89A Clear carry
FORCE_NO_SYMBOL $F89A
COMMENT $F89D Add to digit
COMMENT $F89F If digit was a blank,
COMMENT $F8A3 promote the result to a digit
FORCE_NO_SYMBOL $F8A3
COMMENT $F8A5 If a carry has occurred,
COMMENT $F8A9 subtract ten
FORCE_NO_SYMBOL $F8A9
COMMENT $F8AB and set carry flag
FORCE_NO_SYMBOL $F8AB
COMMENT $F8AE Store resulting digit
COMMENT $F8B0 Go back for more digits
COMMENT $F8B3 Clear $C823 back to zero
FORCE_NO_SYMBOL $F8B3
COMMENT_LINE $F8B7 -----------------------------------------------------------------------;
COMMENT_LINE $F8B7 F8B7    Strip_Zeros                                             ;
COMMENT_LINE $F8B7 ;
COMMENT_LINE $F8B7 This routine strips the leading zeros from a score accumulator.       ;
COMMENT_LINE $F8B7 ;
COMMENT_LINE $F8B7 ENTRY B-reg = first digit to start with (usually zero)                ;
COMMENT_LINE $F8B7 X-reg points to six byte ASCII score accumulator                ;
COMMENT_LINE $F8B7 ;
COMMENT_LINE $F8B7 D-reg trashed                                                   ;
COMMENT_LINE $F8B7 -----------------------------------------------------------------------;
COMMENT $F8B7 Test current digit
COMMENT $F8BB Exit if not zero
COMMENT $F8BD Change it to a blank
FORCE_NO_SYMBOL $F8C2
COMMENT_LINE $F8C7 -----------------------------------------------------------------------;
COMMENT_LINE $F8C7 F8C7    Compare_Score                                           ;
COMMENT_LINE $F8C7 ;
COMMENT_LINE $F8C7 This routine will compare two BCD score strings, to determine which   ;
COMMENT_LINE $F8C7 one is higher.  The two strings are pointed to by the U and X         ;
COMMENT_LINE $F8C7 registers.  Depending upon how the scores compare, one of the         ;
COMMENT_LINE $F8C7 following values will be returned in the A-register:                  ;
COMMENT_LINE $F8C7 ;
COMMENT_LINE $F8C7 1) The scores are the same: a = 0                               ;
COMMENT_LINE $F8C7 2) X score > U score:   a = 1                                   ;
COMMENT_LINE $F8C7 3) U score > X score:   a = 2                                   ;
COMMENT_LINE $F8C7 ;
COMMENT_LINE $F8C7 ENTRY X-reg points to first score string (terminated with $80)        ;
COMMENT_LINE $F8C7 U-reg points to second score string                             ;
COMMENT_LINE $F8C7 ;
COMMENT_LINE $F8C7 EXIT: A-reg returns result of the compare                             ;
COMMENT_LINE $F8C7 ;
COMMENT_LINE $F8C7 B-reg trashed                                                   ;
COMMENT_LINE $F8C7 -----------------------------------------------------------------------;
COMMENT $F8C7 Save score pointers
COMMENT $F8C9 Default to scores are the same
COMMENT $F8CC Return if end of string
COMMENT $F8D0 Continue if byte is the same
COMMENT $F8D2 Return 1 if X > U
COMMENT $F8D4 Return 2 if U > X
COMMENT $F8D6 Restore pointers and return
COMMENT_LINE $F8D8 -----------------------------------------------------------------------;
COMMENT_LINE $F8D8 F8D8    New_High_Score                                          ;
COMMENT_LINE $F8D8 ;
COMMENT_LINE $F8D8 This routine compares a players score string, pointed to by the       ;
COMMENT_LINE $F8D8 X register, to the current hi score, pointed by the U register.  If   ;
COMMENT_LINE $F8D8 the player's score is higher than the currently saved hi score, then  ;
COMMENT_LINE $F8D8 the player's score will be copied into the hi score buffer pointed    ;
COMMENT_LINE $F8D8 to by the U register.                                                 ;
COMMENT_LINE $F8D8 ;
COMMENT_LINE $F8D8 ENTRY X-reg points to a player's score string                         ;
COMMENT_LINE $F8D8 U-reg points to the high score string (usually $CBEB?)          ;
COMMENT_LINE $F8D8 ;
COMMENT_LINE $F8D8 X-reg, U-reg, D-reg trashed                                     ;
COMMENT_LINE $F8D8 -----------------------------------------------------------------------;
COMMENT $F8D8 Compare the scores
FORCE_NO_SYMBOL $F8DA
COMMENT $F8DC Return if X is not > U
COMMENT $F8DE Copy the new high score
COMMENT $F8E2 until end of string encountered
COMMENT_LINE $F8E5 -----------------------------------------------------------------------;
COMMENT_LINE $F8E5 F8E5    Obj_Will_Hit_u                                          ;
COMMENT_LINE $F8E5 F8F3    Obj_Will_Hit                                            ;
COMMENT_LINE $F8E5 ;
COMMENT_LINE $F8E5 This routine first modifies the position of the object, and then it   ;
COMMENT_LINE $F8E5 checks to see if the missile has hit the object.  The Y register      ;
COMMENT_LINE $F8E5 contains the (y,x) position of the object, the U register contains    ;
COMMENT_LINE $F8E5 a pointer to the (y,x) modification values, the X register contains   ;
COMMENT_LINE $F8E5 the missile (y,x) position, and the D register contains the           ;
COMMENT_LINE $F8E5 (height/2, width/2) of the object.                                    ;
COMMENT_LINE $F8E5 ;
COMMENT_LINE $F8E5 (0,u) is temporarily added to the y position of the object, and       ;
COMMENT_LINE $F8E5 (1,u) is temporarily added to the x position.                         ;
COMMENT_LINE $F8E5 ;
COMMENT_LINE $F8E5 ENTRY Y-reg = (y,x) position of the object                            ;
COMMENT_LINE $F8E5 X-reg = (y,x) position of the missile                           ;
COMMENT_LINE $F8E5 U-reg points to movement (y,x) (Mov_Obj_Hit_u only)             ;
COMMENT_LINE $F8E5 U-reg = movement (y,x) (Mov_Obj_Hit only)                       ;
COMMENT_LINE $F8E5 D-reg = (h/2,w/2) size of object                                ;
COMMENT_LINE $F8E5 ;
COMMENT_LINE $F8E5 EXIT: Carry bit = if the object & missile have collided             ;
COMMENT_LINE $F8E5 ;
COMMENT_LINE $F8E5 ALL registers saved.  Even the original Y-register.             ;
COMMENT_LINE $F8E5 -----------------------------------------------------------------------;
COMMENT $F8E5 Save regs for the hit-test code
COMMENT $F8E9 Get object position
FORCE_NO_SYMBOL $F8E9
COMMENT $F8EB Add it to the modification values
FORCE_NO_SYMBOL $F8EB
FORCE_NO_SYMBOL $F8ED
COMMENT $F8EF Put updated object position back
FORCE_NO_SYMBOL $F8EF
COMMENT $F8F1 Go do the hit-test
COMMENT $F8F3 Save regs for the hit-test code
COMMENT $F8F7 Get modification values
COMMENT $F8F9 Add them to the object position
FORCE_NO_SYMBOL $F8F9
FORCE_NO_SYMBOL $F8FB
COMMENT $F8FD Put update position back and hit-test
COMMENT_LINE $F8FF -----------------------------------------------------------------------;
COMMENT_LINE $F8FF F8FF    Obj_Hit                                                 ;
COMMENT_LINE $F8FF ;
COMMENT_LINE $F8FF Thit routine checks to see if a missile hashit an object.  If the     ;
COMMENT_LINE $F8FF missile has hit the object, then the carry bit will be set;           ;
COMMENT_LINE $F8FF otherwise, the carry bit will be cleared.  A hit is checked for in    ;
COMMENT_LINE $F8FF the following fashion:                                                ;
COMMENT_LINE $F8FF ;
COMMENT_LINE $F8FF if (object y-height/2) <= missile y <= (object y+height/2)          ;
COMMENT_LINE $F8FF and                                     ;
COMMENT_LINE $F8FF (object x-width/2)  <= missile x <= (object x+width/x)           ;
COMMENT_LINE $F8FF ;
COMMENT_LINE $F8FF then the missile hit, otherwise it missed.                          ;
COMMENT_LINE $F8FF ;
COMMENT_LINE $F8FF ENTRY Y-reg = (y,x) position of the object                            ;
COMMENT_LINE $F8FF X-reg = (y,x) position of the missile                           ;
COMMENT_LINE $F8FF D-reg = (h/2,w/2) size of object                                ;
COMMENT_LINE $F8FF ;
COMMENT_LINE $F8FF EXIT: Carry bit = if the object & missile have collided             ;
COMMENT_LINE $F8FF ;
COMMENT_LINE $F8FF All registers preserved.                                        ;
COMMENT_LINE $F8FF -----------------------------------------------------------------------;
COMMENT $F8FF Save some regs
COMMENT $F903 Point X to the stack
COMMENT $F905 Offset to point to y
COMMENT $F907 Get height/2
FORCE_NO_SYMBOL $F907
COMMENT $F909 Add object y
FORCE_NO_SYMBOL $F909
COMMENT $F90D Set to $7F if overflow
FORCE_NO_SYMBOL $F90D
COMMENT $F90F Branch if missile out of range
FORCE_NO_SYMBOL $F90F
COMMENT $F913 Get height/2
FORCE_NO_SYMBOL $F913
COMMENT $F915 Subtract object y
FORCE_NO_SYMBOL $F915
COMMENT $F919 Set to $80 if overflow
FORCE_NO_SYMBOL $F919
COMMENT $F91B Branch if missile out of range
FORCE_NO_SYMBOL $F91B
COMMENT $F91F Offset to point to x
FORCE_NO_SYMBOL $F920
COMMENT $F922 Go back for x
COMMENT $F924 Object in range, set carry
FORCE_NO_SYMBOL $F924
COMMENT $F928 Object not in range, clear carry
FORCE_NO_SYMBOL $F928
COMMENT_LINE $F92E -----------------------------------------------------------------------;
COMMENT_LINE $F92E F92E    Explosion_Snd                                           ;
COMMENT_LINE $F92E ;
COMMENT_LINE $F92E This routine appears to generate some type of an explosion sound,     ;
COMMENT_LINE $F92E dependent upon the 4 bytes which are pointed to by the U register.    ;
COMMENT_LINE $F92E You will probably need to call Do_Sound for this to do anything.      ;
COMMENT_LINE $F92E ;
COMMENT_LINE $F92E The format of the 4-byte block is:                                    ;
COMMENT_LINE $F92E 1)      Bits 0-2 = ?    Stored in $C85D                         ;
COMMENT_LINE $F92E Bits 3-5 = ?    Stored in $C853                         ;
COMMENT_LINE $F92E Bits 6-7 = 0                                            ;
COMMENT_LINE $F92E Bits 0-2 and 3-5 are ORed and stored in bits 0-2 of     ;
COMMENT_LINE $F92E $C854   ;
COMMENT_LINE $F92E 2)      <0 = ?          Something to do with register 6         ;
COMMENT_LINE $F92E =0 = ?                                                  ;
COMMENT_LINE $F92E >0 = ?                                                  ;
COMMENT_LINE $F92E 3)      <0 = ?                                                  ;
COMMENT_LINE $F92E =0 = ?                                                  ;
COMMENT_LINE $F92E >0 = ?                                                  ;
COMMENT_LINE $F92E 4)      Speed?  Higher values = lower duration?                 ;
COMMENT_LINE $F92E ;
COMMENT_LINE $F92E ENTRY DP = $C8                                                        ;
COMMENT_LINE $F92E U-reg points to 4-byte block of data if $C867 high bit =      ;
COMMENT_LINE $F92E ;
COMMENT_LINE $F92E D-reg, X-reg trashed                                            ;
COMMENT_LINE $F92E -----------------------------------------------------------------------;
FORCE_SYMBOL $F92E Vec_Expl_Flag
FORCE_NO_SYMBOL $F932
FORCE_SYMBOL $F934 Vec_Expl_Flag
COMMENT $F936 Copy 4 bytes from U-reg to $C858
FORCE_SYMBOL $F936 Vec_Expl_1
FORCE_NO_SYMBOL $F939
FORCE_SYMBOL $F93B Move_Mem_a
COMMENT $F93E Divide first byte by 8
COMMENT $F941 OR with first byte
FORCE_SYMBOL $F941 Vec_Expl_1
COMMENT $F943 AND with 7
FORCE_NO_SYMBOL $F943
COMMENT $F945 store in $C854
FORCE_SYMBOL $F945 Vec_Expl_Chans
COMMENT $F947 Get first byte
FORCE_SYMBOL $F947 Vec_Expl_1
COMMENT $F949 Mask off bits 3-5
FORCE_NO_SYMBOL $F949
COMMENT $F94B store in $C853
FORCE_SYMBOL $F94B Vec_Expl_ChanA
COMMENT $F94D Get first byte
FORCE_SYMBOL $F94D Vec_Expl_1
COMMENT $F94F AND with 7
FORCE_NO_SYMBOL $F94F
COMMENT $F951 store in $C85D
FORCE_SYMBOL $F951 Vec_Expl_ChanB
COMMENT $F953 Start with channel number 2
FORCE_NO_SYMBOL $F953
FORCE_SYMBOL $F955 Vec_Expl_Chan
COMMENT $F957 Initialize time count
FORCE_NO_SYMBOL $F957
FORCE_SYMBOL $F95B Vec_Expl_Timer
FORCE_SYMBOL $F95F Vec_Expl_4
FORCE_SYMBOL $F964 Vec_Expl_Timer
FORCE_SYMBOL $F968 Vec_Expl_Timer
FORCE_SYMBOL $F96C Vec_Expl_ChanA
FORCE_SYMBOL $F970 Vec_Music_Wk_6
FORCE_SYMBOL $F972 Vec_Expl_2
FORCE_SYMBOL $F97B Vec_Music_Wk_6
FORCE_NO_SYMBOL $F97E
FORCE_NO_SYMBOL $F982
FORCE_SYMBOL $F987 Vec_Expl_3
FORCE_NO_SYMBOL $F98D
FORCE_SYMBOL $F993 Vec_Expl_ChanB
COMMENT $F997 Get channel number
FORCE_SYMBOL $F997 Vec_Expl_Chan
COMMENT $F999 Decrement channel number
COMMENT $F99C Reset to 2 if less than zero
FORCE_NO_SYMBOL $F99C
COMMENT $F99E Save channel number
FORCE_SYMBOL $F99E Vec_Expl_Chan
COMMENT $F9A0 Get bit mask of the channel
FORCE_SYMBOL $F9A0 Bitmask_a
FORCE_SYMBOL $F9A3 Vec_Expl_ChanB
COMMENT $F9A5 Go back if not in for $C85D
FORCE_SYMBOL $F9A7 Vec_Expl_Chan
COMMENT $F9A9 Negative of channel number ; 2
COMMENT $F9AB (registers 1, 3, and 5)
FORCE_SYMBOL $F9AB Vec_Music_Wk_1
FORCE_SYMBOL $F9B0 Random
FORCE_NO_SYMBOL $F9B3
FORCE_NO_SYMBOL $F9B5
FORCE_NO_SYMBOL $F9BA
FORCE_NO_SYMBOL $F9BC
FORCE_NO_SYMBOL $F9C0
FORCE_SYMBOL $F9C2 Vec_Expl_1
FORCE_SYMBOL $F9C5 Vec_Music_Wk_7
FORCE_SYMBOL $F9C7 Vec_Music_Wk_7
FORCE_SYMBOL $F9CA Vec_Expl_Chans
FORCE_SYMBOL $F9CC Vec_Music_Wk_7
COMMENT $F9CF Exit if all channels done
COMMENT $F9D2 Point to next register (8-10)
COMMENT $F9D7 Store noise value if chan in use
FORCE_NO_SYMBOL $F9D7
COMMENT $F9DC For Bitmask_a
COMMENT $F9E4 For noise
COMMENT $F9EA For music
COMMENT $F9F0 For Recalibrate
COMMENT_LINE $FC24 These tables are used by the rise/run calculations
COMMENT_LINE $FC8D Music note to frequency table
COMMENT_LINE $FD0D FD0D = power-on music and music for Crazy Coaster and Narrow Escape
COMMENT_LINE $FD1D FD1D = music for Berzerk?
COMMENT_LINE $FD69 FD69 = ADSR table for Berzerk and FF7A
COMMENT_LINE $FD79 FD79 = twang table for Berzerk and Scramble
COMMENT_LINE $FD81 FD81 = music
COMMENT_LINE $FDC3 FDC3 = ADSR table for FD81 and FF8F
COMMENT_LINE $FDD3 FDD3 = music for Scramble
COMMENT_LINE $FE28 FE28 = ADSR table for Scramble, FF26, FF44, FF62
COMMENT_LINE $FE38 FE38 = music for Solar Quest
COMMENT_LINE $FE66 FE66 = ADSR table for Solar Quest
COMMENT_LINE $FE76 FE76 = music
COMMENT_LINE $FEB2 FEB2 = ADSR table for FE76
COMMENT_LINE $FEB6 FEB6 = "flat" twang table
COMMENT_LINE $FEC6 FEC6 = music
COMMENT_LINE $FEE8 FEE8 = ADSR table for FEC6
COMMENT_LINE $FEF8 FEF8 = music for Melody Master
COMMENT_LINE $FF16 FF16 = ADSR table for FEF8
COMMENT_LINE $FF26 FF26 = music
COMMENT_LINE $FF44 FF44 = music
COMMENT_LINE $FF62 FF62 = music
COMMENT_LINE $FF7A FF7A = music
COMMENT_LINE $FF8F FF8F = music
COMMENT_LINE $FF9F -----------------------------------------------------------------------;
COMMENT_LINE $FF9F FF9F    Draw_Grid_VL                                            ;
COMMENT_LINE $FF9F ;
COMMENT_LINE $FF9F This routine apparently will draw a vector list using a 16x16 grid,   ;
COMMENT_LINE $FF9F and occasionally using regular vector lists too.  This could possibly ;
COMMENT_LINE $FF9F be useful for drawing gridded things like a chess board and all of    ;
COMMENT_LINE $FF9F its pieces at the same time.                                          ;
COMMENT_LINE $FF9F ;
COMMENT_LINE $FF9F The master vector list contains multiple sublists that start with     ;
COMMENT_LINE $FF9F a flag byte:                                                          ;
COMMENT_LINE $FF9F Bit 7 = draw the next regular vector list (from X-reg) first    ;
COMMENT_LINE $FF9F Bit 6 = this is the last sublist in the master vector list      ;
COMMENT_LINE $FF9F Bits 5,4 = unused                                               ;
COMMENT_LINE $FF9F Bits 3-0 = number of points in this sublist (1-16)              ;
COMMENT_LINE $FF9F ;
COMMENT_LINE $FF9F The points are stored as a pair of nibbles:                           ;
COMMENT_LINE $FF9F Bits 7-4 = Y coordinate (?)                                     ;
COMMENT_LINE $FF9F Bits 3-0 = X coordinate (?)                                     ;
COMMENT_LINE $FF9F ;
COMMENT_LINE $FF9F ENTRY DP = $D0                                                        ;
COMMENT_LINE $FF9F X-reg points to regular vector lists                            ;
COMMENT_LINE $FF9F Y-reg points to master vector list                              ;
COMMENT_LINE $FF9F ;
COMMENT_LINE $FF9F EXIT: X-reg points to next byte after last regular vector list used   ;
COMMENT_LINE $FF9F Y-reg points to next byte after end of master vector list       ;
COMMENT_LINE $FF9F ;
COMMENT_LINE $FF9F D-reg trashed                                                   ;
COMMENT_LINE $FF9F -----------------------------------------------------------------------;
COMMENT $FF9F Get flag byte
COMMENT $FFA1 Jump into loop
COMMENT $FFA3 Draw a regular vector list
FORCE_SYMBOL $FFA3 Mov_Draw_VL_d
COMMENT $FFA6 Clear vector list flag
FORCE_NO_SYMBOL $FFA6
FORCE_NO_SYMBOL $FFA9
COMMENT $FFAB Save flag byte for vector count
FORCE_NO_SYMBOL $FFAB
COMMENT $FFAE Decrement vector count
FORCE_NO_SYMBOL $FFAE
COMMENT $FFB1 Get Y of next point
FORCE_NO_SYMBOL $FFB1
FORCE_NO_SYMBOL $FFB4
COMMENT $FFB6 Get X of next point
FORCE_NO_SYMBOL $FFBD
COMMENT $FFBF Draw a regular vector list?
FORCE_NO_SYMBOL $FFBF
COMMENT $FFC2 Go back if so
COMMENT $FFC4 Draw a line to the new point
FORCE_SYMBOL $FFC4 Draw_Line_d
COMMENT $FFC7 Check vector counter
FORCE_NO_SYMBOL $FFC7
FORCE_NO_SYMBOL $FFCA
COMMENT $FFCC Go back if more vectors to draw
COMMENT $FFCE Check for end of list
FORCE_NO_SYMBOL $FFCE
COMMENT $FFD0 Go back if more lists to draw
COMMENT $FFEE Unused
COMMENT $FFF2 SWI3 vector
COMMENT $FFF4 SWI2 vector
COMMENT $FFF6 FIRQ vector
COMMENT $FFF8 IRQ vector
COMMENT $FFFA SWI vector
COMMENT $FFFC NMI vector
COMMENT $FFFE Reset vector
RANGE $F000-$F0E9 CODE
RANGE $F0E9-$F0EB DB_DATA 2
RANGE $F0EB-$F0ED DB_DATA 2
RANGE $F0ED-$F0EF DB_DATA 2
RANGE $F0EF-$F0F1 DB_DATA 2
RANGE $F0F1-$F0F3 DB_DATA 2
RANGE $F0F3-$F0F5 DB_DATA 2
RANGE $F0F5-$F0F7 DB_DATA 2
RANGE $F0F7-$F0F9 DB_DATA 2
RANGE $F0F9-$F0FB DB_DATA 2
RANGE $F0FB-$F0FD DB_DATA 2
RANGE $F0FD-$F0FE DB_DATA 1
RANGE $F0FE-$F0FF DB_DATA 1
RANGE $F0FF-$F100 DB_DATA 1
RANGE $F100-$F101 DB_DATA 1
RANGE $F101-$F10B CHAR_DATA 10
RANGE $F10B-$F10C DB_DATA 1
RANGE $F10C-$F10E DB_DATA 2
RANGE $F10E-$F110 DB_DATA 2
RANGE $F110-$F117 CHAR_DATA 7
RANGE $F117-$F118 DB_DATA 1
RANGE $F118-$F11A DB_DATA 2
RANGE $F11A-$F11C DB_DATA 2
RANGE $F11C-$F123 CHAR_DATA 7
RANGE $F123-$F124 DB_DATA 1
RANGE $F124-$F126 DB_DATA 2
RANGE $F126-$F128 DB_DATA 2
RANGE $F128-$F12B CHAR_DATA 3
RANGE $F12B-$F12C DB_DATA 1
RANGE $F12C-$F12E DB_DATA 2
RANGE $F12E-$F130 DB_DATA 2
RANGE $F130-$F13C CHAR_DATA 12
RANGE $F13C-$F13D DB_DATA 1
RANGE $F13D-$F13F DB_DATA 2
RANGE $F13F-$F141 DB_DATA 2
RANGE $F141-$F14A CHAR_DATA 9
RANGE $F14A-$F14B DB_DATA 1
RANGE $F14B-$F14C DB_DATA 1
RANGE $F14C-$F794 CODE
RANGE $F794-$F796 DW_DATA 1
RANGE $F796-$F798 DW_DATA 1
RANGE $F798-$F79E CHAR_DATA 6
RANGE $F79E-$F79F DB_DATA 1
RANGE $F79F-$F7A1 DW_DATA 1
RANGE $F7A1-$F7A3 DW_DATA 1
RANGE $F7A3-$F7A8 CHAR_DATA 5
RANGE $F7A8-$F7A9 DB_DATA 1
RANGE $F7A9-$F9DC CODE
RANGE $F9DC-$F9E4 DB_DATA 8
RANGE $F9E4-$F9EA DB_DATA 6
RANGE $F9EA-$F9F0 DB_DATA 6
RANGE $F9F0-$F9F4 DW_DATA 2
RANGE $F9F4-$FA04 DW_DATA 8
RANGE $FA04-$FA14 DW_DATA 8
RANGE $FA14-$FA24 DW_DATA 8
RANGE $FA24-$FA34 DW_DATA 8
RANGE $FA34-$FA44 DW_DATA 8
RANGE $FA44-$FA54 DW_DATA 8
RANGE $FA54-$FA64 DW_DATA 8
RANGE $FA64-$FA74 DW_DATA 8
RANGE $FA74-$FA84 DW_DATA 8
RANGE $FA84-$FA94 DW_DATA 8
RANGE $FA94-$FAA4 DW_DATA 8
RANGE $FAA4-$FAB4 DW_DATA 8
RANGE $FAB4-$FAC4 DW_DATA 8
RANGE $FAC4-$FAD4 DW_DATA 8
RANGE $FAD4-$FAE4 DW_DATA 8
RANGE $FAE4-$FAF4 DW_DATA 8
RANGE $FAF4-$FB04 DW_DATA 8
RANGE $FB04-$FB14 DW_DATA 8
RANGE $FB14-$FB24 DW_DATA 8
RANGE $FB24-$FB34 DW_DATA 8
RANGE $FB34-$FB44 DW_DATA 8
RANGE $FB44-$FB54 DW_DATA 8
RANGE $FB54-$FB64 DW_DATA 8
RANGE $FB64-$FB74 DW_DATA 8
RANGE $FB74-$FB84 DW_DATA 8
RANGE $FB84-$FB94 DW_DATA 8
RANGE $FB94-$FBA4 DW_DATA 8
RANGE $FBA4-$FBB4 DW_DATA 8
RANGE $FBB4-$FBC4 DW_DATA 8
RANGE $FBC4-$FBD4 DW_DATA 8
RANGE $FBD4-$FBE4 DW_DATA 8
RANGE $FBE4-$FBF4 DW_DATA 8
RANGE $FBF4-$FC04 DW_DATA 8
RANGE $FC04-$FC14 DW_DATA 8
RANGE $FC14-$FC24 DW_DATA 8
RANGE $FC24-$FC2C DW_DATA 4
RANGE $FC2C-$FC3C DW_DATA 8
RANGE $FC3C-$FC4C DW_DATA 8
RANGE $FC4C-$FC5C DW_DATA 8
RANGE $FC5C-$FC6C DW_DATA 8
RANGE $FC6C-$FC6D DB_DATA 1
RANGE $FC6D-$FC7D DW_DATA 8
RANGE $FC7D-$FC8D DW_DATA 8
RANGE $FC8D-$FC9D DW_DATA 8
RANGE $FC9D-$FCAD DW_DATA 8
RANGE $FCAD-$FCBD DW_DATA 8
RANGE $FCBD-$FCCD DW_DATA 8
RANGE $FCCD-$FCDD DW_DATA 8
RANGE $FCDD-$FCED DW_DATA 8
RANGE $FCED-$FCFD DW_DATA 8
RANGE $FCFD-$FD0D DW_DATA 8
RANGE $FD0D-$FD1D DW_DATA 8
RANGE $FD1D-$FD2D DW_DATA 8
RANGE $FD2D-$FD3D DW_DATA 8
RANGE $FD3D-$FD4D DW_DATA 8
RANGE $FD4D-$FD5D DW_DATA 8
RANGE $FD5D-$FD69 DW_DATA 6
RANGE $FD69-$FD79 DW_DATA 8
RANGE $FD79-$FD81 DW_DATA 4
RANGE $FD81-$FD91 DW_DATA 8
RANGE $FD91-$FDA1 DW_DATA 8
RANGE $FDA1-$FDB1 DW_DATA 8
RANGE $FDB1-$FDC1 DW_DATA 8
RANGE $FDC1-$FDC3 DW_DATA 1
RANGE $FDC3-$FDD3 DW_DATA 8
RANGE $FDD3-$FDE3 DW_DATA 8
RANGE $FDE3-$FDF3 DW_DATA 8
RANGE $FDF3-$FE03 DW_DATA 8
RANGE $FE03-$FE13 DW_DATA 8
RANGE $FE13-$FE23 DW_DATA 8
RANGE $FE23-$FE28 DB_DATA 5
RANGE $FE28-$FE38 DW_DATA 8
RANGE $FE38-$FE48 DW_DATA 8
RANGE $FE48-$FE58 DW_DATA 8
RANGE $FE58-$FE66 DW_DATA 7
RANGE $FE66-$FE76 DW_DATA 8
RANGE $FE76-$FE86 DW_DATA 8
RANGE $FE86-$FE96 DW_DATA 8
RANGE $FE96-$FEA6 DW_DATA 8
RANGE $FEA6-$FEB2 DW_DATA 6
RANGE $FEB2-$FEB6 DW_DATA 2
RANGE $FEB6-$FEC6 DW_DATA 8
RANGE $FEC6-$FED6 DW_DATA 8
RANGE $FED6-$FEE6 DW_DATA 8
RANGE $FEE6-$FEE8 DW_DATA 1
RANGE $FEE8-$FEF8 DW_DATA 8
RANGE $FEF8-$FF08 DW_DATA 8
RANGE $FF08-$FF16 DW_DATA 7
RANGE $FF16-$FF26 DW_DATA 8
RANGE $FF26-$FF36 DW_DATA 8
RANGE $FF36-$FF44 DW_DATA 7
RANGE $FF44-$FF54 DW_DATA 8
RANGE $FF54-$FF62 DW_DATA 7
RANGE $FF62-$FF72 DW_DATA 8
RANGE $FF72-$FF7A DW_DATA 4
RANGE $FF7A-$FF8A DW_DATA 8
RANGE $FF8A-$FF8F DB_DATA 5
RANGE $FF8F-$FF9F DW_DATA 8
RANGE $FF9F-$FFD3 CODE
RANGE $FFD3-$FFEE CHAR_DATA 27
RANGE $FFEE-$FFF2 DW_DATA 2
RANGE $FFF2-$FFF4 DW_DATA 1
RANGE $FFF4-$FFF6 DW_DATA 1
RANGE $FFF6-$FFF8 DW_DATA 1
RANGE $FFF8-$FFFA DW_DATA 1
RANGE $FFFA-$FFFC DW_DATA 1
RANGE $FFFC-$FFFE DW_DATA 1
RANGE $FFFE-$0000 DW_DATA 1

