BANK 0
EQU $00 
LABEL $F000 start_of_OS_ROM
LABEL $F101 gce_copyright_string
LABEL $F10C vectrex_string
LABEL $F14C init_PIA_chip
LABEL $F164 initialize_OS_RAM
LABEL $F18B reinit
LABEL $F192 waitrecal
LABEL $F1A2 set_refresh
LABEL $F1AA dptoD0
LABEL $F1AF dptoC8
LABEL $F1B4 read_switches
LABEL $F1BA read_switches2
LABEL $F1F8 read_jstick
LABEL $F256 byte_2_sound_chip
LABEL $F259 byte_2_sound_chip2
LABEL $F272 clear_sound_chip
LABEL $F27D copy_bytes_2_sound_chip
LABEL $F289 do_sound
LABEL $F29D intensity_to_1F
LABEL $F2A1 intensity_to_3F
LABEL $F2A5 intensity_to_5F
LABEL $F2A9 intensity_to_7F
LABEL $F2AB intensity_to_a
LABEL $F2BE dotixb
LABEL $F2C1 dotix
LABEL $F2C3 dot_at_d
LABEL $F2C5 dot_at_current_position
LABEL $F2D5 dot_list
LABEL $F2DE dotix_then_reset
LABEL $F2F2 move_pen7F_no_inc
LABEL $F2FC move_pen7F_to_d
LABEL $F308 move_penFF
LABEL $F30C move_pen7F
LABEL $F30E set_scale_factor
LABEL $F310 move_pen
LABEL $F312 move_pen_d
LABEL $F34A set_dp_and_reset0ref
LABEL $F34F check0ref
LABEL $F354 reset0ref
LABEL $F373 print_1_string
LABEL $F378 print_with_dft_hw
LABEL $F37A print_at_d
LABEL $F385 printu
LABEL $F38A printu2
LABEL $F38C printu3
LABEL $F391 print_b_minus_a
LABEL $F393 print_b_minus_a2
LABEL $F3AD move_then_draw_VL_with_count1
LABEL $F3B1 move_then_draw_VL_with_count2
LABEL $F3B5 move_then_draw_VL_with_count3
LABEL $F3B7 move_then_draw_VL_with_count4
LABEL $F3B9 move_then_draw_VL_with_count6
LABEL $F3BC move_then_draw_VL_with_count5
LABEL $F3CE draw_VL_with_count4
LABEL $F3D2 draw_VL_with_count3
LABEL $F3D6 draw_VL_with_count2
LABEL $F3D8 draw_VL_with_count6
LABEL $F3DA draw_VL_with_count5
LABEL $F3DD draw_VL_with_count1
LABEL $F3DF draw_to_d
LABEL $F404 drawl1_scale_FF
LABEL $F408 drawl1_scale_7F
LABEL $F40C drawl1
LABEL $F40E drawl1b
LABEL $F410 next_pt
LABEL $F434 dwp_with_count
LABEL $F437 draw_with_pattern
LABEL $F46E drawl2
LABEL $F495 display_string
LABEL $F511 get_random_a2
LABEL $F517 get_random_a
LABEL $F533 init_music_buf
LABEL $F53F clear_blockxb
LABEL $F542 clear_C8_ram
LABEL $F545 clear_256_bytes
LABEL $F548 clear_block
LABEL $F550 clear_block_to_0x80
LABEL $F552 clear_block_to_a
LABEL $F55A decrement_counters_C82E_C830
LABEL $F55E decrement_counters_C82E_C833
LABEL $F56D delay_b_3
LABEL $F571 delay_b_2
LABEL $F575 delay_b_1
LABEL $F579 delay_b_0
LABEL $F57A start_b_delay
LABEL $F57E get_bit_mask
LABEL $F584 get_absolute_value_of_ab
LABEL $F593 convert_rise_run_to_angle
LABEL $F5D9 get_2nd_index_pair
LABEL $F5DB get_1st_index_pair
LABEL $F5EF get_rotation_index_pairs
LABEL $F5FF convert_abs_angle_to_rise_run
LABEL $F601 convert_angle_to_rise_run
LABEL $F610 rotate_vector_list2
LABEL $F61F rotate_vector_list1
LABEL $F637 transform_next_point
LABEL $F65B xform_1
LABEL $F65D xform_1a
LABEL $F661 xform_2
LABEL $F663 xform_2a
LABEL $F67F move_block
LABEL $F683 move_block2
LABEL $F687 init_sound
LABEL $F68D init_sound2
LABEL $F7A9 get_players_game
LABEL $F82C handle_buttons
LABEL $F835 display_option_string
LABEL $F84F set_dft_score
LABEL $F85E convert_a_to_bcd_and_add
LABEL $F87C add_d_to_x_in_bcd
LABEL $F8C7 compare_scores
LABEL $F8D8 check_4_new_hi_score
LABEL $F8E5 modify_target_and_check_4_hit1
LABEL $F8F3 modify_target_and_check_4_hit2
LABEL $F8FF check_bullet_for_hit
LABEL $F903 check_bullet_for_hit2
LABEL $F92E generate_explosion_sound
LABEL $F794 player_string
LABEL $F79F game_string
LABEL $F9DC bit_masks
LABEL $F9E4 music_stuff1
LABEL $F9EA music_stuff2
LABEL $F9F4 character_table
LABEL $FC24 angle_data1
LABEL $FC2C angle_data2
LABEL $FC6D rotation_pair_table
LABEL $FC8D music_routine_data
LABEL $FD0D intro_music_block
LABEL $FD1D berzerk_music_block
LABEL $FD69 music_header1a
LABEL $FD79 music_header2b
LABEL $FEB6 music_header2a
LABEL $FEE8 music_header1b
LABEL $0EEE AM_music
LABEL $0021 start
LABEL $01A2 am_clear_game_RAM
LABEL $009B display_main_menu
LABEL $003A main_loop
LABEL $0ECB check_for_end_of_sound
LABEL $0040 P0040
LABEL $0050 P0050
EQU $56 SM_ERASE_STR
EQU $62 SM_MENU_STR
EQU $6D SM_NEXT_STR
EQU $78 SM_LAST_STR
LABEL $0083 SM_PLAY_STR
LABEL $008E SM_CREATE_STR
LABEL $0169 MM_SKETCH_STR
LABEL $0ACF print_with_pick_check
LABEL $00B5 disp_mm_connect_str
LABEL $0102 disp_only_mm_sketch_str
LABEL $0176 MM_CONNECT_STR
LABEL $00CC disp_mm_animate_str
LABEL $0127 disp_only_mm_connect_str
LABEL $0184 MM_ANIMATE_STR
LABEL $00E3 P00E3
LABEL $00E4 disp_only_mm_animate_str
LABEL $00F9 P00F9
LABEL $00FF P00FF
LABEL $01D6 start_of_animate
LABEL $0117 P0117
LABEL $011D P011D
LABEL $0BCF start_of_sketch_connect
LABEL $013C P013C
LABEL $0142 P0142
LABEL $0151 HDR_CREATE_STR
LABEL $015E HDR_EDIT_STR
LABEL $0192 box
LABEL $01A5 P01A5
LABEL $01AD draw_previous_frame
LABEL $01B3 P01B3
LABEL $053C draw_all_visible_lines
LABEL $0507 draw_points_without_pick
LABEL $01CC select_a_frame
LABEL $056F init_animate_variables
LABEL $01E2 return_to_frame1
LABEL $0224 animate_handler
LABEL $01F2 advance_to_next_frame
LABEL $020F P020F
LABEL $01FE P01FE
LABEL $021D P021D
LABEL $02C7 edit_handler
LABEL $0306 display_frame_num
LABEL $048C find_lightpen_pick
LABEL $0B19 am_print_string
LABEL $0269 P0269
LABEL $055B draw_line_between_2_points
LABEL $0260 P0260
LABEL $042D process_button1_and_2
LABEL $027A disp_sm_erase_str
LABEL $057C add_a_new_line
LABEL $03C2 check_for_move_request
LABEL $0290 disp_sm_next_str
LABEL $02AA disp_sm_menu_str
LABEL $0ED8 set_up_a_misc_sound1
LABEL $02C0 P02C0
LABEL $02CF P02CF
LABEL $02EF P02EF
LABEL $02F7 P02F7
LABEL $032C disp_sm_menu_str2
LABEL $0346 disp_sm_create_str
LABEL $0345 P0345
LABEL $035F disp_sm_next_str2
LABEL $0384 disp_sm_last_str
LABEL $03A8 disp_sm_play_str
LABEL $0EDB set_up_a_misc_sound2
LABEL $03C1 P03C1
LABEL $05D3 init_play_variables
LABEL $059C play_handler
LABEL $03CD process_move
LABEL $0405 continue_moving_point
LABEL $03DB start_moving_point
LABEL $08ED set_cursor_structure
LABEL $040B update_moving_point
LABEL $0901 update_cursor_position
LABEL $0EB2 am_move_to_d
LABEL $07D6 draw_with_pick_check
LABEL $0437 P0437
LABEL $0448 P0448
LABEL $0460 scan_screen_for_lightpen
LABEL $0450 P0450
LABEL $0469 P0469
LABEL $0721 search_screen_for_lightpen
LABEL $0471 P0471
LABEL $0481 P0481
LABEL $049A P049A
LABEL $04A9 check_next_endpoint
LABEL $04D0 P04D0
LABEL $052F cross
LABEL $0A50 dot_pattern
LABEL $0502 P0502
LABEL $050A P050A
LABEL $0513 P0513
LABEL $0545 P0545
LABEL $054A P054A
LABEL $0557 P0557
LABEL $0840 draw_vector_with_pick_check
LABEL $0574 P0574
LABEL $057F P057F
LABEL $0585 P0585
LABEL $0584 P0584
LABEL $0598 P0598
LABEL $05AA P05AA
LABEL $064A get_ptrs_to_playback_frames
LABEL $06A9 fill_playback_buffer
LABEL $05E8 check_playback_speed_buttons
LABEL $05D2 P05D2
LABEL $061D update_playback_variables
LABEL $05F3 decrease_playback_speed
LABEL $0609 increase_playback_speed
LABEL $05FB P05FB
LABEL $060F P060F
LABEL $0632 playback_speed_info
LABEL $067F update_play_index_to_next_frame
LABEL $0669 frame_buf_pointers
LABEL $0699 backward_order
LABEL $0690 start_backwards
LABEL $06A2 start_forward
LABEL $06B9 P06B9
LABEL $06DB P06DB
LABEL $06DC merge_coordinates
LABEL $0701 P0701
LABEL $0712 P0712
LABEL $0714 P0714
LABEL $0716 P0716
LABEL $0718 P0718
LABEL $071A P071A
LABEL $071C P071C
LABEL $071E P071E
LABEL $0720 P0720
LABEL $072C P072C
LABEL $0736 draw_scan_line
LABEL $0754 P0754
LABEL $076D find_point_of_intersection
LABEL $07CE ISR_handler
LABEL $079E P079E
LABEL $07AA disable_interrupts
LABEL $07B7 process_ISR
LABEL $07DE P07DE
LABEL $07F3 P07F3
LABEL $0805 P0805
LABEL $080E P080E
LABEL $0814 P0814
LABEL $082A P082A
LABEL $0831 P0831
LABEL $0879 calculate_vector_endpoint
LABEL $08E7 am_scale_factors
LABEL $086D P086D
LABEL $08BA P08BA
LABEL $0897 P0897
LABEL $089E P089E
LABEL $08AD P08AD
LABEL $0A54 whole_search_pattern
LABEL $0984 find_lightpen
LABEL $0983 P0983
LABEL $092B P092B
LABEL $0A5E lower_search_pattern
LABEL $0949 P0949
LABEL $0940 P0940
LABEL $0A68 upper_search_pattern
LABEL $096A P096A
LABEL $0A7C left_search_pattern
LABEL $097F P097F
LABEL $0A72 right_search_pattern
LABEL $09A3 search_4_lightpen
LABEL $09A8 continue_lightpen_search
LABEL $0A86 small_search_pattern_vl
LABEL $09B7 P09B7
LABEL $0A98 large_search_pattern_vl
LABEL $0AC4 search_pattern_scale_factors
LABEL $09CE draw_search_pattern
LABEL $0A13 display_search_pattern
LABEL $09DC lightpen_found
LABEL $0AAA cursor_deltas
LABEL $0ABA delta_multipliers
LABEL $0A05 generate_new_cursor_coordinate
LABEL $0A0B P0A0B
LABEL $0A12 P0A12
LABEL $0A20 P0A20
LABEL $0A35 P0A35
LABEL $0A47 P0A47
LABEL $0AE4 P0AE4
LABEL $0AEC P0AEC
LABEL $0AED hilite_string
LABEL $0B3C P0B3C
LABEL $0B62 P0B62
LABEL $0B5E P0B5E
LABEL $0BAD P0BAD
LABEL $0B8D P0B8D
LABEL $0BB4 SM_DOT_STR
LABEL $0BBE SM_LINE_STR
LABEL $0BC9 initial_cursor_state
LABEL $0E1F init_sketch_connect_variables
LABEL $0BE1 sketch_connect_handler
LABEL $0BF1 P0BF1
LABEL $0D27 display_sc_menu
LABEL $0E38 sketch_connect_draw_vector_list
LABEL $0C95 fan_handler
LABEL $0C0F sc_start_draw
LABEL $0C09 P0C09
LABEL $0C12 sc_start_fan
LABEL $0C46 sc_start_rubber_band_line
LABEL $0C5B sc_draw_handler
LABEL $0C1A P0C1A
LABEL $0CDA rubber_band_line_handler
LABEL $0C57 P0C57
LABEL $0C72 P0C72
LABEL $0DFA get_new_endpoint
LABEL $0C7C fix_endpoint
LABEL $0C85 P0C85
LABEL $0CB7 continue_drawing_fan
LABEL $0CC1 P0CC1
LABEL $0CCA P0CCA
LABEL $0CF4 continue_rb_line
LABEL $0CFE P0CFE
LABEL $0D0B P0D0B
LABEL $0D0C HDR_CONNECT_STR
LABEL $0D1A HDR_SKETCH_STR
LABEL $0D48 P0D48
LABEL $0D43 P0D43
LABEL $0D4E P0D4E
LABEL $0D7C P0D7C
LABEL $0D98 P0D98
LABEL $0DB0 P0DB0
LABEL $0DB2 gen_vec_endpoint_recal
COMMENT_LABEL $0DB2 generate_vector_endpoint_and_recalibrate
LABEL $0DD6 P0DD6
LABEL $0DCC P0DCC
LABEL $0DF0 P0DF0
LABEL $0E02 P0E02
LABEL $0E14 P0E14
LABEL $0E24 P0E24
LABEL $0E40 P0E40
LABEL $0E54 draw_relative_points
LABEL $0E4A move_to_abs_ref_point
LABEL $0E59 P0E59
LABEL $0E5E P0E5E
LABEL $0E68 sc_draw_to_point
LABEL $0E75 sc_move_to_point
LABEL $0E8F am_draw_with_pattern
LABEL $0EA9 P0EA9
LABEL $0EC6 P0EC6
LABEL $0ED4 P0ED4
LABEL $1000 *
COMMENT_LINE $0000 can be assembled correctly now
COMMENT_LINE $0000 compatibilty added by Malban
COMMENT_LINE $0000 assenmble with comand line:
COMMENT_LINE $0000 .\ass\as09.exe -w200 -h0 -l -mcti art.asm >error
COMMENT_LINE $0000 used the 6809 assembler:
COMMENT_LINE $0000 as09 [1.11].
COMMENT_LINE $0000 Copyright 1990-1994, Frank A. Vorstenbosch, Kingswood Software.
COMMENT_LINE $0000 Available at:
COMMENT_LINE $0000 http://www.falstaff.demon.co.uk/cross.html
COMMENT_LINE $0000 This work was originally done by Fred Taft (fred@hp-pcd.cv.hp.com).
COMMENT_LINE $0000 Please forward any comments, corrections or additions back to Fred.
COMMENT_LINE $0000 Art Master
COMMENT_LINE $0000 bios routines
COMMENT_LINE $0000 bios data
COMMENT $000D * height
COMMENT $000E * width
COMMENT $000F * rel y
COMMENT $0010 * rel x
COMMENT $0015 * height
COMMENT $0016 * width
COMMENT $0017 * rel y
COMMENT $0018 * rel x
COMMENT_LINE $0021 Art Master
COMMENT_LINE $0021 This is the entry point for the Art Master game.
COMMENT_LINE $0021 It initializes the RAM area used by the game, initializes
COMMENT_LINE $0021 the music buffer, sets up the indirect jump location
COMMENT_LINE $0021 in C8A7, and lastly, passes control to the main loop.
FORCE_SYMBOL $0022 am_clear_game_RAM
FORCE_SYMBOL $0025 reinit
FORCE_SYMBOL $0028 init_music_buf
FORCE_NO_SYMBOL $002B
FORCE_SYMBOL $002E do_sound
FORCE_SYMBOL $0031 display_main_menu
FORCE_NO_SYMBOL $0034
FORCE_NO_SYMBOL $0037
COMMENT_LINE $003A main_loop()
COMMENT_LINE $003A This main loop is responsible for reading the buttons
COMMENT_LINE $003A on the primary console, continuing any sounds which
COMMENT_LINE $003A are in progress, and then calling whichever handling
COMMENT_LINE $003A routine has been = up in the indirect jump location.
COMMENT_LINE $003A After this, it recalibrates the integraters, and then
COMMENT_LINE $003A repeats the above.
FORCE_SYMBOL $003A read_switches2
FORCE_SYMBOL $003D check_for_end_of_sound
FORCE_SYMBOL $0040 do_sound
COMMENT $0043 * Keep track of the fact that
FORCE_NO_SYMBOL $0043
COMMENT $0046 * a string was picked last pass
FORCE_NO_SYMBOL $0046
COMMENT $0049 * thru the main loop.
FORCE_NO_SYMBOL $0049
FORCE_NO_SYMBOL $004C
FORCE_SYMBOL $0050 waitrecal
FORCE_SYMBOL $0053 main_loop
COMMENT_LINE $009B The next 3 blocks of code cause the three main
COMMENT_LINE $009B menu items (sketch, connect and animate) to be
COMMENT_LINE $009B displayed, until one of them is picked by the
COMMENT_LINE $009B lightpen (a pick is indicated by C89E != 0).
COMMENT_LINE $009B When a pick occurs, the counter in C888
COMMENT_LINE $009B is set, and the jump location (C8A7) is = so that
COMMENT_LINE $009B only the picked option is displayed.
FORCE_SYMBOL $009B intensity_to_7F
FORCE_SYMBOL $009E MM_SKETCH_STR
FORCE_SYMBOL $00A1 print_with_pick_check
FORCE_NO_SYMBOL $00A4
FORCE_NO_SYMBOL $00A9
FORCE_NO_SYMBOL $00AB
FORCE_SYMBOL $00AE disp_only_mm_sketch_str
FORCE_NO_SYMBOL $00B1
FORCE_SYMBOL $00B5 MM_CONNECT_STR
FORCE_SYMBOL $00B8 print_with_pick_check
FORCE_NO_SYMBOL $00BB
FORCE_NO_SYMBOL $00C0
FORCE_NO_SYMBOL $00C2
FORCE_SYMBOL $00C5 disp_only_mm_connect_str
FORCE_NO_SYMBOL $00C8
FORCE_SYMBOL $00CC MM_ANIMATE_STR
FORCE_SYMBOL $00CF print_with_pick_check
FORCE_NO_SYMBOL $00D2
FORCE_SYMBOL $00D7 disp_only_mm_animate_str
FORCE_NO_SYMBOL $00DA
FORCE_NO_SYMBOL $00DD
FORCE_NO_SYMBOL $00DF
COMMENT_LINE $00E4 Continue to display the ANIMATE main menu item,
COMMENT_LINE $00E4 until either the loop counter (C888) decrements
COMMENT_LINE $00E4 to zero (at which point the ANIMATE activity starts),
COMMENT_LINE $00E4 or the string is no longer picked (then display the
COMMENT_LINE $00E4 main menu again).
FORCE_SYMBOL $00E4 intensity_to_7F
FORCE_SYMBOL $00E7 MM_ANIMATE_STR
FORCE_SYMBOL $00EA print_with_pick_check
FORCE_NO_SYMBOL $00ED
FORCE_SYMBOL $00F2 display_main_menu
FORCE_NO_SYMBOL $00F5
FORCE_NO_SYMBOL $00F9
FORCE_SYMBOL $00FF start_of_animate
COMMENT_LINE $0102 Continue to display the SKETCH main menu item,
COMMENT_LINE $0102 until either the loop counter (C888) decrements
COMMENT_LINE $0102 to zero (at which point the SKETCH activity starts),
COMMENT_LINE $0102 or the string is no longer picked (then display the
COMMENT_LINE $0102 main menu again).
FORCE_SYMBOL $0102 intensity_to_7F
FORCE_SYMBOL $0105 MM_SKETCH_STR
FORCE_SYMBOL $0108 print_with_pick_check
FORCE_NO_SYMBOL $010B
FORCE_SYMBOL $0110 display_main_menu
FORCE_NO_SYMBOL $0113
FORCE_NO_SYMBOL $0117
COMMENT $011D * Flag this is sketch mode
FORCE_NO_SYMBOL $011D
FORCE_SYMBOL $0120 start_of_sketch_connect
FORCE_NO_SYMBOL $0123
COMMENT_LINE $0127 Continue to display the CONNECT main menu item,
COMMENT_LINE $0127 until either the loop counter (C888) decrements
COMMENT_LINE $0127 to zero (at which point the CONNECT activity starts),
COMMENT_LINE $0127 or the string is no longer picked (then display the
COMMENT_LINE $0127 main menu again).
FORCE_SYMBOL $0127 intensity_to_7F
FORCE_SYMBOL $012A MM_CONNECT_STR
FORCE_SYMBOL $012D print_with_pick_check
FORCE_NO_SYMBOL $0130
FORCE_SYMBOL $0135 display_main_menu
FORCE_NO_SYMBOL $0138
FORCE_NO_SYMBOL $013C
FORCE_NO_SYMBOL $0142
COMMENT $0144 * CONNECT option
FORCE_NO_SYMBOL $0144
COMMENT $0147 * Do dots first
FORCE_NO_SYMBOL $0147
FORCE_SYMBOL $014A start_of_sketch_connect
FORCE_NO_SYMBOL $014D
COMMENT_LINE $0192 This is the vector list which describes the box
COMMENT_LINE $0192 which is sometimes drawn around a selected point.
COMMENT_LINE $0192 The list has the following format:
COMMENT_LINE $0192 line pattern, rel y, rel x
COMMENT_LINE $0192 A line pattern of 1 signals the end.
COMMENT_LINE $01A2 am_clear_game_RAM()
COMMENT_LINE $01A2 Clear to zero, the block of RAM which is used
COMMENT_LINE $01A2 by the Art Master game: C880 - CB7F
FORCE_NO_SYMBOL $01A2
FORCE_NO_SYMBOL $01A7
COMMENT_LINE $01AD draw_previous_frame()
COMMENT_LINE $01AD This routine gets information for the previous frame
COMMENT_LINE $01AD during ANIMATE mode.  It will then use the new
COMMENT_LINE $01AD frame number to index into the structure starting
COMMENT_LINE $01AD at C977 (the vectors for this frame), using the
COMMENT_LINE $01AD following formula:
COMMENT_LINE $01AD C917 = (previous_frame_num* 64) + C977
COMMENT_LINE $01AD Afterwards, it will draw the vectors associated with
COMMENT_LINE $01AD this frame, using a small intensity, thus allowing the
COMMENT_LINE $01AD user to see the previous frame he made.
FORCE_NO_SYMBOL $01AD
FORCE_NO_SYMBOL $01B4
FORCE_NO_SYMBOL $01B8
FORCE_NO_SYMBOL $01BD
FORCE_NO_SYMBOL $01C0
FORCE_SYMBOL $01C2 intensity_to_a
FORCE_SYMBOL $01C5 draw_all_visible_lines
FORCE_SYMBOL $01C8 draw_points_without_pick
COMMENT_LINE $01CC select_a_frame (frame_num)
COMMENT_LINE $01CC This procedure selects a particular frame
COMMENT_LINE $01CC as the active frame, and returns a pointer
COMMENT_LINE $01CC to the vector list associated with that frame
COMMENT_LINE $01CC in the 'x' register.  At entry, the 'b' register
COMMENT_LINE $01CC specifies which frame is to be selected.
COMMENT $01CD * " "
FORCE_NO_SYMBOL $01CD
FORCE_NO_SYMBOL $01D0
COMMENT_LINE $01D6 This is the starting point for the
COMMENT_LINE $01D6 ANIMATE main menu option.
FORCE_SYMBOL $01D6 am_clear_game_RAM
FORCE_SYMBOL $01D9 init_animate_variables
FORCE_NO_SYMBOL $01DC
FORCE_NO_SYMBOL $01DF
FORCE_NO_SYMBOL $01E2
FORCE_NO_SYMBOL $01E5
FORCE_NO_SYMBOL $01E8
FORCE_SYMBOL $01EB animate_handler
FORCE_NO_SYMBOL $01EE
COMMENT_LINE $01F2 advance_to_next_frame()
COMMENT_LINE $01F2 This procedure first checks to see if we will be
COMMENT_LINE $01F2 entering a virgin frame (C8A5 == C8A6), and if we
COMMENT_LINE $01F2 are, then it copies the data in the current frames
COMMENT_LINE $01F2 vector list area into the area associated with the
COMMENT_LINE $01F2 next frame.  In any case, the frame counter is
COMMENT_LINE $01F2 incremented, and if this is a virgin frame, then
COMMENT_LINE $01F2 C8A6 is updated to reflect the fact that we have
COMMENT_LINE $01F2 now advanced into a new frame.
COMMENT $01F2 * If C8A5 == C8A6, then init
FORCE_NO_SYMBOL $01F2
COMMENT $01F5 * the new vector list area.
FORCE_NO_SYMBOL $01F5
FORCE_SYMBOL $01FA select_a_frame
COMMENT $01FE * Copy vector list info from
FORCE_NO_SYMBOL $01FE
COMMENT $0200 * current frame to new frame.
FORCE_NO_SYMBOL $0200
FORCE_NO_SYMBOL $0203
FORCE_NO_SYMBOL $0205
FORCE_NO_SYMBOL $0208
FORCE_NO_SYMBOL $020B
COMMENT $020F * Increment the frame counter, and
FORCE_NO_SYMBOL $020F
COMMENT $0212 * update C8A6 if this is a virgin
FORCE_NO_SYMBOL $0212
COMMENT $0215 * frame being entered.
FORCE_NO_SYMBOL $0215
FORCE_NO_SYMBOL $021A
FORCE_SYMBOL $021D edit_handler
FORCE_NO_SYMBOL $0220
COMMENT_LINE $0224 animate_handler()
COMMENT_LINE $0224 This procedure is responsible for overseeing the
COMMENT_LINE $0224 work done by the ANIMATE command.  It is invoked
COMMENT_LINE $0224 through the indirect jump location.
FORCE_SYMBOL $0224 display_frame_num
FORCE_SYMBOL $0227 reset0ref
COMMENT $022A * Reset pointer to the
FORCE_NO_SYMBOL $022A
COMMENT $022D * first frame.
FORCE_NO_SYMBOL $022D
FORCE_NO_SYMBOL $0230
FORCE_SYMBOL $0233 intensity_to_7F
FORCE_SYMBOL $0236 find_lightpen_pick
FORCE_SYMBOL $0239 draw_all_visible_lines
FORCE_SYMBOL $023C reset0ref
FORCE_SYMBOL $023F HDR_CREATE_STR
FORCE_SYMBOL $0242 am_print_string
COMMENT $0245 * If a vector was picked, then
FORCE_NO_SYMBOL $0245
COMMENT $0248 * highlight it, by redrawing
FORCE_NO_SYMBOL $0248
COMMENT $024C * it several times.
FORCE_SYMBOL $0250 draw_line_between_2_points
FORCE_SYMBOL $0253 draw_line_between_2_points
FORCE_SYMBOL $0256 draw_line_between_2_points
COMMENT $0259 * If button 4 (delete) is
FORCE_NO_SYMBOL $0259
COMMENT $025C * pressed, then remove the
COMMENT $025E * indexes for this line from
COMMENT $0260 * the line array.
FORCE_NO_SYMBOL $0260
FORCE_NO_SYMBOL $0264
FORCE_SYMBOL $0269 process_button1_and_2
COMMENT $026D * If button 2 was pressed,
COMMENT $026F * then add the indexes for
FORCE_NO_SYMBOL $026F
COMMENT $0272 * the line endpoints to the
COMMENT $0274 * line array (C8A9-C90E).
FORCE_NO_SYMBOL $0274
FORCE_SYMBOL $0277 add_a_new_line
COMMENT_LINE $027A disp_sm_erase_str()
COMMENT_LINE $027A Display the ERASE sub-menu string, while the
COMMENT_LINE $027A ANIMATE option is in CREATE mode.  If the
COMMENT_LINE $027A string is picked (C89E != 0) while button 3
COMMENT_LINE $027A is pressed (C814 != 0), then jump to the routine
COMMENT_LINE $027A which re_initializes the animate buffers and
COMMENT_LINE $027A variables; this erases the all current frames.
FORCE_SYMBOL $027A check_for_move_request
FORCE_SYMBOL $027D SM_ERASE_STR
FORCE_SYMBOL $0280 print_with_pick_check
FORCE_NO_SYMBOL $0283
FORCE_NO_SYMBOL $0288
FORCE_SYMBOL $028D start_of_animate
COMMENT_LINE $0290 disp_sm_next_str()
COMMENT_LINE $0290 Display the NEXT sub-menu string, while the
COMMENT_LINE $0290 ANIMATE option is in CREATE mode.  If the string
COMMENT_LINE $0290 is picked (C89E != 0) while button 3 is pressed
COMMENT_LINE $0290 (C814 != 0), then advance to the next ANIMATE frame.
FORCE_SYMBOL $0290 SM_NEXT_STR
FORCE_SYMBOL $0293 print_with_pick_check
FORCE_NO_SYMBOL $0296
FORCE_NO_SYMBOL $029B
FORCE_SYMBOL $02A0 advance_to_next_frame
FORCE_NO_SYMBOL $02A3
FORCE_SYMBOL $02A6 set_up_a_misc_sound1
COMMENT_LINE $02AA disp_sm_menu_str()
COMMENT_LINE $02AA Display the MENU sub-menu string, while the
COMMENT_LINE $02AA ANIMATE option is in CREATE mode.  If the string
COMMENT_LINE $02AA is picked (C89E != 0) while button 3 is pressed
COMMENT_LINE $02AA (C814 != 0), then exit from ANIMATE mode, and return
COMMENT_LINE $02AA to the main menu.
FORCE_SYMBOL $02AA SM_MENU_STR
FORCE_SYMBOL $02AD print_with_pick_check
FORCE_NO_SYMBOL $02B0
FORCE_NO_SYMBOL $02B5
FORCE_SYMBOL $02BA display_main_menu
FORCE_NO_SYMBOL $02BD
COMMENT $02C1 * height of FR string
COMMENT $02C2 * width of FR string
COMMENT $02C3 * rel y of FR string
COMMENT $02C4 * rel x of FR string
COMMENT $02C5 * pointer to start of FR string
COMMENT_LINE $02C7 edit_handler()
COMMENT_LINE $02C7 This procedure is responsible for processing the
COMMENT_LINE $02C7 buttons during the EDIT portion of ANIMATE mode.
COMMENT_LINE $02C7 It also displays the EDIT header, and the sub-menu
COMMENT_LINE $02C7 items (if they have not bee disabled).  This is
COMMENT_LINE $02C7 invoked only through the indirect jump location.
COMMENT $02C7 * See if a background image
FORCE_NO_SYMBOL $02C7
COMMENT $02CA * needs to be displayed.
FORCE_SYMBOL $02CC draw_previous_frame
FORCE_NO_SYMBOL $02CF
FORCE_SYMBOL $02D2 select_a_frame
FORCE_NO_SYMBOL $02D5
FORCE_SYMBOL $02D8 intensity_to_7F
FORCE_NO_SYMBOL $02DB
FORCE_SYMBOL $02DE find_lightpen_pick
FORCE_SYMBOL $02E1 draw_all_visible_lines
FORCE_SYMBOL $02E4 check_for_move_request
COMMENT $02E7 * Check button 4 (background)
FORCE_NO_SYMBOL $02E7
COMMENT $02EC * Toggle state of background flag
FORCE_NO_SYMBOL $02EC
COMMENT $02EF * Check button 1 (foreground)
FORCE_NO_SYMBOL $02EF
COMMENT $02F4 * Toggle state of foreground flag
FORCE_NO_SYMBOL $02F4
FORCE_SYMBOL $02F7 reset0ref
COMMENT $02FA * Display EDIT screen header
FORCE_SYMBOL $02FA HDR_EDIT_STR
FORCE_SYMBOL $02FD am_print_string
COMMENT $0300 * See if sub-menu should be displayed
FORCE_NO_SYMBOL $0300
COMMENT_LINE $0306 display_frame_num()
COMMENT_LINE $0306 Display the frame number string:
COMMENT_LINE $0306 "FR #",$80
COMMENT $0306 * "F"
FORCE_NO_SYMBOL $0306
COMMENT $0308 * "R"
FORCE_NO_SYMBOL $0308
FORCE_NO_SYMBOL $030A
COMMENT $030D * " "
FORCE_NO_SYMBOL $030D
FORCE_NO_SYMBOL $030F
FORCE_NO_SYMBOL $0312
FORCE_NO_SYMBOL $0314
FORCE_NO_SYMBOL $0317
COMMENT $031A * "1"
FORCE_NO_SYMBOL $031A
FORCE_NO_SYMBOL $031C
FORCE_NO_SYMBOL $031F
FORCE_SYMBOL $0322 reset0ref
FORCE_SYMBOL $0325 delay_b_3
FORCE_SYMBOL $0328 am_print_string
COMMENT_LINE $032C disp_sm_menu_str2()
COMMENT_LINE $032C Display the MENU sub-menu string, while the
COMMENT_LINE $032C ANIMATE option is in EDIT mode.  If the string
COMMENT_LINE $032C is picked (C89E != 0) while button 3 is pressed
COMMENT_LINE $032C (C814 != 0), then exit from ANIMATE mode, and return
COMMENT_LINE $032C to the main menu.
FORCE_SYMBOL $032C display_frame_num
FORCE_SYMBOL $032F SM_MENU_STR
FORCE_SYMBOL $0332 print_with_pick_check
FORCE_NO_SYMBOL $0335
FORCE_NO_SYMBOL $033A
FORCE_SYMBOL $033F display_main_menu
FORCE_NO_SYMBOL $0342
COMMENT_LINE $0346 disp_sm_create_str()
COMMENT_LINE $0346 Display the CREATE sub-menu string, while the
COMMENT_LINE $0346 ANIMATE option is in EDIT mode.  If the string
COMMENT_LINE $0346 is picked (C89E != 0) while button 3 is pressed
COMMENT_LINE $0346 (C814 != 0), then exit from EDIT mode, and return
COMMENT_LINE $0346 to CREATE mode.
FORCE_SYMBOL $0346 SM_CREATE_STR
FORCE_SYMBOL $0349 print_with_pick_check
FORCE_NO_SYMBOL $034C
FORCE_NO_SYMBOL $0351
FORCE_SYMBOL $0356 SM_ERASE_STR
FORCE_NO_SYMBOL $0359
FORCE_SYMBOL $035C return_to_frame1
COMMENT_LINE $035F disp_sm_next_str2()
COMMENT_LINE $035F Display the NEXT sub-menu string, while the
COMMENT_LINE $035F ANIMATE option is in EDIT mode.  If the string
COMMENT_LINE $035F is picked (C89E != 0) while button 3 is pressed
COMMENT_LINE $035F (C814 != 0), then advance to the next frame, and
COMMENT_LINE $035F make a sound also.
COMMENT $035F * Only display this label if we
FORCE_NO_SYMBOL $035F
COMMENT $0362 * are not already at last frame
FORCE_NO_SYMBOL $0362
FORCE_SYMBOL $0366 SM_NEXT_STR
FORCE_SYMBOL $0369 print_with_pick_check
FORCE_NO_SYMBOL $036C
FORCE_NO_SYMBOL $0371
COMMENT $0376 * Increment the frame counter
FORCE_NO_SYMBOL $0376
FORCE_NO_SYMBOL $0379
FORCE_SYMBOL $037D advance_to_next_frame
FORCE_SYMBOL $0380 set_up_a_misc_sound1
COMMENT_LINE $0384 disp_sm_last_str()
COMMENT_LINE $0384 Display the LAST sub-menu string, while the
COMMENT_LINE $0384 ANIMATE option is in EDIT mode.  If the string
COMMENT_LINE $0384 is picked (C89E != 0) while button 3 is pressed
COMMENT_LINE $0384 (C814 != 0), then display the previous frame, and
COMMENT_LINE $0384 make a sound also.
COMMENT $0384 * Only display this label if not
FORCE_NO_SYMBOL $0384
COMMENT $0387 * already at first frame.
FORCE_SYMBOL $0389 SM_LAST_STR
FORCE_SYMBOL $038C print_with_pick_check
FORCE_NO_SYMBOL $038F
FORCE_NO_SYMBOL $0394
FORCE_NO_SYMBOL $0399
COMMENT $039E * Decrement frame counter
FORCE_NO_SYMBOL $039E
FORCE_NO_SYMBOL $03A1
FORCE_SYMBOL $03A4 set_up_a_misc_sound2
COMMENT_LINE $03A8 disp_sm_play_str()
COMMENT_LINE $03A8 Display the PLAY sub-menu string, while the
COMMENT_LINE $03A8 ANIMATE option is in EDIT mode.  If the string
COMMENT_LINE $03A8 is picked (C89E != 0) while button 3 is pressed
COMMENT_LINE $03A8 (C814 != 0), then prepare to start playing through
COMMENT_LINE $03A8 the current = of defined frames.
FORCE_SYMBOL $03A8 SM_PLAY_STR
FORCE_SYMBOL $03AB print_with_pick_check
FORCE_NO_SYMBOL $03AE
FORCE_NO_SYMBOL $03B3
FORCE_SYMBOL $03B8 init_play_variables
FORCE_SYMBOL $03BB play_handler
FORCE_NO_SYMBOL $03BE
COMMENT_LINE $03C2 check_for_move_request()
COMMENT_LINE $03C2 This routine is responsible for checking the state
COMMENT_LINE $03C2 of button 3 (move a point) during ANIMATE mode.  This
COMMENT_LINE $03C2 is called by the CREATE and EDIT handlers, for each
COMMENT_LINE $03C2 pass through the handler loop.
COMMENT_LINE $03C2 C912 indicates if a move request is currently active.
COMMENT_LINE $03C2 C90F contains index of currently picked point.
COMMENT_LINE $03C2 C917 points to the beginning of the vector list.
COMMENT $03C2 * Check for button 3 transition
FORCE_NO_SYMBOL $03C2
COMMENT $03C5 * Button 3 = move a point.
FORCE_NO_SYMBOL $03C5
FORCE_NO_SYMBOL $03C9
COMMENT $03CD * See if button 3 is now pressed
FORCE_NO_SYMBOL $03CD
COMMENT $03D2 * Make sure a point is picked
FORCE_NO_SYMBOL $03D2
FORCE_NO_SYMBOL $03D7
FORCE_NO_SYMBOL $03DB
COMMENT $03DD * Flag that move is active
FORCE_NO_SYMBOL $03DD
FORCE_NO_SYMBOL $03E0
COMMENT $03E3 * Set up new cursor movement
FORCE_NO_SYMBOL $03E3
COMMENT $03E6 * limits.
FORCE_NO_SYMBOL $03E6
FORCE_NO_SYMBOL $03E9
FORCE_NO_SYMBOL $03EC
COMMENT $03F0 * Save index of moving point
FORCE_NO_SYMBOL $03F0
FORCE_NO_SYMBOL $03F3
COMMENT $03F6 * Get point's coordinates
FORCE_NO_SYMBOL $03F8
COMMENT $03FB * Move cursor to this point
FORCE_NO_SYMBOL $03FB
FORCE_NO_SYMBOL $03FE
FORCE_SYMBOL $0401 set_cursor_structure
FORCE_NO_SYMBOL $0405
COMMENT $040B * Replace the location of
FORCE_NO_SYMBOL $040B
COMMENT $040E * the picked point
FORCE_SYMBOL $040E update_cursor_position
COMMENT $0411 * in the vector list.
FORCE_NO_SYMBOL $0411
FORCE_NO_SYMBOL $0414
FORCE_NO_SYMBOL $0417
FORCE_SYMBOL $041C reset0ref
FORCE_SYMBOL $0421 am_move_to_d
COMMENT $0424 * Draw the lightpen box
FORCE_SYMBOL $0424 box
COMMENT $0427 * around the picked point
FORCE_NO_SYMBOL $0427
FORCE_SYMBOL $0429 draw_with_pick_check
COMMENT_LINE $042D process_button1_and_2()
COMMENT_LINE $042D This procedure checks to see if buttons 1 or 2 are
COMMENT_LINE $042D during animate mode.  If neither button is pressed,
COMMENT_LINE $042D then this routine returns without doing anything.
COMMENT_LINE $042D However, if either button is pressed, then this routine
COMMENT_LINE $042D attempts to 'locate' the lightpen.  If C90F != $FF,
COMMENT_LINE $042D then this implies that the lightpen is already at a
COMMENT_LINE $042D known place (on an existing point); if C90F == $FF,
COMMENT_LINE $042D then a series of horizontal scan lines will be drawn,
COMMENT_LINE $042D until the lightpen is located, or the whole screen is
COMMENT_LINE $042D scanned.
COMMENT_LINE $042D At entry:
COMMENT_LINE $042D (C8A3)-1 contains index of next available spot
COMMENT_LINE $042D in the vector list.
COMMENT_LINE $042D At exit time:
COMMENT_LINE $042D 'a' register =  0 => lightpen not located.
COMMENT_LINE $042D 'a' register = FF => lightpen located, and
COMMENT_LINE $042D C910 is = to index of current point, and
COMMENT_LINE $042D C911 is = to index of previous point.
COMMENT $042D * Check if either button 1 or
FORCE_NO_SYMBOL $042D
COMMENT $0430 * button 2 is pressed.
FORCE_NO_SYMBOL $0430
COMMENT $0435 * Lightpen not located
COMMENT $0437 * See if the lightpen is on an
FORCE_NO_SYMBOL $0437
COMMENT $043A * existing point.
COMMENT $043C * YES it is, so save the index
FORCE_NO_SYMBOL $043C
COMMENT $043F * this point, and the previous
FORCE_NO_SYMBOL $043F
COMMENT $0442 * point the lightpen picked.
FORCE_NO_SYMBOL $0442
FORCE_NO_SYMBOL $0445
FORCE_SYMBOL $0448 scan_screen_for_lightpen
COMMENT $044E * Lightpen not located.
COMMENT $0450 * Lightpen located, so save new
FORCE_NO_SYMBOL $0450
COMMENT $0453 * cursor position index, and the
FORCE_NO_SYMBOL $0453
COMMENT $0456 * previous lightpen position.
FORCE_NO_SYMBOL $0456
FORCE_NO_SYMBOL $045A
COMMENT $045D * Lightpen located
FORCE_NO_SYMBOL $045D
COMMENT_LINE $0460 scan_screen_for_lightpen()
COMMENT_LINE $0460 If the current frame is not filled, then this routine
COMMENT_LINE $0460 will perform a full screen scan, in an attempt to
COMMENT_LINE $0460 locate the lightpen.  If the lightpen is located, then
COMMENT_LINE $0460 its position is saved in the next location in the vector
COMMENT_LINE $0460 list for all 9 frames.
COMMENT_LINE $0460 At entry:
COMMENT_LINE $0460 C917 points to the start of the vector list.
COMMENT_LINE $0460 C8A3 contains index into next available place
COMMENT_LINE $0460 in the vector list.
COMMENT_LINE $0460 At exit:
COMMENT_LINE $0460 'a' =    0 if lightpen was not located.
COMMENT_LINE $0460 'a' = $FF if lightpen was located.
COMMENT $0460 * See if this frame is already full
FORCE_NO_SYMBOL $0460
FORCE_NO_SYMBOL $0463
FORCE_SYMBOL $0469 search_screen_for_lightpen
COMMENT $046F * Lightpen not found
COMMENT $0471 * Lightpen was found
FORCE_NO_SYMBOL $0471
FORCE_NO_SYMBOL $0474
COMMENT $0478 * Save lightpen location.
COMMENT $047A * Increment vector list index.
FORCE_NO_SYMBOL $047A
FORCE_NO_SYMBOL $047D
COMMENT $0481 * Add this point to each of the
FORCE_NO_SYMBOL $0481
COMMENT $0484 * 8 other frames.
FORCE_NO_SYMBOL $0484
COMMENT $0489 * Lightpen was found
FORCE_NO_SYMBOL $0489
COMMENT_LINE $048C find_lightpen_pick()
COMMENT_LINE $048C This routine draws a dot at each endpoint for every
COMMENT_LINE $048C vector currently defined in the frame vector list.
COMMENT_LINE $048C if a lightpen pick is detected when a dot is drawn,
COMMENT_LINE $048C box will be drawn around that endpoint.  The cross
COMMENT_LINE $048C will be drawn at the last known cursor position.
COMMENT_LINE $048C At entry:
COMMENT_LINE $048C C8A3 contains index of next available spot in
COMMENT_LINE $048C the vector list.
COMMENT_LINE $048C C910 contains index of last known cursor position.
COMMENT_LINE $048C At exit:
COMMENT_LINE $048C C90F contains index of picked point; $FF if
COMMENT_LINE $048C no point was picked.
COMMENT_LINE $048C Work variables:
COMMENT_LINE $048C C915 flags if a point was already picked.
COMMENT_LINE $048C C880 contains index into the vector list for the
COMMENT_LINE $048C next endpoint to check.
COMMENT_LINE $048C C881 contains index of picked point.
COMMENT $048C * Clear 'point picked' flag
FORCE_NO_SYMBOL $048C
FORCE_SYMBOL $048F intensity_to_7F
COMMENT $0492 * Init vector list index to 0
FORCE_NO_SYMBOL $0492
FORCE_NO_SYMBOL $0495
COMMENT $0497 * Init picked point index to 0
FORCE_NO_SYMBOL $0497
FORCE_NO_SYMBOL $049A
COMMENT $049D * See if we're at end of list
FORCE_NO_SYMBOL $049D
FORCE_NO_SYMBOL $04A2
COMMENT $04A5 * Return index of picked point
FORCE_NO_SYMBOL $04A5
FORCE_NO_SYMBOL $04A9
FORCE_SYMBOL $04AC reset0ref
FORCE_NO_SYMBOL $04AF
COMMENT $04B2 * Get the index for the next point
FORCE_NO_SYMBOL $04B2
COMMENT $04B5 * to be checked, and see if it equals
COMMENT $04B7 * the index of the cursor position.
FORCE_NO_SYMBOL $04B7
FORCE_SYMBOL $04BA animate_handler
COMMENT $04BD * If so, then draw the cross at this
COMMENT $04BF * location.
FORCE_SYMBOL $04C2 am_move_to_d
FORCE_SYMBOL $04C5 cross
FORCE_NO_SYMBOL $04C8
FORCE_SYMBOL $04CA draw_with_pick_check
FORCE_SYMBOL $04CD reset0ref
FORCE_NO_SYMBOL $04D0
COMMENT $04D3 * Draw dot at this endpoint, and see
COMMENT $04D4 * if it was picked by the lightpen
FORCE_NO_SYMBOL $04D6
FORCE_SYMBOL $04D9 am_move_to_d
FORCE_SYMBOL $04DC dot_pattern
FORCE_NO_SYMBOL $04DF
FORCE_SYMBOL $04E1 draw_with_pick_check
COMMENT $04E4 * Check for a lightpen pick
COMMENT $04E7 * Ignore, if previous pick occurred
FORCE_NO_SYMBOL $04E7
COMMENT $04EC * Ignore, if a move is active
FORCE_NO_SYMBOL $04EC
COMMENT $04F1 * Draw a box around this endpoint
FORCE_SYMBOL $04F1 box
FORCE_NO_SYMBOL $04F4
FORCE_SYMBOL $04F6 draw_with_pick_check
FORCE_NO_SYMBOL $04F9
COMMENT $04FC * Save index of picked point.
FORCE_NO_SYMBOL $04FC
COMMENT $04FF * Flag that a pick occurred.
FORCE_NO_SYMBOL $04FF
FORCE_NO_SYMBOL $0502
COMMENT $0505 * Loop to next point
COMMENT_LINE $0507 draw_points_without_pick()
COMMENT_LINE $0507 This routine goes through the vector list for the
COMMENT_LINE $0507 current frame, and draws a dot at each endpoint.
COMMENT_LINE $0507 Lightpen picks are ignored.
FORCE_NO_SYMBOL $0507
COMMENT $050A * Keep processing, until we reach
FORCE_NO_SYMBOL $050A
COMMENT $050D * the end of the vector list.
FORCE_NO_SYMBOL $050D
FORCE_NO_SYMBOL $0513
FORCE_SYMBOL $0516 reset0ref
FORCE_NO_SYMBOL $0519
COMMENT $051F * Move to next endpoint, and
FORCE_SYMBOL $051F am_move_to_d
COMMENT $0522 * draw a dot there.
FORCE_SYMBOL $0522 dot_pattern
FORCE_NO_SYMBOL $0525
FORCE_SYMBOL $0527 draw_with_pick_check
FORCE_NO_SYMBOL $052A
COMMENT_LINE $052F This is a = of move and draw instructions,
COMMENT_LINE $052F which result in a cross being displayed.
COMMENT $052F * move
COMMENT $0532 * draw
COMMENT $0535 * move
COMMENT $0538 * draw
COMMENT $053B * end of list
COMMENT_LINE $053C draw_all_visible_lines()
COMMENT_LINE $053C This routine draws all of the visible lines in
COMMENT_LINE $053C the current animate frame.  While these lines are
COMMENT_LINE $053C being drawn, any lightpen picks are saved for later
COMMENT_LINE $053C use.
COMMENT_LINE $053C C8A9 is start of array containing indexes of
COMMENT_LINE $053C endpoints for each visible line.
COMMENT_LINE $053C At exit:
COMMENT_LINE $053C C915 points to the index pair, in the line array
COMMENT_LINE $053C (C8A9), of the vector which was picked; $FFFF
COMMENT_LINE $053C if none were picked.
COMMENT $053C * Load addr of line index array
FORCE_NO_SYMBOL $053C
FORCE_NO_SYMBOL $053F
COMMENT $0542 * Init picked vector pointer
FORCE_NO_SYMBOL $0542
FORCE_NO_SYMBOL $0545
FORCE_NO_SYMBOL $054A
FORCE_SYMBOL $054E draw_line_between_2_points
COMMENT $0551 * Check to see if a pick occurred,
COMMENT $0552 * and save a pointer to the endpt
COMMENT $0554 * index pair in C915, if so.
FORCE_NO_SYMBOL $0554
FORCE_NO_SYMBOL $0557
COMMENT_LINE $055B draw_line_between_2_points()
COMMENT_LINE $055B Draw a line between the 2 endpoints whose index are
COMMENT_LINE $055B pointed to by the 'u' registe.  These 2 indexes are then
COMMENT_LINE $055B then used to index into the vector list array.  While
COMMENT_LINE $055B drawing the line, check for a lightpen pick.
COMMENT_LINE $055B At entry:
COMMENT_LINE $055B 'u' points to the index pairs describing the
COMMENT_LINE $055B starting and ending points for this line.
COMMENT_LINE $055B The indexes are in the following format:
COMMENT_LINE $055B (ending pt index, starting pt index)
COMMENT_LINE $055B At exit:
COMMENT_LINE $055B 'a' = 0 => vector was not picked.
COMMENT_LINE $055B otherwise, the vector was picked.
FORCE_NO_SYMBOL $055B
COMMENT $055E * Load 'y' with coordinates for
FORCE_NO_SYMBOL $055E
COMMENT $0561 * line's endpoint.
FORCE_NO_SYMBOL $0563
COMMENT $0566 * Load 'x' with coordinates for
FORCE_NO_SYMBOL $0566
COMMENT $0569 * line's starting point.
FORCE_SYMBOL $056B draw_vector_with_pick_check
COMMENT_LINE $056F init_animate_variables()
COMMENT_LINE $056F This procedure initializes the block of memory
COMMENT_LINE $056F in the range C8A9-C90E to $FF.  It is called
COMMENT_LINE $056F when ANIMATE mode is first entered.  This block
COMMENT_LINE $056F of memory contains the line endpoint index pairs
COMMENT_LINE $056F for all visible lines.
FORCE_NO_SYMBOL $056F
FORCE_NO_SYMBOL $0572
FORCE_NO_SYMBOL $0576
COMMENT_LINE $057C add_a_new_line()
COMMENT_LINE $057C This routine adds the index pairs describing the
COMMENT_LINE $057C starting and ending points for a line, to the line
COMMENT_LINE $057C endpoint array, at C8A9-C90C.  If either of the
COMMENT_LINE $057C indexes is $FF, or if the indexes are the same, then
COMMENT_LINE $057C this point is not added to the array.  The indexes are
COMMENT_LINE $057C added to the next available location.
COMMENT_LINE $057C At entry:
COMMENT_LINE $057C a = ending point index
COMMENT_LINE $057C b = starting point index
FORCE_NO_SYMBOL $057C
COMMENT $057F * Don't bother, if array
FORCE_NO_SYMBOL $057F
COMMENT $0582 * is full.
COMMENT $0585 * Verify that this is a
COMMENT $0586 * valid set of endpoint
COMMENT $0588 * indexes.
COMMENT $0591 * See if spot is empty
FORCE_NO_SYMBOL $0591
FORCE_NO_SYMBOL $0595
COMMENT $0598 * Spot is taken, go onto
FORCE_NO_SYMBOL $0598
COMMENT $059A * next entry location.
COMMENT_LINE $059C play_handler()
COMMENT_LINE $059C This is the start of the PLAY command handler.
COMMENT_LINE $059C It will cause all currently defined ANIMATE
COMMENT_LINE $059C frames to be played in succession.
COMMENT $059C * See if the current frame's
FORCE_NO_SYMBOL $059C
COMMENT $059F * display duration has been
FORCE_NO_SYMBOL $059F
COMMENT $05A2 * reached.
COMMENT $05A4 * Reset duration counter, & goto
FORCE_NO_SYMBOL $05A4
COMMENT $05A7 * next frame.
FORCE_SYMBOL $05A7 get_ptrs_to_playback_frames
COMMENT $05AA * Display playback buf.
FORCE_SYMBOL $05AA fill_playback_buffer
FORCE_NO_SYMBOL $05AD
FORCE_NO_SYMBOL $05B0
FORCE_SYMBOL $05B3 intensity_to_7F
FORCE_SYMBOL $05B6 draw_all_visible_lines
FORCE_SYMBOL $05B9 draw_points_without_pick
COMMENT $05BC * Increment duration counter
FORCE_NO_SYMBOL $05BC
FORCE_SYMBOL $05BF check_playback_speed_buttons
FORCE_SYMBOL $05C2 reset0ref
COMMENT $05C5 * If button 1 or 2 is pressed,
FORCE_NO_SYMBOL $05C5
COMMENT $05C8 * then enter the EDIT portion
FORCE_NO_SYMBOL $05C8
COMMENT $05CA * of the ANIMATE code.
FORCE_SYMBOL $05CC edit_handler
FORCE_NO_SYMBOL $05CF
COMMENT_LINE $05D3 init_play_variables()
COMMENT_LINE $05D3 This routine is invoked when the user initiates
COMMENT_LINE $05D3 an animate 'PLAY' request.  It will initialize
COMMENT_LINE $05D3 some of the globals used by the PLAY routines.
COMMENT $05D3 * Clear frame duration counter.
FORCE_NO_SYMBOL $05D3
FORCE_NO_SYMBOL $05D6
COMMENT $05D8 * Set default playback speed.
FORCE_NO_SYMBOL $05D8
FORCE_SYMBOL $05DB update_playback_variables
COMMENT $05DE * Set up to display 1st frame.
FORCE_NO_SYMBOL $05DE
COMMENT $05E1 * Direction flag:0=>frwd,1=>bckwd
FORCE_NO_SYMBOL $05E1
FORCE_SYMBOL $05E4 get_ptrs_to_playback_frames
COMMENT_LINE $05E8 check_playback_speed_buttons()
COMMENT_LINE $05E8 This routine monitors buttons 3 (slow) and
COMMENT_LINE $05E8 4 (fast) during the PLAY mode portion of the
COMMENT_LINE $05E8 animate option.  The current playback speed is
COMMENT_LINE $05E8 kept in C929; 0 = fastest, 7 = slowest.
FORCE_NO_SYMBOL $05E8
FORCE_NO_SYMBOL $05ED
COMMENT_LINE $05F3 decrease_playback_speed()
COMMENT_LINE $05F3 Decrease the playback speed (by incrementing C929)
FORCE_NO_SYMBOL $05F3
FORCE_NO_SYMBOL $05F6
FORCE_NO_SYMBOL $05FB
FORCE_NO_SYMBOL $05FE
COMMENT $0601 * Increase duration counter for
COMMENT $0602 * this frame.
FORCE_NO_SYMBOL $0602
FORCE_SYMBOL $0605 update_playback_variables
COMMENT_LINE $0609 increase_playback_speed()
COMMENT_LINE $0609 Increase the playback speed (by decrementing C929)
FORCE_NO_SYMBOL $0609
FORCE_NO_SYMBOL $060F
FORCE_NO_SYMBOL $0612
COMMENT $0615 * Decrease duration counter
COMMENT $0616 * for this frame.
FORCE_NO_SYMBOL $0616
FORCE_SYMBOL $0619 update_playback_variables
COMMENT_LINE $061D update_playback_variables()
COMMENT_LINE $061D This routine uses the current playback speed, in C929,
COMMENT_LINE $061D to index into the structure at 0632 (playback_speed_info).
COMMENT_LINE $061D From this structure, two values are obtained: a 1 byte bit
COMMENT_LINE $061D pattern, and a two byte jump address.  These two
COMMENT_LINE $061D values are used by the playback routines.
FORCE_SYMBOL $061D playback_speed_info
FORCE_NO_SYMBOL $0620
FORCE_NO_SYMBOL $0623
FORCE_NO_SYMBOL $0629
FORCE_NO_SYMBOL $062E
COMMENT_LINE $0632 Table with the following format:
COMMENT_LINE $0632 1 byte value
COMMENT_LINE $0632 2 byte subroutine address.
COMMENT_LINE $0632 The information here is used during the PLAY
COMMENT_LINE $0632 mode of ANIMATE.  The playback speed (in C929)
COMMENT_LINE $0632 is used to index into this structure.  An index
COMMENT_LINE $0632 of 7 is for slowest playback, and an index of 0
COMMENT_LINE $0632 is for fastest playback.
COMMENT_LINE $064A get_ptrs_to_playback_frames()
COMMENT_LINE $064A This routine is used during the playback mode portion
COMMENT_LINE $064A of animate.  If loads C924 with a pointer to the
COMMENT_LINE $064A frame buffer for the current buffer, and C926 with a
COMMENT_LINE $064A a pointer to the frame buffer for the next buffer to
COMMENT_LINE $064A be displayed.  It will then increment the buffer index,
COMMENT_LINE $064A in C920.
COMMENT_LINE $064A At entry:
COMMENT_LINE $064A C920 contains the index of the current frame.
COMMENT_LINE $064A At exit:
COMMENT_LINE $064A C920 is incremented to index next frame.
COMMENT_LINE $064A C924 points to frame buffer for current frame.
COMMENT_LINE $064A C926 points to frame buffer for next frame.
COMMENT $064A * Load index of current frame.
FORCE_NO_SYMBOL $064A
FORCE_NO_SYMBOL $064D
FORCE_SYMBOL $0650 update_play_index_to_next_frame
FORCE_SYMBOL $0653 frame_buf_pointers
FORCE_NO_SYMBOL $0656
COMMENT $065A * Load C924 with ptr to frame buf
COMMENT $065C * for the current frame.
FORCE_NO_SYMBOL $065C
FORCE_NO_SYMBOL $065F
COMMENT $0663 * Load C926 with ptr to frame buf
COMMENT $0665 * for the next frame.
FORCE_NO_SYMBOL $0665
COMMENT_LINE $0669 This is an array of word pointers.  These point
COMMENT_LINE $0669 to the beginning of the buffer area associated
COMMENT_LINE $0669 with each of the animate frames.  Each frame is
COMMENT_LINE $0669 64 bytes long.
COMMENT_LINE $067F update_play_index_to_next_frame()
COMMENT_LINE $067F This routine updates the frame index (C920),
COMMENT_LINE $067F to index the next frame to be displayed.  If we
COMMENT_LINE $067F are currently displaying in the forward direction,
COMMENT_LINE $067F then this will be incremented.  If we are currently
COMMENT_LINE $067F displaying in the backward direction, then this will
COMMENT_LINE $067F be decremented.  If we reach the first/last frame,
COMMENT_LINE $067F then the direction will be changed.
COMMENT $067F * Check 4 frwd/bkwd display order.
FORCE_NO_SYMBOL $067F
COMMENT $0684 * Increment, if not at last frame.
FORCE_NO_SYMBOL $0684
FORCE_NO_SYMBOL $0687
FORCE_NO_SYMBOL $068C
COMMENT $0690 * Set direction flag to 'backwards'.
FORCE_NO_SYMBOL $0690
FORCE_NO_SYMBOL $0692
COMMENT $0695 * Decrement to previous frame.
FORCE_NO_SYMBOL $0695
COMMENT $0699 * Decrement, if not at first frame.
FORCE_NO_SYMBOL $0699
FORCE_NO_SYMBOL $069E
COMMENT $06A2 * Set direction flag to 'forwards'.
FORCE_NO_SYMBOL $06A2
COMMENT $06A5 * Increment to next frame.
FORCE_NO_SYMBOL $06A5
COMMENT_LINE $06A9 fill_playback_buffer()
COMMENT_LINE $06A9 This routine fills the playback buffer (C933-????)
COMMENT_LINE $06A9 with the (y,x) coordinate pairs for the currently
COMMENT_LINE $06A9 visible frame.  It does this by taking each coordinate
COMMENT_LINE $06A9 in the current frame, and the corresponding coordinate
COMMENT_LINE $06A9 in the next frame, and doing some sort of extrapolation
COMMENT_LINE $06A9 on them, to end up with the final endpoint.
COMMENT_LINE $06A9 At entry:
COMMENT_LINE $06A9 C924 points to frame buffer for current frame.
COMMENT_LINE $06A9 C926 points to frame buffer for next frame.
COMMENT_LINE $06A9 C933 is start of playback buffer.
COMMENT_LINE $06A9 C8A3 specifies number of defined points in a frame.
COMMENT $06A9 * Pointer to current frame.
FORCE_NO_SYMBOL $06A9
COMMENT $06AC * Ptr to next (transition) frame.
FORCE_NO_SYMBOL $06AC
COMMENT $06B0 * Addr of playback buffer.
FORCE_NO_SYMBOL $06B0
COMMENT $06B3 * # of points in frame buffer.
FORCE_NO_SYMBOL $06B3
FORCE_NO_SYMBOL $06B6
FORCE_NO_SYMBOL $06B9
COMMENT $06BE * Load both 'y' coordinates.
FORCE_NO_SYMBOL $06C2
FORCE_SYMBOL $06C5 merge_coordinates
COMMENT $06C8 * Save final 'y' coordinate.
COMMENT $06CA * Load both 'x' coordinates.
FORCE_NO_SYMBOL $06CE
FORCE_SYMBOL $06D1 merge_coordinates
COMMENT $06D4 * Save final 'x' coordinate.
FORCE_NO_SYMBOL $06D6
COMMENT_LINE $06DC merge_coordinates()
COMMENT_LINE $06DC This routine takes a pair of coordinates (2 'x' or
COMMENT_LINE $06DC 2 'y') and extrapolates a new value.  This new coordinate
COMMENT_LINE $06DC is what is displayed by the playback routine.
COMMENT_LINE $06DC At entry:
COMMENT_LINE $06DC C82E has coordinate for current frame.
COMMENT_LINE $06DC C82F has coordinate for next frame.
COMMENT_LINE $06DC At exit:
COMMENT_LINE $06DC 'b' contains modified coordinate.
COMMENT $06DC * Get coord for current frame.
FORCE_NO_SYMBOL $06DC
COMMENT $06E2 * Get coord for next frame.
FORCE_NO_SYMBOL $06E2
FORCE_NO_SYMBOL $06EB
FORCE_NO_SYMBOL $06EF
FORCE_NO_SYMBOL $06F5
FORCE_NO_SYMBOL $06FA
FORCE_NO_SYMBOL $0701
FORCE_NO_SYMBOL $0705
FORCE_NO_SYMBOL $070B
COMMENT_LINE $0721 search_screen_for_lightpen()
COMMENT_LINE $0721 This routine attempts to locate the location of the
COMMENT_LINE $0721 lightpen, by drawing a series of horizontal scan lines.
COMMENT_LINE $0721 Starting from the bottom of the display, a series of
COMMENT_LINE $0721 lines are drawn, until either a lightpen pick occurs,
COMMENT_LINE $0721 or the last scan line is drawn.  If a lightpen pick
COMMENT_LINE $0721 occurs, then that particular scan line will again be
COMMENT_LINE $0721 drawn, only this time, interrupts will be enabled, so
COMMENT_LINE $0721 that the exact location of the pick can be determined.
COMMENT_LINE $0721 At exit:
COMMENT_LINE $0721 'a' =    0 if lightpen was not located.
COMMENT_LINE $0721 'a' = $FF if lightpen was located.
COMMENT_LINE $0721 Work variables:
COMMENT_LINE $0721 C881 contains the number of scan lines left to draw.
COMMENT_LINE $0721 C882-C883 contain starting point for next scan line.
FORCE_NO_SYMBOL $0721
COMMENT $0723 * Init # of scan lines to draw
FORCE_NO_SYMBOL $0723
FORCE_NO_SYMBOL $0726
COMMENT $0729 * Init start pt for first scan line
FORCE_NO_SYMBOL $0729
FORCE_NO_SYMBOL $072C
FORCE_SYMBOL $0731 reset0ref
COMMENT $0734 * If we make it to here, then the
COMMENT $0735 * lightpen was not found.
FORCE_SYMBOL $0736 reset0ref
COMMENT $0739 * Move to start of scan line
FORCE_NO_SYMBOL $0739
FORCE_SYMBOL $073C move_pen7F_to_d
FORCE_NO_SYMBOL $073F
FORCE_NO_SYMBOL $0741
FORCE_NO_SYMBOL $0743
FORCE_NO_SYMBOL $0745
FORCE_NO_SYMBOL $0747
FORCE_NO_SYMBOL $0749
FORCE_NO_SYMBOL $074B
FORCE_NO_SYMBOL $074D
COMMENT $0750 * Use solid line pattern.
FORCE_NO_SYMBOL $0750
FORCE_NO_SYMBOL $0752
FORCE_NO_SYMBOL $0754
FORCE_NO_SYMBOL $0758
COMMENT $075A * Check for a lightpen pick
FORCE_NO_SYMBOL $075A
FORCE_NO_SYMBOL $075C
COMMENT $0760 * No lightpen pick, so continue
FORCE_NO_SYMBOL $0760
COMMENT $0763 * to draw the next scan line.
FORCE_NO_SYMBOL $0763
COMMENT $0766 * Draw on everyother horz line.
FORCE_NO_SYMBOL $0766
FORCE_NO_SYMBOL $0768
COMMENT_LINE $076D find_point_of_intersection()
COMMENT_LINE $076D This routine is responsible for locating the exact
COMMENT_LINE $076D location of the lightpen, after a pick has occurred
COMMENT_LINE $076D while a scan line was being drawn.  It does this in
COMMENT_LINE $076D the following manner:
COMMENT_LINE $076D The pen is moved back to the start of the previous
COMMENT_LINE $076D scan line, and lightpen interrupts are enabled.
COMMENT_LINE $076D Next, the scan line is redrawn; while this is going
COMMENT_LINE $076D on, a timing (counter) loop is executed.  If the
COMMENT_LINE $076D timing loop completes, then it implies that the
COMMENT_LINE $076D lightpen was not located; interrupts will be disabled,
COMMENT_LINE $076D and control will return to the procedure which had
COMMENT_LINE $076D originally invoked the scan line routine.
COMMENT_LINE $076D However, if the lightpen interrupts, then the timing
COMMENT_LINE $076D loop is interrupted, and the ISR handling routine is
COMMENT_LINE $076D called.  This handler will calculate the exact location
COMMENT_LINE $076D of the lightpen, using the value in the counter.  If
COMMENT_LINE $076D an interrupt occurs, control will never return to
COMMENT_LINE $076D this routine; control returns directly to the routine
COMMENT_LINE $076D which had invoked the scan line routine.  The location
COMMENT_LINE $076D of the 'pick' is returned in the 'x' register.
FORCE_SYMBOL $076D reset0ref
COMMENT $0770 * Move to start of scan line
FORCE_NO_SYMBOL $0770
FORCE_SYMBOL $0773 move_pen7F_to_d
COMMENT $0776 * Enable IRQ on 6809
FORCE_NO_SYMBOL $0776
COMMENT $0778 * Enable CA1 on PIA
FORCE_NO_SYMBOL $0778
FORCE_NO_SYMBOL $077A
COMMENT $077C * Set up IRQ handler
FORCE_NO_SYMBOL $077C
FORCE_NO_SYMBOL $077E
FORCE_SYMBOL $0781 ISR_handler
FORCE_NO_SYMBOL $0784
COMMENT $0787 * Redraw the scan line
FORCE_NO_SYMBOL $0787
FORCE_NO_SYMBOL $0789
FORCE_NO_SYMBOL $078B
FORCE_NO_SYMBOL $078E
FORCE_NO_SYMBOL $0790
FORCE_NO_SYMBOL $0792
FORCE_NO_SYMBOL $0794
FORCE_NO_SYMBOL $0796
FORCE_NO_SYMBOL $0798
FORCE_NO_SYMBOL $079A
FORCE_NO_SYMBOL $079C
COMMENT $079E * Wait for interrupt; counter loop
FORCE_NO_SYMBOL $07A3
FORCE_SYMBOL $07A5 disable_interrupts
COMMENT $07A8 * Lightpen not found
COMMENT_LINE $07AA disable_interrupts()
COMMENT_LINE $07AA This routine is responsible for disabling lightpen
COMMENT_LINE $07AA interrupts.
COMMENT $07AB * Disable CA1 on PIA
FORCE_NO_SYMBOL $07AB
FORCE_NO_SYMBOL $07AD
FORCE_NO_SYMBOL $07AF
COMMENT $07B1 * Disable IRQ on 6809
FORCE_NO_SYMBOL $07B1
FORCE_SYMBOL $07B3 reset0ref
COMMENT_LINE $07B7 process_ISR()
COMMENT_LINE $07B7 This procedure performs most of the work involved,
COMMENT_LINE $07B7 whenever the lightpen generates an interrupt.  It
COMMENT_LINE $07B7 uses the counter value, in the 'b' register, to
COMMENT_LINE $07B7 calculate the x coordinate of the lightpen.  The
COMMENT_LINE $07B7 intersection point is returned in the 'x' register.
COMMENT_LINE $07B7 This routine returns to the routine which invoked
COMMENT_LINE $07B7 the scan line search routine.
FORCE_NO_SYMBOL $07B7
FORCE_NO_SYMBOL $07B9
COMMENT $07BB * Calculate x coordinate
FORCE_NO_SYMBOL $07BB
FORCE_NO_SYMBOL $07C0
COMMENT $07C3 * Retrieve y coordinate
FORCE_NO_SYMBOL $07C3
FORCE_SYMBOL $07C8 disable_interrupts
COMMENT $07CB * Lightpen found
FORCE_NO_SYMBOL $07CB
COMMENT_LINE $07CE ISR_handler()
COMMENT_LINE $07CE This is the entry point called by the OS, whenever the
COMMENT_LINE $07CE lightpen generates an IRQ interrupt.  This procedure
COMMENT_LINE $07CE discards the 12 bytes of saved state information
COMMENT_LINE $07CE placed on the stack by the 6809, including the return
COMMENT_LINE $07CE address for the interrupted routine.  Then it calls the
COMMENT_LINE $07CE process_ISR() routine, to process the IRQ request.
FORCE_NO_SYMBOL $07CE
FORCE_NO_SYMBOL $07D0
FORCE_SYMBOL $07D2 process_ISR
COMMENT_LINE $07D6 draw_with_pick_check(vector_list, scale)
COMMENT_LINE $07D6 This procedure will perform a series of move and
COMMENT_LINE $07D6 draw requests, as specified in the passed in vector
COMMENT_LINE $07D6 list.  The vector list must have the following format:
COMMENT_LINE $07D6 mode, rel y, rel x
COMMENT_LINE $07D6 |      |       |
COMMENT_LINE $07D6 |      |       relative x position
COMMENT_LINE $07D6 |      relative y positon
COMMENT_LINE $07D6 FF - draw
COMMENT_LINE $07D6 0 - move
COMMENT_LINE $07D6 1 - end o list
COMMENT_LINE $07D6 NOTE: the mode also acts as the line pattern.
COMMENT_LINE $07D6 At entry: 'x' contains pointer to the vector list.
COMMENT_LINE $07D6 'b' contains the scale factor to be used.
COMMENT_LINE $07D6 At exit:  'a' contains the index of the point being
COMMENT_LINE $07D6 drawn when the lightpen detected a pick.
COMMENT_LINE $07D6 $FF if no pick occurred.
COMMENT $07D6 * Temporary storage of current pt #
FORCE_NO_SYMBOL $07D8
COMMENT $07DA * Temporary storage of last pt picked
FORCE_NO_SYMBOL $07DC
FORCE_NO_SYMBOL $07DE
COMMENT $07E0 * Set rel y position.
FORCE_NO_SYMBOL $07E0
FORCE_NO_SYMBOL $07E2
COMMENT $07E4 * Get the mode.
FORCE_NO_SYMBOL $07E4
COMMENT $07E6 * Increment ptr to next entry.
FORCE_NO_SYMBOL $07E6
FORCE_NO_SYMBOL $07E8
COMMENT $07EA * Set rel x position.
FORCE_NO_SYMBOL $07EA
COMMENT $07EC * Set line pattern.
FORCE_NO_SYMBOL $07EC
FORCE_NO_SYMBOL $07EE
FORCE_NO_SYMBOL $07F0
FORCE_NO_SYMBOL $07F3
FORCE_NO_SYMBOL $07F9
COMMENT $07FB * Check for a lightpen pick
FORCE_NO_SYMBOL $07FB
FORCE_NO_SYMBOL $07FD
COMMENT $0803 * Save the current pt #.
COMMENT $0805 * Increment the current pt #
FORCE_NO_SYMBOL $0807
COMMENT $080B * Return index if any pt picked.
COMMENT_LINE $080E This routine appears to not be used anywhere!!
FORCE_NO_SYMBOL $0812
FORCE_NO_SYMBOL $0814
FORCE_NO_SYMBOL $0816
FORCE_NO_SYMBOL $0818
FORCE_NO_SYMBOL $081A
FORCE_NO_SYMBOL $081C
FORCE_NO_SYMBOL $081E
FORCE_NO_SYMBOL $0820
FORCE_NO_SYMBOL $082A
FORCE_NO_SYMBOL $082C
FORCE_NO_SYMBOL $082E
FORCE_NO_SYMBOL $0831
FORCE_NO_SYMBOL $0837
FORCE_NO_SYMBOL $083B
COMMENT_LINE $0840 draw_vector_with_pick_check()
COMMENT_LINE $0840 This routine draws a vector, starting at (y,x) endpoint
COMMENT_LINE $0840 pointed to by the 'x' register, to the (y,x) endpoint
COMMENT_LINE $0840 pointed to by the 'y' register.  A value is returned
COMMENT_LINE $0840 which indicates whether or not a lightpen pick occurred
COMMENT_LINE $0840 while the vector was being drawn.
COMMENT_LINE $0840 At entry:
COMMENT_LINE $0840 'x' points to (y,x) pair for starting point.
COMMENT_LINE $0840 'y' points to (y,x) pair for ending point.
COMMENT_LINE $0840 At exit:
COMMENT_LINE $0840 'a' = 0 => no pick
COMMENT_LINE $0840 otherwise a pick occurred.
FORCE_SYMBOL $0840 reset0ref
FORCE_NO_SYMBOL $0843
FORCE_NO_SYMBOL $0845
FORCE_NO_SYMBOL $0848
FORCE_NO_SYMBOL $084A
COMMENT $084D * Move to starting point
FORCE_NO_SYMBOL $084D
FORCE_NO_SYMBOL $084F
FORCE_NO_SYMBOL $0851
FORCE_NO_SYMBOL $0853
FORCE_NO_SYMBOL $0855
FORCE_NO_SYMBOL $0857
FORCE_NO_SYMBOL $0859
FORCE_NO_SYMBOL $085B
FORCE_NO_SYMBOL $085D
FORCE_NO_SYMBOL $085F
FORCE_NO_SYMBOL $0861
FORCE_SYMBOL $0863 calculate_vector_endpoint
FORCE_SYMBOL $0866 am_scale_factors
FORCE_NO_SYMBOL $086B
FORCE_NO_SYMBOL $086D
FORCE_NO_SYMBOL $0871
FORCE_SYMBOL $0874 draw_with_pick_check
COMMENT_LINE $0879 calculate_vector_endpoint()
COMMENT_LINE $0879 This routine takes an absolute starting point, and an
COMMENT_LINE $0879 absolute ending point, and calculates the relative
COMMENT_LINE $0879 (y,x) pair for the vector between these two points.
COMMENT_LINE $0879 It also returns an index into the scale factor array,
COMMENT_LINE $0879 indicating which scale factor should be used when
COMMENT_LINE $0879 drawing the vector.
COMMENT_LINE $0879 At entry:
COMMENT_LINE $0879 'y' points to (y,x) endpoint.
COMMENT_LINE $0879 'x' points to (y,x) starting point.
COMMENT_LINE $0879 At exit:
COMMENT_LINE $0879 C881-C882 contain relative (y,x) endpoint.
COMMENT_LINE $0879 'b' contains the index of the scale factor to use.
COMMENT $0879 * Determine delta y.
FORCE_NO_SYMBOL $0879
FORCE_NO_SYMBOL $087B
COMMENT $0881 * Determine delta x.
FORCE_NO_SYMBOL $0881
FORCE_NO_SYMBOL $0883
FORCE_NO_SYMBOL $0889
FORCE_SYMBOL $088C get_absolute_value_of_ab
FORCE_NO_SYMBOL $0897
FORCE_NO_SYMBOL $089B
FORCE_NO_SYMBOL $089E
FORCE_NO_SYMBOL $08A2
FORCE_NO_SYMBOL $08A7
FORCE_NO_SYMBOL $08AA
FORCE_NO_SYMBOL $08AD
FORCE_NO_SYMBOL $08B4
FORCE_NO_SYMBOL $08B7
FORCE_NO_SYMBOL $08BA
FORCE_NO_SYMBOL $08BF
FORCE_NO_SYMBOL $08C6
FORCE_NO_SYMBOL $08CB
FORCE_NO_SYMBOL $08DC
FORCE_NO_SYMBOL $08E1
FORCE_NO_SYMBOL $08E4
COMMENT_LINE $08ED set_cursor_structure (cursor_ptr, data_ptr)
COMMENT_LINE $08ED This routine appears to copy the data pointer to
COMMENT_LINE $08ED by the 'x' register into the cursor structure, which
COMMENT_LINE $08ED is pointed to by the 'u' register.
COMMENT_LINE $08ED The cursor struct is 12 bytes long, and is laid out
COMMENT_LINE $08ED as follows:
COMMENT_LINE $08ED ************************
COMMENT_LINE $08ED * cursor rel y pos    *
COMMENT_LINE $08ED ************************
COMMENT_LINE $08ED * cursor rel x pos    *
COMMENT_LINE $08ED ************************
COMMENT_LINE $08ED * found this pass flag*
COMMENT_LINE $08ED ************************\
COMMENT_LINE $08ED * cursor y delta      * \
COMMENT_LINE $08ED ************************  > Used when moving cursor
COMMENT_LINE $08ED * cursor x delta      * /  to follow light pen
COMMENT_LINE $08ED ***********************
COMMENT_LINE $08ED * found last pass flag*
COMMENT_LINE $08ED ************************
COMMENT_LINE $08ED * max y position      *
COMMENT_LINE $08ED ************************
COMMENT_LINE $08ED * min x position      *
COMMENT_LINE $08ED ************************
COMMENT_LINE $08ED * min y position      *
COMMENT_LINE $08ED ************************
COMMENT_LINE $08ED * max x position      *
COMMENT_LINE $08ED ************************
COMMENT_LINE $08ED * ptr to line pattern *
COMMENT_LINE $08ED ** array used when   **
COMMENT_LINE $08ED * drawing search webs *
COMMENT_LINE $08ED ************************
FORCE_NO_SYMBOL $08EF
FORCE_NO_SYMBOL $08F3
FORCE_NO_SYMBOL $08F7
FORCE_SYMBOL $08F9 whole_search_pattern
FORCE_NO_SYMBOL $08FC
FORCE_NO_SYMBOL $08FE
COMMENT_LINE $0901 update_cursor_position()
COMMENT_LINE $0901 This routine attempts to move the cursor so that
COMMENT_LINE $0901 it 'stays' with  the lightpen.  First, it sees if
COMMENT_LINE $0901 the lightpen is still within 'sight' of the cursor.
COMMENT_LINE $0901 This is done by draw a series of 'spider web' patterns,
COMMENT_LINE $0901 until the lightpen is found, or the max web is drawn.
COMMENT_LINE $0901 Then it takes the deltas calculated by the search routine,
COMMENT_LINE $0901 adds them to the current cursor position, performs some
COMMENT_LINE $0901 bounds checks, and updates the line patterns used when
COMMENT_LINE $0901 drawing the search webs.
COMMENT $0901 * Try to find lightpen.
FORCE_SYMBOL $0901 find_lightpen
COMMENT $0904 * Proceed only if the lightpen
FORCE_NO_SYMBOL $0904
COMMENT $0906 * is currently at the cursor.
FORCE_NO_SYMBOL $0906
COMMENT $090A * Get y position, & extend to 16 bits
FORCE_NO_SYMBOL $090A
COMMENT $090F * Get new y delta
FORCE_NO_SYMBOL $090F
COMMENT $0912 * Add together
COMMENT $0916 * Compare new coordinate to max y
FORCE_NO_SYMBOL $0916
COMMENT $0918 * value.  Use max y value, if new
COMMENT $0919 * coordinate is too big.
FORCE_NO_SYMBOL $0919
FORCE_NO_SYMBOL $091E
FORCE_SYMBOL $0920 lower_search_pattern
COMMENT $0923 * Use lower search pattern
FORCE_NO_SYMBOL $0923
FORCE_NO_SYMBOL $0925
FORCE_NO_SYMBOL $0927
COMMENT $092B * Compare new coordinate to min y
FORCE_NO_SYMBOL $092B
COMMENT $092D * value.  Use min y value if new
COMMENT $092E * cordinate is too small.
FORCE_NO_SYMBOL $092E
FORCE_NO_SYMBOL $0933
FORCE_SYMBOL $0935 upper_search_pattern
COMMENT $0938 * Use upper search pattern
FORCE_NO_SYMBOL $0938
FORCE_NO_SYMBOL $093A
FORCE_NO_SYMBOL $093C
COMMENT $0940 * Save new y coordinate in the
COMMENT $0942 * cursor structure.
FORCE_NO_SYMBOL $0942
FORCE_SYMBOL $0944 whole_search_pattern
COMMENT $0947 * Use whole search pattern.
FORCE_NO_SYMBOL $0947
COMMENT $0949 * Load current x coordinate, and
FORCE_NO_SYMBOL $0949
COMMENT $094B * extend it to 16 bits.
FORCE_NO_SYMBOL $094E
COMMENT $0951 * Add the new x delta.
COMMENT $0955 * Compare new x coordinate to max x
FORCE_NO_SYMBOL $0955
COMMENT $0957 * value.  Use max value if new coord
COMMENT $0958 * is too big.
FORCE_NO_SYMBOL $0958
FORCE_NO_SYMBOL $095D
FORCE_SYMBOL $095F left_search_pattern
COMMENT $0962 * Use left search pattern
FORCE_NO_SYMBOL $0962
FORCE_NO_SYMBOL $0964
FORCE_NO_SYMBOL $0966
COMMENT $096A * Compare new coordinate to min x
FORCE_NO_SYMBOL $096A
COMMENT $096C * value.  Use min value, if new
COMMENT $096D * coordinate is too small.
FORCE_NO_SYMBOL $096D
FORCE_NO_SYMBOL $0972
FORCE_SYMBOL $0974 right_search_pattern
COMMENT $0977 * Use right search pattern
FORCE_NO_SYMBOL $0977
FORCE_NO_SYMBOL $0979
FORCE_NO_SYMBOL $097B
COMMENT $097F * Save new x coordinate
FORCE_NO_SYMBOL $0981
COMMENT_LINE $0984 find_lightpen()
COMMENT_LINE $0984 This routine is used by a portion of the animate code
COMMENT_LINE $0984 to locate the lightpen, so that the cursor may track
COMMENT_LINE $0984 it.  It does this in the following manner:
COMMENT_LINE $0984 Firstly, it moves to the last known location of
COMMENT_LINE $0984 the cursor, and draws a dot.  It a lightpen pick
COMMENT_LINE $0984 occurs, then no further searching is needed; the
COMMENT_LINE $0984 lightpen has not moved.  However, if the lightpen
COMMENT_LINE $0984 has moved, then we must perform a more extensive
COMMENT_LINE $0984 search.  However, if the lightpen was not found
COMMENT_LINE $0984 the last time we searched for it, then we won't
COMMENT_LINE $0984 bother searching for it now; we don't want to
COMMENT_LINE $0984 continually clutter the screen with our search
COMMENT_LINE $0984 patterns!
COMMENT_LINE $0984 Secondly, we will draw a series of ever increasing
COMMENT_LINE $0984 8 sided spider webs.  If, while drawing one of these
COMMENT_LINE $0984 search patterns, a lightpen pick is detected, then
COMMENT_LINE $0984 we will determine which vector of the pattern was
COMMENT_LINE $0984 picked, and we will calculate a cursor movement
COMMENT_LINE $0984 delta dependent upon the scale factor used and the
COMMENT_LINE $0984 vector picked.
COMMENT_LINE $0984 Depending upon the vector picked, the base delta
COMMENT_LINE $0984 value will be either -1, <<0, or +1.  This will then
COMMENT_LINE $0984 be multiplied by a scale value, which is obtained
COMMENT_LINE $0984 by using the scale factor index to index into a
COMMENT_LINE $0984 multiplier array.  The new deltas are saved in the
COMMENT_LINE $0984 cursor structure.
COMMENT $0984 * Clear "found this pass" flag
FORCE_NO_SYMBOL $0984
FORCE_SYMBOL $0986 intensity_to_7F
FORCE_SYMBOL $0989 reset0ref
COMMENT $098C * Move to last known location
FORCE_NO_SYMBOL $098C
FORCE_SYMBOL $098E move_pen7F_to_d
COMMENT $0991 * Draw a dot; check for pick
FORCE_SYMBOL $0991 dot_pattern
FORCE_NO_SYMBOL $0994
FORCE_SYMBOL $0996 draw_with_pick_check
COMMENT $099C * Lightpen was found
FORCE_NO_SYMBOL $099C
FORCE_NO_SYMBOL $099E
FORCE_NO_SYMBOL $09A0
COMMENT $09A3 * Don't bother searching if lightpen
FORCE_NO_SYMBOL $09A3
COMMENT $09A5 * wasn't found
COMMENT $09A7 * last pass.
COMMENT $09A8 * Draw the spider web, with an
FORCE_SYMBOL $09A8 reset0ref
COMMENT $09AB * increasing scale
FORCE_SYMBOL $09AB small_search_pattern_vl
COMMENT $09AE * factor, until either the light
FORCE_NO_SYMBOL $09AE
COMMENT $09B0 * pen is found, or the last scale
FORCE_NO_SYMBOL $09B0
COMMENT $09B2 * factor is reached.
FORCE_SYMBOL $09B4 large_search_pattern_vl
FORCE_NO_SYMBOL $09B7
FORCE_SYMBOL $09B9 move_pen7F_to_d
FORCE_SYMBOL $09BC search_pattern_scale_factors
FORCE_NO_SYMBOL $09C0
FORCE_SYMBOL $09C6 reset0ref
COMMENT $09C9 * Flag that cursor is 'lost'
FORCE_NO_SYMBOL $09C9
COMMENT $09CB * to the lightpen.
FORCE_NO_SYMBOL $09CB
COMMENT $09CE * Get line pattern array pointer
FORCE_NO_SYMBOL $09CE
FORCE_SYMBOL $09D1 display_search_pattern
COMMENT $09D4 * Check for a pick.
FORCE_NO_SYMBOL $09D4
COMMENT $09D8 * Increment the scale factor.
FORCE_NO_SYMBOL $09D8
FORCE_SYMBOL $09DC cursor_deltas
COMMENT $09DF * Decrement the index of the picked
COMMENT $09E0 * point, & convert to word index.
COMMENT $09E1 * Load x & y delta values, and save
COMMENT $09E3 * in the cursor structure.
FORCE_NO_SYMBOL $09E3
FORCE_SYMBOL $09E5 delta_multipliers
COMMENT $09E8 * Use the scale factor index to get
FORCE_NO_SYMBOL $09E8
COMMENT $09EA * the correct delta multiplier.
COMMENT $09EE * Generate new y delta.
FORCE_NO_SYMBOL $09EE
FORCE_SYMBOL $09F0 generate_new_cursor_coordinate
FORCE_NO_SYMBOL $09F3
COMMENT $09F7 *  Generate new x delta.
FORCE_NO_SYMBOL $09F7
FORCE_SYMBOL $09F9 generate_new_cursor_coordinate
FORCE_NO_SYMBOL $09FC
COMMENT $09FE * Flag that the cursor is picked
FORCE_NO_SYMBOL $09FE
FORCE_NO_SYMBOL $0A00
FORCE_NO_SYMBOL $0A02
COMMENT_LINE $0A05 generate_new_cursor_coordinate()
COMMENT_LINE $0A05 This routine calulates the new cursor delta,
COMMENT_LINE $0A05 by multiplying a delta value (-1, <<0, +1) by
COMMENT_LINE $0A05 a scale multiplier.
COMMENT_LINE $0A05 At entry:
COMMENT_LINE $0A05 'b' = coordinate delta.
COMMENT_LINE $0A05 'a' = scale multiplier.
COMMENT_LINE $0A13 display_search_pattern()
COMMENT_LINE $0A13 This routine draws the series of vectors, specified in
COMMENT_LINE $0A13 the structure pointed to by they 'x' register.  The 'y'
COMMENT_LINE $0A13 'y' register points to an array of line patterns
COMMENT_LINE $0A13 associated with each vector.  The scale factor to be used
COMMENT_LINE $0A13 is specified in 'b'.  A pattern of '1' terminates this
COMMENT_LINE $0A13 routine.  If a pick is detected, then the index of the
COMMENT_LINE $0A13 vector being drawn is returned in the 'a' register;
COMMENT_LINE $0A13 if no pick occurred, then $FF is returned.  This is used
COMMENT_LINE $0A13 when drawing the spider web search patterns.
COMMENT_LINE $0A13 At entry:
COMMENT_LINE $0A13 'b' = scale factor
COMMENT_LINE $0A13 'x' = vector list ptr (rel y, rel x)
COMMENT_LINE $0A13 'y' = line pattern array ptr
COMMENT_LINE $0A13 At exit:
COMMENT_LINE $0A13 'a' = $FF => no pick occurred.
COMMENT_LINE $0A13 otherwise, indicates which vector was picked.
FORCE_NO_SYMBOL $0A13
FORCE_NO_SYMBOL $0A15
COMMENT $0A18 * Keeps track of current vector index
FORCE_NO_SYMBOL $0A1A
COMMENT $0A1C * Keeps index of picked vector
FORCE_NO_SYMBOL $0A1E
FORCE_NO_SYMBOL $0A20
FORCE_NO_SYMBOL $0A22
FORCE_NO_SYMBOL $0A24
FORCE_NO_SYMBOL $0A26
FORCE_NO_SYMBOL $0A28
FORCE_NO_SYMBOL $0A2A
FORCE_NO_SYMBOL $0A2E
FORCE_NO_SYMBOL $0A30
FORCE_NO_SYMBOL $0A32
FORCE_NO_SYMBOL $0A35
FORCE_NO_SYMBOL $0A3B
COMMENT $0A3D * Check for a lightpen pick
FORCE_NO_SYMBOL $0A3D
FORCE_NO_SYMBOL $0A3F
COMMENT $0A45 * Save index of picked vector.
COMMENT $0A47 * Increment index.
FORCE_NO_SYMBOL $0A49
COMMENT $0A4D * Return index of picked vector.
COMMENT_LINE $0A54 The following 5 arrays contain the line patterns
COMMENT_LINE $0A54 used when drawing the spider web search pattern.
COMMENT_LINE $0A54 Depending upon which = of line patterns are used,
COMMENT_LINE $0A54 either the whole pattern, the left side, or right side,
COMMENT_LINE $0A54 or upper portion, or lower portion will be drawn.
COMMENT_LINE $0AAA These are (y,x) delta pairs, which are added
COMMENT_LINE $0AAA to the cursor position, to line the cursor up
COMMENT_LINE $0AAA with the lightpen.  The pair used depends upon
COMMENT_LINE $0AAA which vector of the search pattern was picked.
COMMENT_LINE $0ABA This is an array of multiplier values, used when
COMMENT_LINE $0ABA updating the cursors position so that is tracks
COMMENT_LINE $0ABA the lightpen.  The scale factor index used to
COMMENT_LINE $0ABA draw the search pattern is also used to index into
COMMENT_LINE $0ABA this byte array.  As the scale factor increases, so
COMMENT_LINE $0ABA does the multiplier value.
COMMENT_LINE $0AC4 This array contains the scale factors to be used
COMMENT_LINE $0AC4 when drawing the search patterns.
COMMENT_LINE $0ACF print_with_pick_check(string_ptr)
COMMENT_LINE $0ACF This procedure checks to see if a pick occurred
COMMENT_LINE $0ACF on the previous pass through the main loop (C81E != 0).
COMMENT_LINE $0ACF If a pick did not occur, then the passed in string
COMMENT_LINE $0ACF is displayed.  However, if a pick did occur on the
COMMENT_LINE $0ACF previous pass, then a check is made to see if this
COMMENT_LINE $0ACF is the string which was picked (the string address
COMMENT_LINE $0ACF is compared against that which was saved in C81C).
COMMENT_LINE $0ACF If this is not the string which was last picked, then
COMMENT_LINE $0ACF this string will not be displayed.  If this was the
COMMENT_LINE $0ACF string which was picked, then we will display it.
COMMENT_LINE $0ACF If we do display the string, then afterwards, we will
COMMENT_LINE $0ACF check to see if a pick occurred, and if so, then we
COMMENT_LINE $0ACF will hi-light the string, and save its address in C81C.
COMMENT_LINE $0ACF This routine is useful for display menus with multiple
COMMENT_LINE $0ACF choices.  When one choice is selected, the others will
COMMENT_LINE $0ACF not be displayed.  Once a string is no longer selected,
COMMENT_LINE $0ACF then all of the choices will once again be displayed.
COMMENT_LINE $0ACF At entry: 'u' must point to the string block.
FORCE_NO_SYMBOL $0ACF
FORCE_SYMBOL $0AD2 reset0ref
FORCE_NO_SYMBOL $0AD5
FORCE_NO_SYMBOL $0AD8
FORCE_NO_SYMBOL $0ADF
FORCE_SYMBOL $0AE4 am_print_string
FORCE_NO_SYMBOL $0AE7
COMMENT_LINE $0AED hilite_string()
COMMENT_LINE $0AED This routine is used by print_with_pick_check() to
COMMENT_LINE $0AED hi-lite a string once it is picked, and to = several
COMMENT_LINE $0AED globals, so that other routine will know a pick occurred.
COMMENT_LINE $0AED The address of the string block is in C880.  A copy of
COMMENT_LINE $0AED this address will then be saved in C81C, and C89E and
COMMENT_LINE $0AED C81B will be = to one (to flag that a pick occurred).
FORCE_NO_SYMBOL $0AED
FORCE_NO_SYMBOL $0AF0
FORCE_NO_SYMBOL $0AF3
FORCE_SYMBOL $0AF6 am_print_string
FORCE_NO_SYMBOL $0AF9
FORCE_SYMBOL $0AFC am_print_string
FORCE_NO_SYMBOL $0AFF
FORCE_SYMBOL $0B02 am_print_string
FORCE_NO_SYMBOL $0B05
FORCE_SYMBOL $0B08 am_print_string
FORCE_NO_SYMBOL $0B0B
FORCE_NO_SYMBOL $0B0D
FORCE_NO_SYMBOL $0B10
FORCE_NO_SYMBOL $0B13
COMMENT_LINE $0B19 am_print_string()
COMMENT_LINE $0B19 Prints a string of character, terminated by $80.
COMMENT_LINE $0B19 At entry, the 'u' register must point to a block
COMMENT_LINE $0B19 having the following format:
COMMENT_LINE $0B19 1 byte height of string
COMMENT_LINE $0B19 1 byte width of string
COMMENT_LINE $0B19 1 byte rel y location
COMMENT_LINE $0B19 1 byte rel x location
COMMENT_LINE $0B19 2 byte pointer to start of string
COMMENT_LINE $0B19 At exit: C89E will be = if a pick occurred.
FORCE_NO_SYMBOL $0B1B
FORCE_SYMBOL $0B20 move_pen7F_to_d
FORCE_NO_SYMBOL $0B23
FORCE_NO_SYMBOL $0B25
FORCE_NO_SYMBOL $0B2A
FORCE_NO_SYMBOL $0B2D
FORCE_NO_SYMBOL $0B2F
FORCE_NO_SYMBOL $0B32
FORCE_NO_SYMBOL $0B35
FORCE_NO_SYMBOL $0B38
FORCE_NO_SYMBOL $0B3A
FORCE_NO_SYMBOL $0B3C
FORCE_NO_SYMBOL $0B3E
FORCE_NO_SYMBOL $0B40
FORCE_NO_SYMBOL $0B44
FORCE_NO_SYMBOL $0B46
FORCE_NO_SYMBOL $0B48
FORCE_NO_SYMBOL $0B4A
FORCE_NO_SYMBOL $0B4D
FORCE_NO_SYMBOL $0B4F
FORCE_NO_SYMBOL $0B52
FORCE_NO_SYMBOL $0B54
FORCE_NO_SYMBOL $0B57
FORCE_NO_SYMBOL $0B5A
FORCE_NO_SYMBOL $0B60
COMMENT $0B66 * Record any picks.
FORCE_NO_SYMBOL $0B66
FORCE_NO_SYMBOL $0B68
FORCE_NO_SYMBOL $0B6A
FORCE_NO_SYMBOL $0B6D
FORCE_NO_SYMBOL $0B71
FORCE_NO_SYMBOL $0B73
FORCE_NO_SYMBOL $0B75
FORCE_NO_SYMBOL $0B77
FORCE_NO_SYMBOL $0B79
FORCE_NO_SYMBOL $0B7B
FORCE_NO_SYMBOL $0B80
FORCE_NO_SYMBOL $0B85
FORCE_NO_SYMBOL $0B88
FORCE_NO_SYMBOL $0B8D
FORCE_NO_SYMBOL $0B93
FORCE_NO_SYMBOL $0B95
FORCE_NO_SYMBOL $0B98
FORCE_NO_SYMBOL $0B9A
FORCE_NO_SYMBOL $0B9C
FORCE_NO_SYMBOL $0BA0
FORCE_NO_SYMBOL $0BA2
FORCE_NO_SYMBOL $0BA4
FORCE_NO_SYMBOL $0BA6
FORCE_NO_SYMBOL $0BA8
FORCE_SYMBOL $0BAA P0B3C
FORCE_NO_SYMBOL $0BAD
FORCE_NO_SYMBOL $0BAF
FORCE_SYMBOL $0BB1 reset0ref
COMMENT_LINE $0BC9 This describes the initial cursor state.
COMMENT_LINE $0BCF start_of_sketch_connect()
COMMENT_LINE $0BCF This is the starting point for the SKETCH and
COMMENT_LINE $0BCF the CONNECT main menu items.
FORCE_SYMBOL $0BCF init_sketch_connect_variables
FORCE_NO_SYMBOL $0BD2
FORCE_SYMBOL $0BD5 initial_cursor_state
FORCE_SYMBOL $0BD8 set_cursor_structure
FORCE_SYMBOL $0BDB sketch_connect_handler
FORCE_NO_SYMBOL $0BDE
COMMENT_LINE $0BE1 sketch_connect_handler()
COMMENT_LINE $0BE1 This is the real main loop routine for the sketch
COMMENT_LINE $0BE1 and connect operatons.  It takes care of reading
COMMENT_LINE $0BE1 the buttons, and calling any button handlers, as
COMMENT_LINE $0BE1 needed.  It is invoked only through the indirect
COMMENT_LINE $0BE1 jump location, by the main loop.
FORCE_NO_SYMBOL $0BE1
COMMENT $0BE4 * Check button 4, iff in connect mode
FORCE_NO_SYMBOL $0BE4
COMMENT $0BE9 * Check button 4;(dot/lines)
FORCE_NO_SYMBOL $0BE9
COMMENT $0BEE * Complement dot/connect flag
FORCE_NO_SYMBOL $0BEE
FORCE_SYMBOL $0BF1 display_sc_menu
FORCE_SYMBOL $0BF4 sketch_connect_draw_vector_list
FORCE_SYMBOL $0BF7 fan_handler
COMMENT $0BFA * Check button 1;(draw)
FORCE_NO_SYMBOL $0BFA
COMMENT $0BFF * Check button 4, iff in sketch mode
FORCE_NO_SYMBOL $0BFF
COMMENT $0C04 * Check button 4;(fan)
FORCE_NO_SYMBOL $0C04
COMMENT $0C09 * Check button 2;(rubber band line)
FORCE_NO_SYMBOL $0C09
COMMENT_LINE $0C0F sc_start_draw()
COMMENT_LINE $0C0F sc_start_fan()
COMMENT_LINE $0C0F These two entry points are responsible for initializing
COMMENT_LINE $0C0F things when either button 1 (draw) or button 4 (fan)
COMMENT_LINE $0C0F are pressed during SKETCH or CONNECT modes.  They will
COMMENT_LINE $0C0F = up a new indirect jump handler, save the current
COMMENT_LINE $0C0F cursor position, and initialize some variables.
FORCE_SYMBOL $0C0F sc_draw_handler
COMMENT $0C12 * Don't bother, if the vector
FORCE_NO_SYMBOL $0C12
COMMENT $0C15 * list is already full.
FORCE_NO_SYMBOL $0C15
COMMENT $0C1A * Save new indirect jump handler.
FORCE_NO_SYMBOL $0C1A
FORCE_NO_SYMBOL $0C1D
COMMENT $0C1F * Load 'x' with pointer to next
FORCE_NO_SYMBOL $0C1F
COMMENT $0C22 * free spot in the vector list
COMMENT $0C23 * buffer.
FORCE_NO_SYMBOL $0C25
COMMENT $0C27 * Fill this spot, using the current
FORCE_NO_SYMBOL $0C27
COMMENT $0C2A * cursor position.
FORCE_NO_SYMBOL $0C2A
COMMENT $0C2C * Increment the vector counter.
FORCE_NO_SYMBOL $0C2C
COMMENT $0C2F * # of pts to draw relative 2 starting
FORCE_NO_SYMBOL $0C2F
COMMENT $0C31 * pt, be4 forcing new absolute ref pt.
FORCE_NO_SYMBOL $0C31
COMMENT $0C34 * Save current cursor position.
FORCE_NO_SYMBOL $0C34
FORCE_NO_SYMBOL $0C37
FORCE_NO_SYMBOL $0C3A
FORCE_NO_SYMBOL $0C3D
COMMENT $0C3F * Stores reset value for counter.
FORCE_NO_SYMBOL $0C3F
COMMENT $0C42 * Active counter; endpoint is fixed
FORCE_NO_SYMBOL $0C42
COMMENT $0C45 * when this goes to 0.
COMMENT_LINE $0C46 sc_start_rubber_band_line()
COMMENT_LINE $0C46 This entry point is responsible for setting up the
COMMENT_LINE $0C46 indirect jump location, and initializing variables
COMMENT_LINE $0C46 when button 2 (rubber band line) is pressed during
COMMENT_LINE $0C46 either SKETCH or CONNECT mode.
COMMENT $0C46 * Save current cursor position.
FORCE_NO_SYMBOL $0C46
FORCE_NO_SYMBOL $0C49
FORCE_SYMBOL $0C4C rubber_band_line_handler
COMMENT $0C4F * Don't bother if the vector list
FORCE_NO_SYMBOL $0C4F
COMMENT $0C52 * is already full.
FORCE_NO_SYMBOL $0C52
COMMENT $0C57 * Save new indirect jump handler.
FORCE_NO_SYMBOL $0C57
COMMENT_LINE $0C5B sc_draw_handler()
COMMENT_LINE $0C5B This is the routine which draws lines/dots when
COMMENT_LINE $0C5B button 1 is depressed.  It is invoked only through
COMMENT_LINE $0C5B the indirect jump location.  It is used only when
COMMENT_LINE $0C5B either SKETCH or CONNECT modes are active.
FORCE_SYMBOL $0C5B display_sc_menu
FORCE_SYMBOL $0C5E sketch_connect_draw_vector_list
COMMENT $0C61 * Check if button 1 is still pressed.
FORCE_NO_SYMBOL $0C61
FORCE_NO_SYMBOL $0C64
FORCE_SYMBOL $0C68 get_new_endpoint
FORCE_SYMBOL $0C6B sketch_connect_handler
FORCE_NO_SYMBOL $0C6E
COMMENT $0C72 * Don't continue, if the cursor has
FORCE_NO_SYMBOL $0C72
COMMENT $0C75 * not moved since last point.
FORCE_NO_SYMBOL $0C75
COMMENT $0C7C * Wait for counter (C895) to decrement
FORCE_NO_SYMBOL $0C7C
COMMENT $0C7F * to zero, before fixing endpoint.
FORCE_NO_SYMBOL $0C81
FORCE_SYMBOL $0C85 get_new_endpoint
COMMENT $0C88 * Move the starting point for next
FORCE_NO_SYMBOL $0C88
COMMENT $0C8B * vector to previous vectors endpt.
FORCE_NO_SYMBOL $0C8B
FORCE_NO_SYMBOL $0C8E
COMMENT $0C91 * Reset 'fix endpoint' counter.
FORCE_NO_SYMBOL $0C91
COMMENT_LINE $0C95 fan_handler()
COMMENT_LINE $0C95 As long as the user has button 4 pressed, a fan
COMMENT_LINE $0C95 pattern will be drawn.  Once button 4 is released,
COMMENT_LINE $0C95 control will return to the sketch/connect handler.
COMMENT $0C95 * Flag that 'fan' is being done.
FORCE_NO_SYMBOL $0C95
FORCE_NO_SYMBOL $0C97
FORCE_NO_SYMBOL $0C9A
FORCE_SYMBOL $0C9D display_sc_menu
FORCE_SYMBOL $0CA0 sketch_connect_draw_vector_list
COMMENT $0CA3 * Check if button 4 is still pressed
FORCE_NO_SYMBOL $0CA3
FORCE_NO_SYMBOL $0CA6
FORCE_SYMBOL $0CAA get_new_endpoint
FORCE_SYMBOL $0CAD sketch_connect_handler
FORCE_NO_SYMBOL $0CB0
FORCE_NO_SYMBOL $0CB3
COMMENT $0CB7 * Don't add a new line, unless
FORCE_NO_SYMBOL $0CB7
COMMENT $0CBA * the cursor position has changed.
FORCE_NO_SYMBOL $0CBA
COMMENT $0CC1 * Don't fix next fan endpt, until
FORCE_NO_SYMBOL $0CC1
COMMENT $0CC4 * 'fix point' counter has decremented
COMMENT $0CC6 * to zero.
FORCE_NO_SYMBOL $0CC6
FORCE_SYMBOL $0CCA get_new_endpoint
COMMENT $0CCD * Set starting point for next vector
FORCE_NO_SYMBOL $0CCD
COMMENT $0CD0 * equal to last vectors endpoint.
FORCE_NO_SYMBOL $0CD0
FORCE_NO_SYMBOL $0CD3
COMMENT $0CD6 * Reset 'fix endpoint' counter.
FORCE_NO_SYMBOL $0CD6
COMMENT_LINE $0CDA rubber_band_line_handler()
COMMENT_LINE $0CDA This is the handler routine while the user is
COMMENT_LINE $0CDA drawing a rubber band line during sketch or connect
COMMENT_LINE $0CDA modes.  The rubber band line will continue until the
COMMENT_LINE $0CDA user stops pressing button 2.  This routine is only
COMMENT_LINE $0CDA invoked through the indirect jump location.
FORCE_SYMBOL $0CDA display_sc_menu
FORCE_SYMBOL $0CDD sketch_connect_draw_vector_list
COMMENT $0CE0 * See if button 2 still depressed
FORCE_NO_SYMBOL $0CE0
FORCE_NO_SYMBOL $0CE3
COMMENT $0CE7 * Clear the relative point counter.
FORCE_NO_SYMBOL $0CE7
FORCE_SYMBOL $0CEA get_new_endpoint
FORCE_SYMBOL $0CED sketch_connect_handler
FORCE_NO_SYMBOL $0CF0
COMMENT $0CF4 * Draw the rubber band line from the
FORCE_NO_SYMBOL $0CF4
COMMENT $0CF7 * originat point to the current cursor
COMMENT $0CF9 * position, unless in DOT mode.
FORCE_NO_SYMBOL $0CF9
FORCE_SYMBOL $0CFE intensity_to_7F
FORCE_NO_SYMBOL $0D01
FORCE_NO_SYMBOL $0D04
FORCE_SYMBOL $0D08 draw_vector_with_pick_check
COMMENT_LINE $0D27 display_sc_menu()
COMMENT_LINE $0D27 This procedure displays either the SKETCH or CONNECT
COMMENT_LINE $0D27 header (as an unpickable string), and then also displays
COMMENT_LINE $0D27 the ERASE, MENU and DOT/LINE sub-items (as pickable strings)
COMMENT_LINE $0D27 It then checks to see if any of these items were picked,
COMMENT_LINE $0D27 and handles them is they were. Also displays the cursor.
FORCE_SYMBOL $0D27 intensity_to_7F
FORCE_SYMBOL $0D2A reset0ref
COMMENT $0D2D * See if in sketch or connect mode
FORCE_NO_SYMBOL $0D2D
COMMENT $0D32 * CONNECT mode
FORCE_SYMBOL $0D32 HDR_CONNECT_STR
FORCE_SYMBOL $0D35 am_print_string
COMMENT $0D38 * Display DOT or LINE item
FORCE_SYMBOL $0D38 SM_DOT_STR
FORCE_NO_SYMBOL $0D3B
FORCE_SYMBOL $0D40 SM_LINE_STR
FORCE_SYMBOL $0D43 am_print_string
COMMENT $0D48 * SKETCH mode
FORCE_SYMBOL $0D48 HDR_SKETCH_STR
FORCE_SYMBOL $0D4B am_print_string
COMMENT $0D4E * Draw cursor at current
FORCE_NO_SYMBOL $0D4E
COMMENT $0D50 * position.
FORCE_SYMBOL $0D50 intensity_to_a
FORCE_NO_SYMBOL $0D53
FORCE_SYMBOL $0D56 am_move_to_d
FORCE_SYMBOL $0D59 cross
FORCE_NO_SYMBOL $0D5C
FORCE_SYMBOL $0D5E draw_with_pick_check
FORCE_SYMBOL $0D61 intensity_to_7F
COMMENT $0D64 * If cursor is picked, then
FORCE_NO_SYMBOL $0D64
COMMENT $0D67 * draw it brighter.
FORCE_NO_SYMBOL $0D67
FORCE_SYMBOL $0D6B reset0ref
FORCE_NO_SYMBOL $0D6E
FORCE_SYMBOL $0D71 am_move_to_d
FORCE_NO_SYMBOL $0D74
FORCE_SYMBOL $0D76 cross
FORCE_SYMBOL $0D79 draw_with_pick_check
FORCE_SYMBOL $0D7C update_cursor_position
COMMENT $0D7F * Print ERASE item
FORCE_SYMBOL $0D7F SM_ERASE_STR
FORCE_SYMBOL $0D82 print_with_pick_check
COMMENT $0D85 * Check if button 3
FORCE_NO_SYMBOL $0D85
COMMENT $0D88 * is pressed and item is
FORCE_NO_SYMBOL $0D88
COMMENT $0D8A * picked.
FORCE_NO_SYMBOL $0D8C
FORCE_SYMBOL $0D91 start_of_sketch_connect
FORCE_NO_SYMBOL $0D94
COMMENT $0D98 * Print MENU item
FORCE_SYMBOL $0D98 SM_MENU_STR
FORCE_SYMBOL $0D9B print_with_pick_check
COMMENT $0D9E * Check if button 3 is
FORCE_NO_SYMBOL $0D9E
COMMENT $0DA1 * pressed and item is picked
FORCE_NO_SYMBOL $0DA1
FORCE_NO_SYMBOL $0DA5
FORCE_SYMBOL $0DAA display_main_menu
FORCE_NO_SYMBOL $0DAD
COMMENT $0DB1 * "9"
COMMENT_LINE $0DB2 gen_vec_endpoint_recal ;generate_vector_endpoint_and_recalibrate()
COMMENT_LINE $0DB2 This routine generates an endpoint for a vector.
COMMENT_LINE $0DB2 If the relative point counter (C8A4) has decremented
COMMENT_LINE $0DB2 to zero, then we will add an absolute reference point
COMMENT_LINE $0DB2 to the vector list, to prevent our vectors from getting
COMMENT_LINE $0DB2 too far out of whack; this is done after every 5 points.
COMMENT_LINE $0DB2 At entry:
COMMENT_LINE $0DB2 C8A4 contains the relative point counter.
COMMENT_LINE $0DB2 'a' has index of next available spot in vector list.
COMMENT_LINE $0DB2 C89B contains starting point for this vector.
COMMENT_LINE $0DB2 C82F contains starting point for the fan.
COMMENT_LINE $0DB2 C82E flags DRAW .vs. FAN mode.
COMMENT_LINE $0DB2 C8A3 has index of next available spot in vector list.
COMMENT_LINE $0DB2 At exit:
COMMENT_LINE $0DB2 C881-C882 contains new vector endpoint.
COMMENT_LINE $0DB2 'u' points to next available spot in vector list.
COMMENT $0DB2 * If the relative pt counter has gone
FORCE_NO_SYMBOL $0DB2
COMMENT $0DB5 * to zero, then force another absolute
COMMENT $0DB7 * ref point.
FORCE_NO_SYMBOL $0DB7
FORCE_NO_SYMBOL $0DB9
COMMENT $0DBF * Flag an absolute reference point.
FORCE_NO_SYMBOL $0DBF
COMMENT $0DC1 * Get starting pt for this vector; if
FORCE_NO_SYMBOL $0DC1
COMMENT $0DC4 * DRAW mode, then use last cursor
FORCE_NO_SYMBOL $0DC4
COMMENT $0DC7 * position; else, use cursor position
COMMENT $0DC9 * for beginning of fan.
FORCE_NO_SYMBOL $0DC9
COMMENT $0DCC * Save abs ref point.
FORCE_NO_SYMBOL $0DCC
COMMENT $0DCE * Increment vector counter.
FORCE_NO_SYMBOL $0DCE
COMMENT $0DD1 * Reset the relative point counter.
FORCE_NO_SYMBOL $0DD1
FORCE_NO_SYMBOL $0DD3
FORCE_NO_SYMBOL $0DD6
COMMENT $0DD9 * Load 'u' with pointer to current
FORCE_NO_SYMBOL $0DD9
COMMENT $0DDC * work spot in the vector list.
FORCE_NO_SYMBOL $0DDC
COMMENT $0DE1 * Calculate endpt for this vector.
FORCE_NO_SYMBOL $0DE1
FORCE_NO_SYMBOL $0DE4
FORCE_NO_SYMBOL $0DE8
FORCE_NO_SYMBOL $0DED
FORCE_SYMBOL $0DF0 calculate_vector_endpoint
COMMENT $0DF3 * Increment vector list counter.
FORCE_NO_SYMBOL $0DF3
COMMENT $0DF6 * Decrement relative point counter.
FORCE_NO_SYMBOL $0DF6
COMMENT_LINE $0DFA get_new_endpoint()
COMMENT_LINE $0DFA This routine checks to see how many vectors or dots
COMMENT_LINE $0DFA we have available for use.  The current number of
COMMENT_LINE $0DFA vectors or dots drawn is stored in C8A3.  If we
COMMENT_LINE $0DFA have already reached the limit, then return without
COMMENT_LINE $0DFA doing anything.  Otherwise, if we are close to the
COMMENT_LINE $0DFA limit, then make a sound, and flag that we are close,
COMMENT_LINE $0DFA by setting C829; this flag will prevent us from making
COMMENT_LINE $0DFA the sound more than once.  Also, it will generate the
COMMENT_LINE $0DFA scale factor and coordinates for the current vector.
COMMENT_LINE $0DFA These pieces of information are then stored in the
COMMENT_LINE $0DFA vector list.
COMMENT $0DFA * See if we have surpassed limit
FORCE_NO_SYMBOL $0DFA
FORCE_NO_SYMBOL $0DFD
COMMENT $0E02 * Don't make sound more than once
FORCE_NO_SYMBOL $0E02
COMMENT $0E07 * See if we're near limit
FORCE_NO_SYMBOL $0E07
FORCE_NO_SYMBOL $0E0B
FORCE_SYMBOL $0E0E set_up_a_misc_sound1
FORCE_NO_SYMBOL $0E11
COMMENT $0E14 generate_vector_endpoint_and_recalibrate;
FORCE_SYMBOL $0E14 gen_vec_endpoint_recal
COMMENT $0E17 * Save scale factor.
FORCE_NO_SYMBOL $0E17
FORCE_NO_SYMBOL $0E19
COMMENT $0E1C * Save vector endpoints.
FORCE_NO_SYMBOL $0E1C
COMMENT_LINE $0E1F init_sketch_connect_variables()
COMMENT_LINE $0E1F This routine is invoked when the sketch/connect
COMMENT_LINE $0E1F handler is first called.  It is responsible for
COMMENT_LINE $0E1F initializing the vector list residing in RAM at
COMMENT_LINE $0E1F C8A9-CBA5 to $FF.  It also initializes some RAM
COMMENT_LINE $0E1F locations to 0.
FORCE_NO_SYMBOL $0E1F
FORCE_NO_SYMBOL $0E22
FORCE_NO_SYMBOL $0E26
COMMENT $0E2B * Vector counter.
FORCE_NO_SYMBOL $0E2B
COMMENT $0E2E * Relative point counter.
FORCE_NO_SYMBOL $0E2E
COMMENT $0E31 * Buffer almost full flag.
FORCE_NO_SYMBOL $0E31
COMMENT $0E34 * Sound duration.
FORCE_NO_SYMBOL $0E34
COMMENT_LINE $0E38 sketch_connect_draw_vector_list()
COMMENT_LINE $0E38 This routine goes through the vector list, performing
COMMENT_LINE $0E38 all of the move and draw requests currently therein.
COMMENT_LINE $0E38 It does this by drawing all of the points relative to
COMMENT_LINE $0E38 to the last absolute reference point, until a new
COMMENT_LINE $0E38 absolute reference point is encountered.  At this point
COMMENT_LINE $0E38 it will recalibrate things, and then move to the new
COMMENT_LINE $0E38 absolute reference point, and continue drawing.  This
COMMENT_LINE $0E38 will continue until the end of the vector list is
COMMENT_LINE $0E38 encountered.  The vector list has the following format:
COMMENT_LINE $0E38 scale, rel y, rel x
COMMENT_LINE $0E38 If 'scale' is $FF, then this is the end of the list.
COMMENT_LINE $0E38 If 'scale' is $00, then the corresponding (y,x) are
COMMENT_LINE $0E38 really a new absolute reference point, not relative
COMMENT_LINE $0E38 points.
COMMENT_LINE $0E38 If 'scale' is positive, then draw to new point.
COMMENT_LINE $0E38 If 'scale' is negative, then move to new point.
COMMENT $0E38 * Set up vector intensity.
FORCE_NO_SYMBOL $0E38
FORCE_SYMBOL $0E3A intensity_to_a
COMMENT $0E3D * Start drawing vector list.
FORCE_NO_SYMBOL $0E3D
FORCE_SYMBOL $0E40 draw_relative_points
FORCE_SYMBOL $0E46 reset0ref
COMMENT $0E4A * Reset zero reference.
FORCE_SYMBOL $0E4A reset0ref
COMMENT $0E4D * Move to abs ref point.
FORCE_SYMBOL $0E4F am_move_to_d
COMMENT_LINE $0E54 draw_relative_points()
COMMENT_LINE $0E54 This routine draw all of the vector in the vector
COMMENT_LINE $0E54 list, which are relative to the current absolute
COMMENT_LINE $0E54 reference point.  When the end of the vector list
COMMENT_LINE $0E54 or a new absolute reference point is encountered,
COMMENT_LINE $0E54 this routine will return.
COMMENT_LINE $0E54 At entry:
COMMENT_LINE $0E54 'x' points to the vector list.
COMMENT_LINE $0E54 At exit:
COMMENT_LINE $0E54 'a' contains scale factor for terminating point.
COMMENT $0E54 * Load scale factor; return if it
COMMENT $0E56 * flags a new abs reference point.
COMMENT $0E59 * Check 4 the end of the vector list.
FORCE_NO_SYMBOL $0E59
COMMENT $0E5E * Check for LINE or DOT mode.
FORCE_NO_SYMBOL $0E5E
FORCE_NO_SYMBOL $0E63
COMMENT $0E68 * Check for move/draw operation.
FORCE_NO_SYMBOL $0E6B
FORCE_NO_SYMBOL $0E6D
FORCE_SYMBOL $0E70 am_draw_with_pattern
FORCE_NO_SYMBOL $0E75
FORCE_NO_SYMBOL $0E7B
FORCE_NO_SYMBOL $0E7D
COMMENT $0E7F * Clear vector pattern.
FORCE_NO_SYMBOL $0E7F
FORCE_SYMBOL $0E82 am_draw_with_pattern
FORCE_NO_SYMBOL $0E85
FORCE_NO_SYMBOL $0E8B
COMMENT_LINE $0E8F am_draw_with_pattern (point, scale_index, pattern)
COMMENT_LINE $0E8F This moves the cursor to a particular point,
COMMENT_LINE $0E8F using one of several scale factors, and a line
COMMENT_LINE $0E8F pattern specified in C880.
COMMENT_LINE $0E8F At entry:   'x' points to vector list of rel y, relx.
COMMENT_LINE $0E8F 'a' has index into scale factor array.
COMMENT_LINE $0E8F C880 has line pattern.
FORCE_SYMBOL $0E8F am_scale_factors
COMMENT $0E92 * Load the scale factor
FORCE_NO_SYMBOL $0E94
COMMENT $0E96 * Load vector endpoints
FORCE_NO_SYMBOL $0E98
FORCE_NO_SYMBOL $0E9A
COMMENT $0E9C * Load line pattern from C880
FORCE_NO_SYMBOL $0E9C
FORCE_NO_SYMBOL $0E9F
FORCE_NO_SYMBOL $0EA1
FORCE_NO_SYMBOL $0EA3
FORCE_NO_SYMBOL $0EA5
FORCE_NO_SYMBOL $0EA7
FORCE_NO_SYMBOL $0EA9
COMMENT $0EAF * Clear the line pattern
FORCE_NO_SYMBOL $0EAF
COMMENT_LINE $0EB2 am_move_to_d()
COMMENT_LINE $0EB2 This routine does a quick move to the point
COMMENT_LINE $0EB2 specified in the 'd' register (a = rel y,
COMMENT_LINE $0EB2 b = rel x).  A scale factor of $7F is used.
FORCE_NO_SYMBOL $0EB2
FORCE_NO_SYMBOL $0EB4
FORCE_NO_SYMBOL $0EB6
FORCE_NO_SYMBOL $0EB8
FORCE_NO_SYMBOL $0EBA
FORCE_NO_SYMBOL $0EBC
COMMENT $0EBE * "@"
FORCE_NO_SYMBOL $0EBE
FORCE_NO_SYMBOL $0EC0
FORCE_NO_SYMBOL $0EC2
FORCE_NO_SYMBOL $0EC4
FORCE_NO_SYMBOL $0EC6
COMMENT_LINE $0ECB check_for_end_of_sound()
COMMENT_LINE $0ECB This routine checks to see if the current
COMMENT_LINE $0ECB miscellaneous sound has completed, by checking
COMMENT_LINE $0ECB the value in C856.  When it reaches zero, the
COMMENT_LINE $0ECB sound is done.
FORCE_NO_SYMBOL $0ECB
FORCE_SYMBOL $0ED0 init_music_buf
FORCE_NO_SYMBOL $0ED4
COMMENT_LINE $0ED8 set_up_a_misc_sound1()
COMMENT_LINE $0ED8 set_up_a_misc_sound2(sound)
COMMENT_LINE $0ED8 Both of these routines cause a sound to be
COMMENT_LINE $0ED8 made.  If set_up_a_misc_sound1() is used,
COMMENT_LINE $0ED8 then the sound to be made is defined by
COMMENT_LINE $0ED8 writing the value $0050 to reg 0 & reg 1
COMMENT_LINE $0ED8 on the sound chip.  If set_up_a_misc_sound2()
COMMENT_LINE $0ED8 is used, then the value passed in in the 'd'
COMMENT_LINE $0ED8 register defines the sound.  The duration of
COMMENT_LINE $0ED8 the sound is stored in C856.
FORCE_NO_SYMBOL $0ED8
FORCE_NO_SYMBOL $0EDB
COMMENT $0EDE * ">"
FORCE_NO_SYMBOL $0EDE
FORCE_NO_SYMBOL $0EE0
FORCE_NO_SYMBOL $0EE3
FORCE_NO_SYMBOL $0EE5
FORCE_NO_SYMBOL $0EE8
FORCE_NO_SYMBOL $0EEA
COMMENT $0F13 * "?"
COMMENT $0F15 * ";"
COMMENT $0F17 * ";"
COMMENT $0F19 * ";"
COMMENT $0F1B * ";"
COMMENT $0F1D * ";"
COMMENT $0F1F * ";"
COMMENT $0F21 * ";"
COMMENT $0F23 * ";"
COMMENT $0F25 * ";"
COMMENT $0F27 * ";"
COMMENT $0F29 * ";"
COMMENT $0F2B * ";"
COMMENT $0F2D * ";"
COMMENT $0F2F * ";"
COMMENT $0F31 * ";"
COMMENT $0F33 * ";"
COMMENT $0F35 * ";"
COMMENT $0F37 * ";"
COMMENT $0F39 * ";"
COMMENT $0F3B * ";"
COMMENT $0F3D * ";"
COMMENT $0F3F * ";"
COMMENT $0F41 * ";"
COMMENT $0F43 * ";"
COMMENT $0F45 * ";"
COMMENT $0F47 * ";"
COMMENT $0F49 * ";"
COMMENT $0F4B * ";"
COMMENT $0F4D * ";"
COMMENT $0F4F * ";"
COMMENT $0F51 * ";"
COMMENT $0F53 * ";"
COMMENT $0F55 * ";"
COMMENT $0F57 * ";"
COMMENT $0F59 * ";"
COMMENT $0F5B * ";"
COMMENT $0F5D * ";"
COMMENT $0F5F * ";"
COMMENT $0F61 * ";"
COMMENT $0F63 * ";"
COMMENT $0F65 * ";"
COMMENT $0F67 * ";"
COMMENT $0F69 * ";"
COMMENT $0F6B * ";"
COMMENT $0F6D * ";"
COMMENT $0F6F * ";"
COMMENT $0F71 * ";"
COMMENT $0F73 * ";"
COMMENT $0F75 * ";"
COMMENT $0F77 * ";"
COMMENT $0F79 * ";"
COMMENT $0F7B * ";"
COMMENT $0F7D * ";"
COMMENT $0F7E * "3"
COMMENT $0F80 * "i"
COMMENT $0F83 * "i"
COMMENT $0F85 * ";"
COMMENT $0F87 * ";"
COMMENT $0F89 * ";"
COMMENT $0F8B * ";"
COMMENT $0F8D * ";"
COMMENT $0F8F * ";"
COMMENT $0F91 * ";"
COMMENT $0F93 * ";"
COMMENT $0F95 * ";"
COMMENT $0F97 * ";"
COMMENT $0F99 * ";"
COMMENT $0F9B * ";"
COMMENT $0F9D * ";"
COMMENT $0F9F * ";"
COMMENT $0FA1 * ";"
COMMENT $0FA3 * ";"
COMMENT $0FA5 * ";"
COMMENT $0FA7 * ";"
COMMENT $0FA9 * ";"
COMMENT $0FAB * ";"
COMMENT $0FAD * ";"
COMMENT $0FAF * ";"
COMMENT $0FB1 * ";"
COMMENT $0FB3 * ";"
COMMENT $0FB5 * ";"
COMMENT $0FB7 * ";"
COMMENT $0FB9 * ";"
COMMENT $0FBB * ";"
COMMENT $0FBD * ";"
COMMENT $0FBF * ";"
COMMENT $0FC1 * ";"
COMMENT $0FC3 * ";"
COMMENT $0FC5 * ";"
COMMENT $0FC7 * ";"
COMMENT $0FC9 * ";"
COMMENT $0FCB * ";"
COMMENT $0FCD * ";"
COMMENT $0FCF * ";"
COMMENT $0FD1 * ";"
COMMENT $0FD3 * ";"
COMMENT $0FD5 * ";"
COMMENT $0FD7 * ";"
COMMENT $0FD9 * ";"
COMMENT $0FDB * ";"
COMMENT $0FDD * ";"
COMMENT $0FDF * ";"
COMMENT $0FE1 * ";"
COMMENT $0FE3 * ";"
COMMENT $0FE5 * ";"
COMMENT $0FE7 * ";"
COMMENT $0FE9 * ";"
COMMENT $0FEB * ";"
COMMENT $0FED * ";"
COMMENT $0FEF * ";"
COMMENT $0FF1 * ";"
COMMENT $0FF3 * ";"
COMMENT $0FF5 * ";"
COMMENT $0FF7 * ";"
COMMENT $0FF9 * ";"
COMMENT $0FFB * ";"
COMMENT $0FFD * ";"
COMMENT $0FFF * ";"
RANGE $0000-$000B CHAR_DATA 11
RANGE $000B-$000D DW_DATA 1
RANGE $000D-$000E DB_DATA 1
RANGE $000E-$000F DB_DATA 1
RANGE $000F-$0010 DB_DATA 1
RANGE $0010-$0011 DB_DATA 1
RANGE $0011-$0015 CHAR_DATA 4
RANGE $0015-$0016 DB_DATA 1
RANGE $0016-$0017 DB_DATA 1
RANGE $0017-$0018 DB_DATA 1
RANGE $0018-$0019 DB_DATA 1
RANGE $0019-$0021 CHAR_DATA 8
RANGE $0021-$0056 CODE
RANGE $0056-$0057 DB_DATA 1
RANGE $0057-$0058 DB_DATA 1
RANGE $0058-$0059 DB_DATA 1
RANGE $0059-$005A DB_DATA 1
RANGE $005A-$005C DW_DATA 1
RANGE $005C-$0062 CHAR_DATA 6
RANGE $0062-$0063 DB_DATA 1
RANGE $0063-$0064 DB_DATA 1
RANGE $0064-$0065 DB_DATA 1
RANGE $0065-$0066 DB_DATA 1
RANGE $0066-$0068 DW_DATA 1
RANGE $0068-$006D CHAR_DATA 5
RANGE $006D-$006E DB_DATA 1
RANGE $006E-$006F DB_DATA 1
RANGE $006F-$0070 DB_DATA 1
RANGE $0070-$0071 DB_DATA 1
RANGE $0071-$0073 DW_DATA 1
RANGE $0073-$0078 CHAR_DATA 5
RANGE $0078-$0079 DB_DATA 1
RANGE $0079-$007A DB_DATA 1
RANGE $007A-$007B DB_DATA 1
RANGE $007B-$007C DB_DATA 1
RANGE $007C-$007E DW_DATA 1
RANGE $007E-$0083 CHAR_DATA 5
RANGE $0083-$0084 DB_DATA 1
RANGE $0084-$0085 DB_DATA 1
RANGE $0085-$0086 DB_DATA 1
RANGE $0086-$0087 DB_DATA 1
RANGE $0087-$0089 DW_DATA 1
RANGE $0089-$008E CHAR_DATA 5
RANGE $008E-$008F DB_DATA 1
RANGE $008F-$0090 DB_DATA 1
RANGE $0090-$0091 DB_DATA 1
RANGE $0091-$0092 DB_DATA 1
RANGE $0092-$0094 DW_DATA 1
RANGE $0094-$009B CHAR_DATA 7
RANGE $009B-$0151 CODE
RANGE $0151-$0152 DB_DATA 1
RANGE $0152-$0153 DB_DATA 1
RANGE $0153-$0154 DB_DATA 1
RANGE $0154-$0155 DB_DATA 1
RANGE $0155-$0157 DW_DATA 1
RANGE $0157-$015E CHAR_DATA 7
RANGE $015E-$015F DB_DATA 1
RANGE $015F-$0160 DB_DATA 1
RANGE $0160-$0161 DB_DATA 1
RANGE $0161-$0162 DB_DATA 1
RANGE $0162-$0164 DW_DATA 1
RANGE $0164-$0169 CHAR_DATA 5
RANGE $0169-$016A DB_DATA 1
RANGE $016A-$016B DB_DATA 1
RANGE $016B-$016C DB_DATA 1
RANGE $016C-$016D DB_DATA 1
RANGE $016D-$016F DW_DATA 1
RANGE $016F-$0176 CHAR_DATA 7
RANGE $0176-$0177 DB_DATA 1
RANGE $0177-$0178 DB_DATA 1
RANGE $0178-$0179 DB_DATA 1
RANGE $0179-$017A DB_DATA 1
RANGE $017A-$017C DW_DATA 1
RANGE $017C-$0184 CHAR_DATA 8
RANGE $0184-$0185 DB_DATA 1
RANGE $0185-$0186 DB_DATA 1
RANGE $0186-$0187 DB_DATA 1
RANGE $0187-$0188 DB_DATA 1
RANGE $0188-$018A DW_DATA 1
RANGE $018A-$0192 CHAR_DATA 8
RANGE $0192-$0193 DB_DATA 1
RANGE $0193-$0194 DB_DATA 1
RANGE $0194-$0195 DB_DATA 1
RANGE $0195-$0196 DB_DATA 1
RANGE $0196-$0197 DB_DATA 1
RANGE $0197-$0198 DB_DATA 1
RANGE $0198-$0199 DB_DATA 1
RANGE $0199-$019A DB_DATA 1
RANGE $019A-$019B DB_DATA 1
RANGE $019B-$019C DB_DATA 1
RANGE $019C-$019D DB_DATA 1
RANGE $019D-$019E DB_DATA 1
RANGE $019E-$019F DB_DATA 1
RANGE $019F-$01A0 DB_DATA 1
RANGE $01A0-$01A1 DB_DATA 1
RANGE $01A1-$01A2 DB_DATA 1
RANGE $01A2-$02C1 CODE
RANGE $02C1-$02C2 DB_DATA 1
RANGE $02C2-$02C3 DB_DATA 1
RANGE $02C3-$02C4 DB_DATA 1
RANGE $02C4-$02C5 DB_DATA 1
RANGE $02C5-$02C7 DW_DATA 1
RANGE $02C7-$052F CODE
RANGE $052F-$0530 DB_DATA 1
RANGE $0530-$0531 DB_DATA 1
RANGE $0531-$0532 DB_DATA 1
RANGE $0532-$0533 DB_DATA 1
RANGE $0533-$0534 DB_DATA 1
RANGE $0534-$0535 DB_DATA 1
RANGE $0535-$0536 DB_DATA 1
RANGE $0536-$0537 DB_DATA 1
RANGE $0537-$0538 DB_DATA 1
RANGE $0538-$0539 DB_DATA 1
RANGE $0539-$053A DB_DATA 1
RANGE $053A-$053B DB_DATA 1
RANGE $053B-$053C DB_DATA 1
RANGE $053C-$0632 CODE
RANGE $0632-$0633 DB_DATA 1
RANGE $0633-$0635 DW_DATA 1
RANGE $0635-$0636 DB_DATA 1
RANGE $0636-$0638 DW_DATA 1
RANGE $0638-$0639 DB_DATA 1
RANGE $0639-$063B DW_DATA 1
RANGE $063B-$063C DB_DATA 1
RANGE $063C-$063E DW_DATA 1
RANGE $063E-$063F DB_DATA 1
RANGE $063F-$0641 DW_DATA 1
RANGE $0641-$0642 DB_DATA 1
RANGE $0642-$0644 DW_DATA 1
RANGE $0644-$0645 DB_DATA 1
RANGE $0645-$0647 DW_DATA 1
RANGE $0647-$0648 DB_DATA 1
RANGE $0648-$064A DW_DATA 1
RANGE $064A-$0669 CODE
RANGE $0669-$066B DW_DATA 1
RANGE $066B-$066D DW_DATA 1
RANGE $066D-$066F DW_DATA 1
RANGE $066F-$0671 DW_DATA 1
RANGE $0671-$0673 DW_DATA 1
RANGE $0673-$0675 DW_DATA 1
RANGE $0675-$0677 DW_DATA 1
RANGE $0677-$0679 DW_DATA 1
RANGE $0679-$067B DW_DATA 1
RANGE $067B-$067D DW_DATA 1
RANGE $067D-$067F DW_DATA 1
RANGE $067F-$07D5 CODE
RANGE $07D5-$07D6 DB_DATA 1
RANGE $07D6-$08E7 CODE
RANGE $08E7-$08E8 DB_DATA 1
RANGE $08E8-$08E9 DB_DATA 1
RANGE $08E9-$08EA DB_DATA 1
RANGE $08EA-$08EB DB_DATA 1
RANGE $08EB-$08EC DB_DATA 1
RANGE $08EC-$08ED DB_DATA 1
RANGE $08ED-$0A50 CODE
RANGE $0A50-$0A51 DB_DATA 1
RANGE $0A51-$0A52 DB_DATA 1
RANGE $0A52-$0A53 DB_DATA 1
RANGE $0A53-$0A54 DB_DATA 1
RANGE $0A54-$0A55 DB_DATA 1
RANGE $0A55-$0A56 DB_DATA 1
RANGE $0A56-$0A57 DB_DATA 1
RANGE $0A57-$0A58 DB_DATA 1
RANGE $0A58-$0A59 DB_DATA 1
RANGE $0A59-$0A5A DB_DATA 1
RANGE $0A5A-$0A5B DB_DATA 1
RANGE $0A5B-$0A5C DB_DATA 1
RANGE $0A5C-$0A5D DB_DATA 1
RANGE $0A5D-$0A5E DB_DATA 1
RANGE $0A5E-$0A5F DB_DATA 1
RANGE $0A5F-$0A60 DB_DATA 1
RANGE $0A60-$0A61 DB_DATA 1
RANGE $0A61-$0A62 DB_DATA 1
RANGE $0A62-$0A63 DB_DATA 1
RANGE $0A63-$0A64 DB_DATA 1
RANGE $0A64-$0A65 DB_DATA 1
RANGE $0A65-$0A66 DB_DATA 1
RANGE $0A66-$0A67 DB_DATA 1
RANGE $0A67-$0A68 DB_DATA 1
RANGE $0A68-$0A69 DB_DATA 1
RANGE $0A69-$0A6A DB_DATA 1
RANGE $0A6A-$0A6B DB_DATA 1
RANGE $0A6B-$0A6C DB_DATA 1
RANGE $0A6C-$0A6D DB_DATA 1
RANGE $0A6D-$0A6E DB_DATA 1
RANGE $0A6E-$0A6F DB_DATA 1
RANGE $0A6F-$0A70 DB_DATA 1
RANGE $0A70-$0A71 DB_DATA 1
RANGE $0A71-$0A72 DB_DATA 1
RANGE $0A72-$0A73 DB_DATA 1
RANGE $0A73-$0A74 DB_DATA 1
RANGE $0A74-$0A75 DB_DATA 1
RANGE $0A75-$0A76 DB_DATA 1
RANGE $0A76-$0A77 DB_DATA 1
RANGE $0A77-$0A78 DB_DATA 1
RANGE $0A78-$0A79 DB_DATA 1
RANGE $0A79-$0A7A DB_DATA 1
RANGE $0A7A-$0A7B DB_DATA 1
RANGE $0A7B-$0A7C DB_DATA 1
RANGE $0A7C-$0A7D DB_DATA 1
RANGE $0A7D-$0A7E DB_DATA 1
RANGE $0A7E-$0A7F DB_DATA 1
RANGE $0A7F-$0A80 DB_DATA 1
RANGE $0A80-$0A81 DB_DATA 1
RANGE $0A81-$0A82 DB_DATA 1
RANGE $0A82-$0A83 DB_DATA 1
RANGE $0A83-$0A84 DB_DATA 1
RANGE $0A84-$0A85 DB_DATA 1
RANGE $0A85-$0A86 DB_DATA 1
RANGE $0A86-$0A87 DB_DATA 1
RANGE $0A87-$0A88 DB_DATA 1
RANGE $0A88-$0A89 DB_DATA 1
RANGE $0A89-$0A8A DB_DATA 1
RANGE $0A8A-$0A8B DB_DATA 1
RANGE $0A8B-$0A8C DB_DATA 1
RANGE $0A8C-$0A8D DB_DATA 1
RANGE $0A8D-$0A8E DB_DATA 1
RANGE $0A8E-$0A8F DB_DATA 1
RANGE $0A8F-$0A90 DB_DATA 1
RANGE $0A90-$0A91 DB_DATA 1
RANGE $0A91-$0A92 DB_DATA 1
RANGE $0A92-$0A93 DB_DATA 1
RANGE $0A93-$0A94 DB_DATA 1
RANGE $0A94-$0A95 DB_DATA 1
RANGE $0A95-$0A96 DB_DATA 1
RANGE $0A96-$0A97 DB_DATA 1
RANGE $0A97-$0A98 DB_DATA 1
RANGE $0A98-$0A99 DB_DATA 1
RANGE $0A99-$0A9A DB_DATA 1
RANGE $0A9A-$0A9B DB_DATA 1
RANGE $0A9B-$0A9C DB_DATA 1
RANGE $0A9C-$0A9D DB_DATA 1
RANGE $0A9D-$0A9E DB_DATA 1
RANGE $0A9E-$0A9F DB_DATA 1
RANGE $0A9F-$0AA0 DB_DATA 1
RANGE $0AA0-$0AA1 DB_DATA 1
RANGE $0AA1-$0AA2 DB_DATA 1
RANGE $0AA2-$0AA3 DB_DATA 1
RANGE $0AA3-$0AA4 DB_DATA 1
RANGE $0AA4-$0AA5 DB_DATA 1
RANGE $0AA5-$0AA6 DB_DATA 1
RANGE $0AA6-$0AA7 DB_DATA 1
RANGE $0AA7-$0AA8 DB_DATA 1
RANGE $0AA8-$0AA9 DB_DATA 1
RANGE $0AA9-$0AAA DB_DATA 1
RANGE $0AAA-$0AAB DB_DATA 1
RANGE $0AAB-$0AAC DB_DATA 1
RANGE $0AAC-$0AAD DB_DATA 1
RANGE $0AAD-$0AAE DB_DATA 1
RANGE $0AAE-$0AAF DB_DATA 1
RANGE $0AAF-$0AB0 DB_DATA 1
RANGE $0AB0-$0AB1 DB_DATA 1
RANGE $0AB1-$0AB2 DB_DATA 1
RANGE $0AB2-$0AB3 DB_DATA 1
RANGE $0AB3-$0AB4 DB_DATA 1
RANGE $0AB4-$0AB5 DB_DATA 1
RANGE $0AB5-$0AB6 DB_DATA 1
RANGE $0AB6-$0AB7 DB_DATA 1
RANGE $0AB7-$0AB8 DB_DATA 1
RANGE $0AB8-$0AB9 DB_DATA 1
RANGE $0AB9-$0ABA DB_DATA 1
RANGE $0ABA-$0ABB DB_DATA 1
RANGE $0ABB-$0ABC DB_DATA 1
RANGE $0ABC-$0ABD DB_DATA 1
RANGE $0ABD-$0ABE DB_DATA 1
RANGE $0ABE-$0ABF DB_DATA 1
RANGE $0ABF-$0AC0 DB_DATA 1
RANGE $0AC0-$0AC1 DB_DATA 1
RANGE $0AC1-$0AC2 DB_DATA 1
RANGE $0AC2-$0AC3 DB_DATA 1
RANGE $0AC3-$0AC4 DB_DATA 1
RANGE $0AC4-$0AC5 DB_DATA 1
RANGE $0AC5-$0AC6 DB_DATA 1
RANGE $0AC6-$0AC7 DB_DATA 1
RANGE $0AC7-$0AC8 DB_DATA 1
RANGE $0AC8-$0AC9 DB_DATA 1
RANGE $0AC9-$0ACA DB_DATA 1
RANGE $0ACA-$0ACB DB_DATA 1
RANGE $0ACB-$0ACC DB_DATA 1
RANGE $0ACC-$0ACD DB_DATA 1
RANGE $0ACD-$0ACE DB_DATA 1
RANGE $0ACE-$0ACF DB_DATA 1
RANGE $0ACF-$0BB4 CODE
RANGE $0BB4-$0BB5 DB_DATA 1
RANGE $0BB5-$0BB6 DB_DATA 1
RANGE $0BB6-$0BB7 DB_DATA 1
RANGE $0BB7-$0BB8 DB_DATA 1
RANGE $0BB8-$0BB9 DB_DATA 1
RANGE $0BB9-$0BBA DB_DATA 1
RANGE $0BBA-$0BBE CHAR_DATA 4
RANGE $0BBE-$0BBF DB_DATA 1
RANGE $0BBF-$0BC0 DB_DATA 1
RANGE $0BC0-$0BC1 DB_DATA 1
RANGE $0BC1-$0BC2 DB_DATA 1
RANGE $0BC2-$0BC3 DB_DATA 1
RANGE $0BC3-$0BC4 DB_DATA 1
RANGE $0BC4-$0BC9 CHAR_DATA 5
RANGE $0BC9-$0BCA DB_DATA 1
RANGE $0BCA-$0BCB DB_DATA 1
RANGE $0BCB-$0BCC DB_DATA 1
RANGE $0BCC-$0BCD DB_DATA 1
RANGE $0BCD-$0BCE DB_DATA 1
RANGE $0BCE-$0BCF DB_DATA 1
RANGE $0BCF-$0D0C CODE
RANGE $0D0C-$0D0D DB_DATA 1
RANGE $0D0D-$0D0E DB_DATA 1
RANGE $0D0E-$0D0F DB_DATA 1
RANGE $0D0F-$0D10 DB_DATA 1
RANGE $0D10-$0D11 DB_DATA 1
RANGE $0D11-$0D12 DB_DATA 1
RANGE $0D12-$0D1A CHAR_DATA 8
RANGE $0D1A-$0D1B DB_DATA 1
RANGE $0D1B-$0D1C DB_DATA 1
RANGE $0D1C-$0D1D DB_DATA 1
RANGE $0D1D-$0D1E DB_DATA 1
RANGE $0D1E-$0D1F DB_DATA 1
RANGE $0D1F-$0D20 DB_DATA 1
RANGE $0D20-$0D27 CHAR_DATA 7
RANGE $0D27-$0DB1 CODE
RANGE $0DB1-$0DB2 DB_DATA 1
RANGE $0DB2-$0EEE CODE
RANGE $0EEE-$0EF0 DW_DATA 1
RANGE $0EF0-$0EF2 DW_DATA 1
RANGE $0EF2-$0EF3 DB_DATA 1
RANGE $0EF3-$0EF4 DB_DATA 1
RANGE $0EF4-$0EF5 DB_DATA 1
RANGE $0EF5-$0EF6 DB_DATA 1
RANGE $0EF6-$0EF7 DB_DATA 1
RANGE $0EF7-$0EF8 DB_DATA 1
RANGE $0EF8-$0EF9 DB_DATA 1
RANGE $0EF9-$0EFA DB_DATA 1
RANGE $0EFA-$0EFB DB_DATA 1
RANGE $0EFB-$0EFC DB_DATA 1
RANGE $0EFC-$0EFD DB_DATA 1
RANGE $0EFD-$0EFE DB_DATA 1
RANGE $0EFE-$0EFF DB_DATA 1
RANGE $0EFF-$0F00 DB_DATA 1
RANGE $0F00-$0F01 DB_DATA 1
RANGE $0F01-$0F02 DB_DATA 1
RANGE $0F02-$0F03 DB_DATA 1
RANGE $0F03-$0F04 DB_DATA 1
RANGE $0F04-$0F05 DB_DATA 1
RANGE $0F05-$0F06 DB_DATA 1
RANGE $0F06-$0F07 DB_DATA 1
RANGE $0F07-$0F08 DB_DATA 1
RANGE $0F08-$0F09 DB_DATA 1
RANGE $0F09-$0F0A DB_DATA 1
RANGE $0F0A-$0F0B DB_DATA 1
RANGE $0F0B-$0F0C DB_DATA 1
RANGE $0F0C-$0F0D DB_DATA 1
RANGE $0F0D-$0F0E DB_DATA 1
RANGE $0F0E-$0F0F DB_DATA 1
RANGE $0F0F-$0F10 DB_DATA 1
RANGE $0F10-$0F11 DB_DATA 1
RANGE $0F11-$0F12 DB_DATA 1
RANGE $0F12-$0F13 DB_DATA 1
RANGE $0F13-$0F14 DB_DATA 1
RANGE $0F14-$0F15 DB_DATA 1
RANGE $0F15-$0F16 DB_DATA 1
RANGE $0F16-$0F17 DB_DATA 1
RANGE $0F17-$0F18 DB_DATA 1
RANGE $0F18-$0F19 DB_DATA 1
RANGE $0F19-$0F1A DB_DATA 1
RANGE $0F1A-$0F1B DB_DATA 1
RANGE $0F1B-$0F1C DB_DATA 1
RANGE $0F1C-$0F1D DB_DATA 1
RANGE $0F1D-$0F1E DB_DATA 1
RANGE $0F1E-$0F1F DB_DATA 1
RANGE $0F1F-$0F20 DB_DATA 1
RANGE $0F20-$0F21 DB_DATA 1
RANGE $0F21-$0F22 DB_DATA 1
RANGE $0F22-$0F23 DB_DATA 1
RANGE $0F23-$0F24 DB_DATA 1
RANGE $0F24-$0F25 DB_DATA 1
RANGE $0F25-$0F26 DB_DATA 1
RANGE $0F26-$0F27 DB_DATA 1
RANGE $0F27-$0F28 DB_DATA 1
RANGE $0F28-$0F29 DB_DATA 1
RANGE $0F29-$0F2A DB_DATA 1
RANGE $0F2A-$0F2B DB_DATA 1
RANGE $0F2B-$0F2C DB_DATA 1
RANGE $0F2C-$0F2D DB_DATA 1
RANGE $0F2D-$0F2E DB_DATA 1
RANGE $0F2E-$0F2F DB_DATA 1
RANGE $0F2F-$0F30 DB_DATA 1
RANGE $0F30-$0F31 DB_DATA 1
RANGE $0F31-$0F32 DB_DATA 1
RANGE $0F32-$0F33 DB_DATA 1
RANGE $0F33-$0F34 DB_DATA 1
RANGE $0F34-$0F35 DB_DATA 1
RANGE $0F35-$0F36 DB_DATA 1
RANGE $0F36-$0F37 DB_DATA 1
RANGE $0F37-$0F38 DB_DATA 1
RANGE $0F38-$0F39 DB_DATA 1
RANGE $0F39-$0F3A DB_DATA 1
RANGE $0F3A-$0F3B DB_DATA 1
RANGE $0F3B-$0F3C DB_DATA 1
RANGE $0F3C-$0F3D DB_DATA 1
RANGE $0F3D-$0F3E DB_DATA 1
RANGE $0F3E-$0F3F DB_DATA 1
RANGE $0F3F-$0F40 DB_DATA 1
RANGE $0F40-$0F41 DB_DATA 1
RANGE $0F41-$0F42 DB_DATA 1
RANGE $0F42-$0F43 DB_DATA 1
RANGE $0F43-$0F44 DB_DATA 1
RANGE $0F44-$0F45 DB_DATA 1
RANGE $0F45-$0F46 DB_DATA 1
RANGE $0F46-$0F47 DB_DATA 1
RANGE $0F47-$0F48 DB_DATA 1
RANGE $0F48-$0F49 DB_DATA 1
RANGE $0F49-$0F4A DB_DATA 1
RANGE $0F4A-$0F4B DB_DATA 1
RANGE $0F4B-$0F4C DB_DATA 1
RANGE $0F4C-$0F4D DB_DATA 1
RANGE $0F4D-$0F4E DB_DATA 1
RANGE $0F4E-$0F4F DB_DATA 1
RANGE $0F4F-$0F50 DB_DATA 1
RANGE $0F50-$0F51 DB_DATA 1
RANGE $0F51-$0F52 DB_DATA 1
RANGE $0F52-$0F53 DB_DATA 1
RANGE $0F53-$0F54 DB_DATA 1
RANGE $0F54-$0F55 DB_DATA 1
RANGE $0F55-$0F56 DB_DATA 1
RANGE $0F56-$0F57 DB_DATA 1
RANGE $0F57-$0F58 DB_DATA 1
RANGE $0F58-$0F59 DB_DATA 1
RANGE $0F59-$0F5A DB_DATA 1
RANGE $0F5A-$0F5B DB_DATA 1
RANGE $0F5B-$0F5C DB_DATA 1
RANGE $0F5C-$0F5D DB_DATA 1
RANGE $0F5D-$0F5E DB_DATA 1
RANGE $0F5E-$0F5F DB_DATA 1
RANGE $0F5F-$0F60 DB_DATA 1
RANGE $0F60-$0F61 DB_DATA 1
RANGE $0F61-$0F62 DB_DATA 1
RANGE $0F62-$0F63 DB_DATA 1
RANGE $0F63-$0F64 DB_DATA 1
RANGE $0F64-$0F65 DB_DATA 1
RANGE $0F65-$0F66 DB_DATA 1
RANGE $0F66-$0F67 DB_DATA 1
RANGE $0F67-$0F68 DB_DATA 1
RANGE $0F68-$0F69 DB_DATA 1
RANGE $0F69-$0F6A DB_DATA 1
RANGE $0F6A-$0F6B DB_DATA 1
RANGE $0F6B-$0F6C DB_DATA 1
RANGE $0F6C-$0F6D DB_DATA 1
RANGE $0F6D-$0F6E DB_DATA 1
RANGE $0F6E-$0F6F DB_DATA 1
RANGE $0F6F-$0F70 DB_DATA 1
RANGE $0F70-$0F71 DB_DATA 1
RANGE $0F71-$0F72 DB_DATA 1
RANGE $0F72-$0F73 DB_DATA 1
RANGE $0F73-$0F74 DB_DATA 1
RANGE $0F74-$0F75 DB_DATA 1
RANGE $0F75-$0F76 DB_DATA 1
RANGE $0F76-$0F77 DB_DATA 1
RANGE $0F77-$0F78 DB_DATA 1
RANGE $0F78-$0F79 DB_DATA 1
RANGE $0F79-$0F7A DB_DATA 1
RANGE $0F7A-$0F7B DB_DATA 1
RANGE $0F7B-$0F7C DB_DATA 1
RANGE $0F7C-$0F7D DB_DATA 1
RANGE $0F7D-$0F7E DB_DATA 1
RANGE $0F7E-$0F7F DB_DATA 1
RANGE $0F7F-$0F80 DB_DATA 1
RANGE $0F80-$0F81 DB_DATA 1
RANGE $0F81-$0F82 DB_DATA 1
RANGE $0F82-$0F83 DB_DATA 1
RANGE $0F83-$0F84 DB_DATA 1
RANGE $0F84-$0F85 DB_DATA 1
RANGE $0F85-$0F86 DB_DATA 1
RANGE $0F86-$0F87 DB_DATA 1
RANGE $0F87-$0F88 DB_DATA 1
RANGE $0F88-$0F89 DB_DATA 1
RANGE $0F89-$0F8A DB_DATA 1
RANGE $0F8A-$0F8B DB_DATA 1
RANGE $0F8B-$0F8C DB_DATA 1
RANGE $0F8C-$0F8D DB_DATA 1
RANGE $0F8D-$0F8E DB_DATA 1
RANGE $0F8E-$0F8F DB_DATA 1
RANGE $0F8F-$0F90 DB_DATA 1
RANGE $0F90-$0F91 DB_DATA 1
RANGE $0F91-$0F92 DB_DATA 1
RANGE $0F92-$0F93 DB_DATA 1
RANGE $0F93-$0F94 DB_DATA 1
RANGE $0F94-$0F95 DB_DATA 1
RANGE $0F95-$0F96 DB_DATA 1
RANGE $0F96-$0F97 DB_DATA 1
RANGE $0F97-$0F98 DB_DATA 1
RANGE $0F98-$0F99 DB_DATA 1
RANGE $0F99-$0F9A DB_DATA 1
RANGE $0F9A-$0F9B DB_DATA 1
RANGE $0F9B-$0F9C DB_DATA 1
RANGE $0F9C-$0F9D DB_DATA 1
RANGE $0F9D-$0F9E DB_DATA 1
RANGE $0F9E-$0F9F DB_DATA 1
RANGE $0F9F-$0FA0 DB_DATA 1
RANGE $0FA0-$0FA1 DB_DATA 1
RANGE $0FA1-$0FA2 DB_DATA 1
RANGE $0FA2-$0FA3 DB_DATA 1
RANGE $0FA3-$0FA4 DB_DATA 1
RANGE $0FA4-$0FA5 DB_DATA 1
RANGE $0FA5-$0FA6 DB_DATA 1
RANGE $0FA6-$0FA7 DB_DATA 1
RANGE $0FA7-$0FA8 DB_DATA 1
RANGE $0FA8-$0FA9 DB_DATA 1
RANGE $0FA9-$0FAA DB_DATA 1
RANGE $0FAA-$0FAB DB_DATA 1
RANGE $0FAB-$0FAC DB_DATA 1
RANGE $0FAC-$0FAD DB_DATA 1
RANGE $0FAD-$0FAE DB_DATA 1
RANGE $0FAE-$0FAF DB_DATA 1
RANGE $0FAF-$0FB0 DB_DATA 1
RANGE $0FB0-$0FB1 DB_DATA 1
RANGE $0FB1-$0FB2 DB_DATA 1
RANGE $0FB2-$0FB3 DB_DATA 1
RANGE $0FB3-$0FB4 DB_DATA 1
RANGE $0FB4-$0FB5 DB_DATA 1
RANGE $0FB5-$0FB6 DB_DATA 1
RANGE $0FB6-$0FB7 DB_DATA 1
RANGE $0FB7-$0FB8 DB_DATA 1
RANGE $0FB8-$0FB9 DB_DATA 1
RANGE $0FB9-$0FBA DB_DATA 1
RANGE $0FBA-$0FBB DB_DATA 1
RANGE $0FBB-$0FBC DB_DATA 1
RANGE $0FBC-$0FBD DB_DATA 1
RANGE $0FBD-$0FBE DB_DATA 1
RANGE $0FBE-$0FBF DB_DATA 1
RANGE $0FBF-$0FC0 DB_DATA 1
RANGE $0FC0-$0FC1 DB_DATA 1
RANGE $0FC1-$0FC2 DB_DATA 1
RANGE $0FC2-$0FC3 DB_DATA 1
RANGE $0FC3-$0FC4 DB_DATA 1
RANGE $0FC4-$0FC5 DB_DATA 1
RANGE $0FC5-$0FC6 DB_DATA 1
RANGE $0FC6-$0FC7 DB_DATA 1
RANGE $0FC7-$0FC8 DB_DATA 1
RANGE $0FC8-$0FC9 DB_DATA 1
RANGE $0FC9-$0FCA DB_DATA 1
RANGE $0FCA-$0FCB DB_DATA 1
RANGE $0FCB-$0FCC DB_DATA 1
RANGE $0FCC-$0FCD DB_DATA 1
RANGE $0FCD-$0FCE DB_DATA 1
RANGE $0FCE-$0FCF DB_DATA 1
RANGE $0FCF-$0FD0 DB_DATA 1
RANGE $0FD0-$0FD1 DB_DATA 1
RANGE $0FD1-$0FD2 DB_DATA 1
RANGE $0FD2-$0FD3 DB_DATA 1
RANGE $0FD3-$0FD4 DB_DATA 1
RANGE $0FD4-$0FD5 DB_DATA 1
RANGE $0FD5-$0FD6 DB_DATA 1
RANGE $0FD6-$0FD7 DB_DATA 1
RANGE $0FD7-$0FD8 DB_DATA 1
RANGE $0FD8-$0FD9 DB_DATA 1
RANGE $0FD9-$0FDA DB_DATA 1
RANGE $0FDA-$0FDB DB_DATA 1
RANGE $0FDB-$0FDC DB_DATA 1
RANGE $0FDC-$0FDD DB_DATA 1
RANGE $0FDD-$0FDE DB_DATA 1
RANGE $0FDE-$0FDF DB_DATA 1
RANGE $0FDF-$0FE0 DB_DATA 1
RANGE $0FE0-$0FE1 DB_DATA 1
RANGE $0FE1-$0FE2 DB_DATA 1
RANGE $0FE2-$0FE3 DB_DATA 1
RANGE $0FE3-$0FE4 DB_DATA 1
RANGE $0FE4-$0FE5 DB_DATA 1
RANGE $0FE5-$0FE6 DB_DATA 1
RANGE $0FE6-$0FE7 DB_DATA 1
RANGE $0FE7-$0FE8 DB_DATA 1
RANGE $0FE8-$0FE9 DB_DATA 1
RANGE $0FE9-$0FEA DB_DATA 1
RANGE $0FEA-$0FEB DB_DATA 1
RANGE $0FEB-$0FEC DB_DATA 1
RANGE $0FEC-$0FED DB_DATA 1
RANGE $0FED-$0FEE DB_DATA 1
RANGE $0FEE-$0FEF DB_DATA 1
RANGE $0FEF-$0FF0 DB_DATA 1
RANGE $0FF0-$0FF1 DB_DATA 1
RANGE $0FF1-$0FF2 DB_DATA 1
RANGE $0FF2-$0FF3 DB_DATA 1
RANGE $0FF3-$0FF4 DB_DATA 1
RANGE $0FF4-$0FF5 DB_DATA 1
RANGE $0FF5-$0FF6 DB_DATA 1
RANGE $0FF6-$0FF7 DB_DATA 1
RANGE $0FF7-$0FF8 DB_DATA 1
RANGE $0FF8-$0FF9 DB_DATA 1
RANGE $0FF9-$0FFA DB_DATA 1
RANGE $0FFA-$0FFB DB_DATA 1
RANGE $0FFB-$0FFC DB_DATA 1
RANGE $0FFC-$0FFD DB_DATA 1
RANGE $0FFD-$0FFE DB_DATA 1
RANGE $0FFE-$0FFF DB_DATA 1
RANGE $0FFF-$1000 DB_DATA 1

