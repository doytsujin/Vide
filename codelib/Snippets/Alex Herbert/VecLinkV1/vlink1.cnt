BANK 0
EQU $00 
LABEL $C800 Vec_Snd_Shadow
COMMENT_LABEL $C800 Shadow of sound chip registers (15 bytes)
LABEL $C80F Vec_Btn_State
COMMENT_LABEL $C80F Current state of all joystick buttons
LABEL $C810 Vec_Prev_Btns
COMMENT_LABEL $C810 Previous state of all joystick buttons
LABEL $C811 Vec_Buttons
COMMENT_LABEL $C811 Current toggle state of all buttons
LABEL $C812 Vec_Button_1_1
COMMENT_LABEL $C812 Current toggle state of stick 1 button 1
LABEL $C813 Vec_Button_1_2
COMMENT_LABEL $C813 Current toggle state of stick 1 button 2
LABEL $C814 Vec_Button_1_3
COMMENT_LABEL $C814 Current toggle state of stick 1 button 3
LABEL $C815 Vec_Button_1_4
COMMENT_LABEL $C815 Current toggle state of stick 1 button 4
LABEL $C816 Vec_Button_2_1
COMMENT_LABEL $C816 Current toggle state of stick 2 button 1
LABEL $C817 Vec_Button_2_2
COMMENT_LABEL $C817 Current toggle state of stick 2 button 2
LABEL $C818 Vec_Button_2_3
COMMENT_LABEL $C818 Current toggle state of stick 2 button 3
LABEL $C819 Vec_Button_2_4
COMMENT_LABEL $C819 Current toggle state of stick 2 button 4
LABEL $C81A Vec_Joy_Resltn
COMMENT_LABEL $C81A Joystick A/D resolution ($80=min $00=max)
LABEL $C81B Vec_Joy_1_X
COMMENT_LABEL $C81B Joystick 1 left/right
LABEL $C81C Vec_Joy_1_Y
COMMENT_LABEL $C81C Joystick 1 up/down
LABEL $C81D Vec_Joy_2_X
COMMENT_LABEL $C81D Joystick 2 left/right
LABEL $C81E Vec_Joy_2_Y
COMMENT_LABEL $C81E Joystick 2 up/down
LABEL $C81F Vec_Joy_Mux
COMMENT_LABEL $C81F Joystick enable/mux flags (4 bytes)
LABEL $C81F Vec_Joy_Mux_1_X
COMMENT_LABEL $C81F Joystick 1 X enable/mux flag (=1)
LABEL $C820 Vec_Joy_Mux_1_Y
COMMENT_LABEL $C820 Joystick 1 Y enable/mux flag (=3)
LABEL $C821 Vec_Joy_Mux_2_X
COMMENT_LABEL $C821 Joystick 2 X enable/mux flag (=5)
LABEL $C822 Vec_Joy_Mux_2_Y
COMMENT_LABEL $C822 Joystick 2 Y enable/mux flag (=7)
LABEL $C823 Vec_Misc_Count
COMMENT_LABEL $C823 Misc counter/flag byte, zero when not in use
LABEL $C824 Vec_0Ref_Enable
COMMENT_LABEL $C824 Check0Ref enable flag
LABEL $C825 Vec_Loop_Count
COMMENT_LABEL $C825 Loop counter word (incremented in Wait_Recal)
LABEL $C827 Vec_Brightness
COMMENT_LABEL $C827 Default brightness
LABEL $C828 Vec_Dot_Dwell
COMMENT_LABEL $C828 Dot dwell time?
LABEL $C829 Vec_Pattern
COMMENT_LABEL $C829 Dot pattern (bits)
LABEL $C82A Vec_Text_HW
COMMENT_LABEL $C82A Default text height and width
LABEL $C82A Vec_Text_Height
COMMENT_LABEL $C82A Default text height
LABEL $C82B Vec_Text_Width
COMMENT_LABEL $C82B Default text width
LABEL $C82C Vec_Str_Ptr
COMMENT_LABEL $C82C Temporary string pointer for Print_Str
LABEL $C82E Vec_Counters
COMMENT_LABEL $C82E Six bytes of counters
LABEL $C82E Vec_Counter_1
COMMENT_LABEL $C82E First  counter byte
LABEL $C82F Vec_Counter_2
COMMENT_LABEL $C82F Second counter byte
LABEL $C830 Vec_Counter_3
COMMENT_LABEL $C830 Third  counter byte
LABEL $C831 Vec_Counter_4
COMMENT_LABEL $C831 Fourth counter byte
LABEL $C832 Vec_Counter_5
COMMENT_LABEL $C832 Fifth  counter byte
LABEL $C833 Vec_Counter_6
COMMENT_LABEL $C833 Sixth  counter byte
LABEL $C834 Vec_RiseRun_Tmp
COMMENT_LABEL $C834 Temp storage word for rise/run
LABEL $C836 Vec_Angle
COMMENT_LABEL $C836 Angle for rise/run and rotation calculations
LABEL $C837 Vec_Run_Index
COMMENT_LABEL $C837 Index pair for run
LABEL $C839 Vec_Rise_Index
COMMENT_LABEL $C839 Index pair for rise
LABEL $C83B Vec_RiseRun_Len
COMMENT_LABEL $C83B length for rise/run
LABEL $C83D Vec_Rfrsh
COMMENT_LABEL $C83D Refresh time (divided by 1.5MHz)
LABEL $C83D Vec_Rfrsh_lo
COMMENT_LABEL $C83D Refresh time low byte
LABEL $C83E Vec_Rfrsh_hi
COMMENT_LABEL $C83E Refresh time high byte
LABEL $C83F Vec_Music_Work
COMMENT_LABEL $C83F Music work buffer (14 bytes, backwards?)
LABEL $C842 Vec_Music_Wk_A
COMMENT_LABEL $C842 register 10
LABEL $C845 Vec_Music_Wk_7
COMMENT_LABEL $C845 register 7
LABEL $C846 Vec_Music_Wk_6
COMMENT_LABEL $C846 register 6
LABEL $C847 Vec_Music_Wk_5
COMMENT_LABEL $C847 register 5
LABEL $C84B Vec_Music_Wk_1
COMMENT_LABEL $C84B register 1
LABEL $C84D Vec_Freq_Table
COMMENT_LABEL $C84D Pointer to note-to-frequency table (normally $FC8D)
LABEL $C84F Vec_Max_Players
COMMENT_LABEL $C84F Maximum number of players for Select_Game
LABEL $C850 Vec_Max_Games
COMMENT_LABEL $C850 Maximum number of games for Select_Game
LABEL $C84F Vec_ADSR_Table
COMMENT_LABEL $C84F Storage for first music header word (ADSR table)
LABEL $C851 Vec_Twang_Table
COMMENT_LABEL $C851 Storage for second music header word ('twang' table)
LABEL $C853 Vec_Music_Ptr
COMMENT_LABEL $C853 Music data pointer
LABEL $C853 Vec_Expl_ChanA
COMMENT_LABEL $C853 Used by Explosion_Snd - bit for first channel used?
LABEL $C854 Vec_Expl_Chans
COMMENT_LABEL $C854 Used by Explosion_Snd - bits for all channels used?
LABEL $C855 Vec_Music_Chan
COMMENT_LABEL $C855 Current sound channel number for Init_Music
LABEL $C856 Vec_Music_Flag
COMMENT_LABEL $C856 Music active flag ($00=off $01=start $80=on)
LABEL $C857 Vec_Duration
COMMENT_LABEL $C857 Duration counter for Init_Music
LABEL $C858 Vec_Music_Twang
COMMENT_LABEL $C858 3 word 'twang' table used by Init_Music
LABEL $C858 Vec_Expl_1
COMMENT_LABEL $C858 Four bytes copied from Explosion_Snd's U-reg parameters
LABEL $C859 Vec_Expl_2
LABEL $C85A Vec_Expl_3
LABEL $C85B Vec_Expl_4
LABEL $C85C Vec_Expl_Chan
COMMENT_LABEL $C85C Used by Explosion_Snd - channel number in use?
LABEL $C85D Vec_Expl_ChanB
COMMENT_LABEL $C85D Used by Explosion_Snd - bit for second channel used?
LABEL $C85E Vec_ADSR_Timers
COMMENT_LABEL $C85E ADSR timers for each sound channel (3 bytes)
LABEL $C861 Vec_Music_Freq
COMMENT_LABEL $C861 Storage for base frequency of each channel (3 words)
LABEL $C867 Vec_Expl_Flag
COMMENT_LABEL $C867 Explosion_Snd initialization flag?
LABEL $C877 Vec_Expl_Timer
COMMENT_LABEL $C877 Used by Explosion_Snd
LABEL $C879 Vec_Num_Players
COMMENT_LABEL $C879 Number of players selected in Select_Game
LABEL $C87A Vec_Num_Game
COMMENT_LABEL $C87A Game number selected in Select_Game
LABEL $C87B Vec_Seed_Ptr
COMMENT_LABEL $C87B Pointer to 3-byte random number seed (=$C87D)
LABEL $C87D Vec_Random_Seed
COMMENT_LABEL $C87D Default 3-byte random number seed
LABEL $CBEA Vec_Default_Stk
COMMENT_LABEL $CBEA Default top-of-stack
LABEL $CBEB Vec_High_Score
COMMENT_LABEL $CBEB High score storage (7 bytes)
LABEL $CBF2 Vec_SWI3_Vector
COMMENT_LABEL $CBF2 SWI2/SWI3 interrupt vector (3 bytes)
LABEL $CBF2 Vec_SWI2_Vector
COMMENT_LABEL $CBF2 SWI2/SWI3 interrupt vector (3 bytes)
LABEL $CBF5 Vec_FIRQ_Vector
COMMENT_LABEL $CBF5 FIRQ interrupt vector (3 bytes)
LABEL $CBF8 Vec_IRQ_Vector
COMMENT_LABEL $CBF8 IRQ interrupt vector (3 bytes)
LABEL $CBFB Vec_SWI_Vector
COMMENT_LABEL $CBFB SWI/NMI interrupt vector (3 bytes)
LABEL $CBFB Vec_NMI_Vector
COMMENT_LABEL $CBFB SWI/NMI interrupt vector (3 bytes)
LABEL $CBFE Vec_Cold_Flag
COMMENT_LABEL $CBFE Cold start flag (warm start if = $7321)
LABEL $D000 VIA_port_b
COMMENT_LABEL $D000 VIA port B data I/O register
LABEL $D001 VIA_port_a
COMMENT_LABEL $D001 VIA port A data I/O register (handshaking)
LABEL $D002 VIA_DDR_b
COMMENT_LABEL $D002 VIA port B data direction register (0=input 1=output)
LABEL $D003 VIA_DDR_a
COMMENT_LABEL $D003 VIA port A data direction register (0=input 1=output)
LABEL $D004 VIA_t1_cnt_lo
COMMENT_LABEL $D004 VIA timer 1 count register lo (scale factor)
LABEL $D005 VIA_t1_cnt_hi
COMMENT_LABEL $D005 VIA timer 1 count register hi
LABEL $D006 VIA_t1_lch_lo
COMMENT_LABEL $D006 VIA timer 1 latch register lo
LABEL $D007 VIA_t1_lch_hi
COMMENT_LABEL $D007 VIA timer 1 latch register hi
LABEL $D008 VIA_t2_lo
COMMENT_LABEL $D008 VIA timer 2 count/latch register lo (refresh)
LABEL $D009 VIA_t2_hi
COMMENT_LABEL $D009 VIA timer 2 count/latch register hi
LABEL $D00A VIA_shift_reg
COMMENT_LABEL $D00A VIA shift register
LABEL $D00B VIA_aux_cntl
COMMENT_LABEL $D00B VIA auxiliary control register
LABEL $D00C VIA_cntl
COMMENT_LABEL $D00C VIA control register
LABEL $D00D VIA_int_flags
COMMENT_LABEL $D00D VIA interrupt flags register
LABEL $D00E VIA_int_enable
COMMENT_LABEL $D00E VIA interrupt enable register
LABEL $D00F VIA_port_a_nohs
COMMENT_LABEL $D00F VIA port A data I/O register (no handshaking)
LABEL $F000 Cold_Start
LABEL $F06C Warm_Start
LABEL $F14C Init_VIA
LABEL $F164 Init_OS_RAM
LABEL $F18B Init_OS
LABEL $F192 Wait_Recal
LABEL $F1A2 Set_Refresh
LABEL $F1AA DP_to_D0
LABEL $F1AF DP_to_C8
LABEL $F1B4 Read_Btns_Mask
LABEL $F1BA Read_Btns
LABEL $F1F5 Joy_Analog
LABEL $F1F8 Joy_Digital
LABEL $F256 Sound_Byte
LABEL $F259 Sound_Byte_x
LABEL $F25B Sound_Byte_raw
LABEL $F272 Clear_Sound
LABEL $F27D Sound_Bytes
LABEL $F284 Sound_Bytes_x
LABEL $F289 Do_Sound
LABEL $F28C Do_Sound_x
LABEL $F29D Intensity_1F
LABEL $F2A1 Intensity_3F
LABEL $F2A5 Intensity_5F
LABEL $F2A9 Intensity_7F
LABEL $F2AB Intensity_a
LABEL $F2BE Dot_ix_b
LABEL $F2C1 Dot_ix
LABEL $F2C3 Dot_d
LABEL $F2C5 Dot_here
LABEL $F2D5 Dot_List
LABEL $F2DE Dot_List_Reset
LABEL $F2E6 Recalibrate
LABEL $F2F2 Moveto_x_7F
LABEL $F2FC Moveto_d_7F
LABEL $F308 Moveto_ix_FF
LABEL $F30C Moveto_ix_7F
LABEL $F30E Moveto_ix_b
LABEL $F310 Moveto_ix
LABEL $F312 Moveto_d
LABEL $F34A Reset0Ref_D0
LABEL $F34F Check0Ref
LABEL $F354 Reset0Ref
LABEL $F35B Reset_Pen
LABEL $F36B Reset0Int
LABEL $F373 Print_Str_hwyx
LABEL $F378 Print_Str_yx
LABEL $F37A Print_Str_d
LABEL $F385 Print_List_hw
LABEL $F38A Print_List
LABEL $F38C Print_List_chk
LABEL $F391 Print_Ships_x
LABEL $F393 Print_Ships
LABEL $F3AD Mov_Draw_VLc_a
COMMENT_LABEL $F3AD count y x y x ...
LABEL $F3B1 Mov_Draw_VL_b
COMMENT_LABEL $F3B1 y x y x ...
LABEL $F3B5 Mov_Draw_VLcs
COMMENT_LABEL $F3B5 count scale y x y x ...
LABEL $F3B7 Mov_Draw_VL_ab
COMMENT_LABEL $F3B7 y x y x ...
LABEL $F3B9 Mov_Draw_VL_a
COMMENT_LABEL $F3B9 y x y x ...
LABEL $F3BC Mov_Draw_VL
COMMENT_LABEL $F3BC y x y x ...
LABEL $F3BE Mov_Draw_VL_d
COMMENT_LABEL $F3BE y x y x ...
LABEL $F3CE Draw_VLc
COMMENT_LABEL $F3CE count y x y x ...
LABEL $F3D2 Draw_VL_b
COMMENT_LABEL $F3D2 y x y x ...
LABEL $F3D6 Draw_VLcs
COMMENT_LABEL $F3D6 count scale y x y x ...
LABEL $F3D8 Draw_VL_ab
COMMENT_LABEL $F3D8 y x y x ...
LABEL $F3DA Draw_VL_a
COMMENT_LABEL $F3DA y x y x ...
LABEL $F3DD Draw_VL
COMMENT_LABEL $F3DD y x y x ...
LABEL $F3DF Draw_Line_d
COMMENT_LABEL $F3DF y x y x ...
LABEL $F404 Draw_VLp_FF
COMMENT_LABEL $F404 pattern y x pattern y x ... $01
LABEL $F408 Draw_VLp_7F
COMMENT_LABEL $F408 pattern y x pattern y x ... $01
LABEL $F40C Draw_VLp_scale
COMMENT_LABEL $F40C scale pattern y x pattern y x ... $01
LABEL $F40E Draw_VLp_b
COMMENT_LABEL $F40E pattern y x pattern y x ... $01
LABEL $F410 Draw_VLp
COMMENT_LABEL $F410 pattern y x pattern y x ... $01
LABEL $F434 Draw_Pat_VL_a
COMMENT_LABEL $F434 y x y x ...
LABEL $F437 Draw_Pat_VL
COMMENT_LABEL $F437 y x y x ...
LABEL $F439 Draw_Pat_VL_d
COMMENT_LABEL $F439 y x y x ...
LABEL $F46E Draw_VL_mode
COMMENT_LABEL $F46E mode y x mode y x ... $01
LABEL $F495 Print_Str
LABEL $F511 Random_3
LABEL $F517 Random
LABEL $F533 Init_Music_Buf
LABEL $F53F Clear_x_b
LABEL $F542 Clear_C8_RAM
COMMENT_LABEL $F542 never used by GCE carts?
LABEL $F545 Clear_x_256
LABEL $F548 Clear_x_d
LABEL $F550 Clear_x_b_80
LABEL $F552 Clear_x_b_a
LABEL $F55A Dec_3_Counters
LABEL $F55E Dec_6_Counters
LABEL $F563 Dec_Counters
LABEL $F56D Delay_3
COMMENT_LABEL $F56D 30 cycles
LABEL $F571 Delay_2
COMMENT_LABEL $F571 25 cycles
LABEL $F575 Delay_1
COMMENT_LABEL $F575 20 cycles
LABEL $F579 Delay_0
COMMENT_LABEL $F579 12 cycles
LABEL $F57A Delay_b
COMMENT_LABEL $F57A 5*B + 10 cycles
LABEL $F57D Delay_RTS
COMMENT_LABEL $F57D 5 cycles
LABEL $F57E Bitmask_a
LABEL $F584 Abs_a_b
LABEL $F58B Abs_b
LABEL $F593 Rise_Run_Angle
LABEL $F5D9 Get_Rise_Idx
LABEL $F5DB Get_Run_Idx
LABEL $F5EF Get_Rise_Run
LABEL $F5FF Rise_Run_X
LABEL $F601 Rise_Run_Y
LABEL $F603 Rise_Run_Len
LABEL $F610 Rot_VL_ab
LABEL $F616 Rot_VL
LABEL $F61F Rot_VL_Mode
LABEL $F62B Rot_VL_M_dft
LABEL $F65B Xform_Run_a
LABEL $F65D Xform_Run
LABEL $F661 Xform_Rise_a
LABEL $F663 Xform_Rise
LABEL $F67F Move_Mem_a_1
LABEL $F683 Move_Mem_a
LABEL $F687 Init_Music_chk
LABEL $F68D Init_Music
LABEL $F692 Init_Music_x
LABEL $F7A9 Select_Game
LABEL $F84F Clear_Score
LABEL $F85E Add_Score_a
LABEL $F87C Add_Score_d
LABEL $F8B7 Strip_Zeros
LABEL $F8C7 Compare_Score
LABEL $F8D8 New_High_Score
LABEL $F8E5 Obj_Will_Hit_u
LABEL $F8F3 Obj_Will_Hit
LABEL $F8FF Obj_Hit
LABEL $F92E Explosion_Snd
LABEL $FF9F Draw_Grid_VL
LABEL $FD0D music1
LABEL $FD1D music2
LABEL $FD81 music3
LABEL $FDD3 music4
LABEL $FE38 music5
LABEL $FE76 music6
LABEL $FEC6 music7
LABEL $FEF8 music8
LABEL $FF26 music9
LABEL $FF44 musica
LABEL $FF62 musicb
LABEL $FF7A musicc
LABEL $FF8F musicd
LABEL $F9F4 Char_Table
LABEL $FBD4 Char_Table_End
EQU $02 S_INTENSITY
EQU $01 S_XPOS
EQU $00 S_YPOS
LABEL $C826 intensityIndexNibble
COMMENT_LABEL $C826 low byte of "Vec_Loop_Count", this counter is increased
LABEL $C880 statusFlag
COMMENT_LABEL $C880 negative = link not established, 0 = I am primary, 1 = I am secondary
LABEL $C881 primary_structure
COMMENT_LABEL $C881 3 bytes
LABEL $C881 primary_pos
LABEL $C881 primary_y
LABEL $C882 primary_x
LABEL $C883 primary_intensity
LABEL $C884 secondary_structure
COMMENT_LABEL $C884 3 bytes
LABEL $C884 secondary_pos
LABEL $C884 secondary_y
LABEL $C885 secondary_x
LABEL $C886 secondary_intensity
LABEL $C887 joy_y
COMMENT_LABEL $C887 contains digital joytick position Y, +1 = up, -1 = down, 0 = no move
LABEL $C888 joy_x
COMMENT_LABEL $C888 contains digital joytick position X, +1 = right, -1 = left, 0 = no move
LABEL $C889 jumper
COMMENT_LABEL $C889 contains indirect jump addresses used in main loop
LABEL $CBF0 _CBF0
COMMENT_LABEL $CBF0 have not figured out what this is...
EQU $0B Copyright_Len
LABEL $0011 no_music
LABEL $01D3 start
LABEL $0017 syncVectrex_3bytes
LABEL $0195 JoytickFFCommunication_A
LABEL $0166 write_A_toJoy2
LABEL $0041 otherWasFound
LABEL $0150 wait_CA1_Timer_D
LABEL $00CF secondaryVectrexCommunication
EQU $51 next_byte_communication
LABEL $014D wait_CA1_Timer_01ff
LABEL $0155 vl_test0155
LABEL $0160 vl_test0160
LABEL $01F1 init_jumper
LABEL $01DE main_loop
LABEL $03AB queryInputPort0
LABEL $01F8 init_vars_main
LABEL $021F no_link
LABEL $0218 we_are_secondary
LABEL $023B primary_main
LABEL $0269 secondary_main
LABEL $0368 no_link_string
COMMENT_LABEL $0368 text "NO LINK" in format: %Y %X %M
LABEL $02F1 draw_vector_list
LABEL $03FF intensity_blink
LABEL $0299 check_input_port0
LABEL $0334 you
COMMENT_LABEL $0334 text "YOU" in format: %Y %X %M
LABEL $02BE draw_players
LABEL $02A9 increase_intensity
LABEL $02B2 check_digital_pos
LABEL $0317 triangle
COMMENT_LABEL $0317 triangle list in format: %Y %X %M
LABEL $0324 diamond
COMMENT_LABEL $0324 diamond list in format: %Y %X %M
LABEL $02F3 display_next_vector
LABEL $030A timerLoop
LABEL $03BC waitLoopV
LABEL $03D5 yReadDone
LABEL $03E2 waitLoopH
LABEL $03FB xReadDone
LABEL $040F *
COMMENT_LINE $0000 Note:
COMMENT_LINE $0000 This is a disassembly of a binary file I got from a fellow vectrexian.
COMMENT_LINE $0000 The original file was programmed by Alex Herbert
COMMENT_LINE $0000 I was assured that Alex had given is consent in making the file available,
COMMENT_LINE $0000 but sadly I had never the opportunity to get in contact with Alex himself.
COMMENT_LINE $0000 Alex: if you do not wish to share this file, please contact me and I will remove it.
COMMENT_LINE $0000 veclink V1 in Port 1
COMMENT_LINE $0000 button 4 (bit 7) is triggering a VIA interrupt (CA1)
COMMENT_LINE $0000 which is used to synchronize the communication
COMMENT_LINE $0000 with button 4 connected one vectrex can trigger an interrupt on the other
COMMENT_LINE $0000 the actual data is transported
COMMENT_LINE $0000 via bit 5 and 6 (on what I call the primary vectrex) (Port 1: Button 2 and 3)
COMMENT_LINE $0000 via bit 4 and 5 (on what I call the secondary vectrex) (Port 1: Button 1 and 2)
COMMENT_LINE $0000 a quarter of a parallel connection :-)
COMMENT_LINE $0000 the communication seems to be "bi" directional
COMMENT_LINE $0000 sending and data sets CA1, the other side waits for CA1
COMMENT_LINE $0000 and immediately sorts out the data of the 2 bits
COMMENT_LINE $0000 and with acknowledgment sends its own data back... and so forth
COMMENT_LINE $0000 cable schematics:
COMMENT_LINE $0000 Vectrex A                Vectrex B
COMMENT_LINE $0000 1 |--------------------------| 4
COMMENT_LINE $0000 |
COMMENT_LINE $0000 |
COMMENT_LINE $0000 >
COMMENT_LINE $0000 <   680 Ohm Resistor
COMMENT_LINE $0000 >
COMMENT_LINE $0000 <
COMMENT_LINE $0000 |
COMMENT_LINE $0000 |
COMMENT_LINE $0000 8 |--------------------------| 8
COMMENT_LINE $0000 |
COMMENT_LINE $0000 |
COMMENT_LINE $0000 >
COMMENT_LINE $0000 <   680 Ohm Resistor
COMMENT_LINE $0000 >
COMMENT_LINE $0000 <
COMMENT_LINE $0000 |
COMMENT_LINE $0000 |
COMMENT_LINE $0000 4 |--------------------------| 3
COMMENT_LINE $0000 2 |--------------------------| 1
COMMENT_LINE $0000 3 |--------------------------| 2
COMMENT_LINE $0000 Additional information that was made available to me:
COMMENT_LINE $0000 (quotation)
COMMENT_LINE $0000 "
COMMENT_LINE $0000 According To the information I have received from Alex Herbert there are several versions of the cable.
COMMENT_LINE $0000 Depending on which of Alex's libraries you use the following will be true.
COMMENT_LINE $0000 Earlier version of the cable. The I/O on pin 4 is harder to drive than pins 1,2,3 so the pull up resistors
COMMENT_LINE $0000 were used to try and correct the voltage levels, but - even then it was still iffy.
COMMENT_LINE $0000 The new cable just avoids this by not using pin 4. It means we have 1 less pin for data which should in theory
COMMENT_LINE $0000 reduce the maximum bandwidth, but I was able to optimize it quite well and didn't loose much performance.
COMMENT_LINE $0000 This cable has been performing rock solid.
COMMENT_LINE $0000 "
COMMENT_LINE $0000 Malban - Thoughts:
COMMENT_LINE $0000 Since I have no cable of my own, I can't do any further tests.
COMMENT_LINE $0000 The "linkage" routines below do sort of work (most of the time)
COMMENT_LINE $0000 as reported by Alex:
COMMENT_LINE $0000 "...Earlier version of the cable. The I/O on pin 4 is harder to drive than pins 1,2,3 so the pull
COMMENT_LINE $0000 up resistors were used to try and correct the voltage levels, but even then it was still iffy."
COMMENT_LINE $0000 The linkage thus seems to be not to stable.
COMMENT_LINE $0000 Emulation of the above cable also results sometimes in "broken" links - I regard that mostly as
COMMENT_LINE $0000 syncing problems of two emulators running in two different threads, but I can't help to wonder...
COMMENT_LINE $0000 examining the core communication routine, I noticed the:
COMMENT_LINE $0000 ora      #$80
COMMENT_LINE $0000 with every data transfer that is done, my first guess was, that setting the high bit
COMMENT_LINE $0000 should = the CA1 on the other vectrex to do the actual syncing.
COMMENT_LINE $0000 (this is what my old comments still state - but this is WRONG!)
COMMENT_LINE $0000 BUT the cable (look above) is "crossed", so setting bit 4 on the one vectrex which is
COMMENT_LINE $0000 sending data does not achieve any CA1 interrupt on the other side.
COMMENT_LINE $0000 Setting bit 4 on the primary vectrex will result in bit 3 of the secondary vectrex
COMMENT_LINE $0000 while setting bit 4 on the secondary vectrex will result in bit 1 being = on the primary.
COMMENT_LINE $0000 (all bits in regard to above picture, not the actual bits of port A of PSG)
COMMENT_LINE $0000 So - Question:             Is the below given communication routine actually buggy?
COMMENT_LINE $0000 or
COMMENT_LINE $0000 Question alternative:      What am I missing?
COMMENT_LINE $0000 Tentive answer from Malban:
COMMENT_LINE $0000 My guess is, that the ora $80 are left overs from an "older" example routine and an even older veclink cable (v0.9?).
COMMENT_LINE $0000 The actual syncing is done in "JoytickFFCommunication_A", which sends "$ff" to the other vectrex, which inherently obviously
COMMENT_LINE $0000 will = the CA1 flag, since all bits receive a 1.
COMMENT_LINE $0000 This theory is backed up by the fact that you can comment out all of the ora $80 and the routine still works
COMMENT_LINE $0000 equally well (or not well in the case of a slow emulator)
COMMENT_LINE $0000 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $0000 this file contains includes for vectrex BIOS functions and variables      ;
COMMENT_LINE $0000 it was written by Bruce Tomlin, slighte changed by Malban                 ;
COMMENT_LINE $0000 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
COMMENT_LINE $0000 $C839   ;Pointer to copyright string during startup
COMMENT_LINE $0000 $C83B   ;High score cold-start flag (=0 if valid)
COMMENT_LINE $0000 $C83C   ;temp byte
COMMENT_LINE $0000 $C843   ;        register 9
COMMENT_LINE $0000 $C844   ;        register 8
COMMENT_LINE $0000 $C848   ;        register 4
COMMENT_LINE $0000 $C849   ;        register 3
COMMENT_LINE $0000 $C84A   ;        register 2
COMMENT_LINE $0000 $C84C   ;        register 0
COMMENT_LINE $0000 $C85E   ;Scratch 'score' storage for Display_Option (7 bytes)
COMMENT_LINE $0000 $C868...$C876   ;Unused?
COMMENT_LINE $0000 $C878   ;Unused?
COMMENT_LINE $0000 $C880 - $CBEA is user RAM  ;
COMMENT_LINE $0000 0 sample/hold (0=enable  mux 1=disable mux)
COMMENT_LINE $0000 1 mux sel 0
COMMENT_LINE $0000 2 mux sel 1
COMMENT_LINE $0000 3 sound BC1
COMMENT_LINE $0000 4 sound BDIR
COMMENT_LINE $0000 5 comparator input
COMMENT_LINE $0000 6 external device (slot pin 35) initialized to input
COMMENT_LINE $0000 7 /RAMP
COMMENT_LINE $0000 0 PA latch enable
COMMENT_LINE $0000 1 PB latch enable
COMMENT_LINE $0000 2 \                     110=output to CB2 under control of phase 2 clock
COMMENT_LINE $0000 3  > shift register control     (110 is the only mode used by the Vectrex ROM)
COMMENT_LINE $0000 4 /
COMMENT_LINE $0000 5 0=t2 one shot                 1=t2 free running
COMMENT_LINE $0000 6 0=t1 one shot                 1=t1 free running
COMMENT_LINE $0000 7 0=t1 disable PB7 output       1=t1 enable PB7 output
COMMENT_LINE $0000 0 CA1 control     CA1 -> SW7    0=IRQ on low 1=IRQ on high
COMMENT_LINE $0000 1 \
COMMENT_LINE $0000 2  > CA2 control  CA2 -> /ZERO  110=low 111=high
COMMENT_LINE $0000 3 /
COMMENT_LINE $0000 4 CB1 control     CB1 -> NC     0=IRQ on low 1=IRQ on high
COMMENT_LINE $0000 5 \
COMMENT_LINE $0000 6  > CB2 control  CB2 -> /BLANK 110=low 111=high
COMMENT_LINE $0000 7 /
COMMENT_LINE $0000 bit                             cleared by
COMMENT_LINE $0000 0 CA2 interrupt flag            reading or writing port A I/O
COMMENT_LINE $0000 1 CA1 interrupt flag            reading or writing port A I/O
COMMENT_LINE $0000 2 shift register interrupt flag reading or writing shift register
COMMENT_LINE $0000 3 CB2 interrupt flag            reading or writing port B I/O
COMMENT_LINE $0000 4 CB1 interrupt flag            reading or writing port A I/O
COMMENT_LINE $0000 5 timer 2 interrupt flag        read t2 low or write t2 high
COMMENT_LINE $0000 6 timer 1 interrupt flag        read t1 count low or write t1 high
COMMENT_LINE $0000 7 IRQ status flag               write logic 0 to IER or IFR bit
COMMENT_LINE $0000 0 CA2 interrupt enable
COMMENT_LINE $0000 1 CA1 interrupt enable
COMMENT_LINE $0000 2 shift register interrupt enable
COMMENT_LINE $0000 3 CB2 interrupt enable
COMMENT_LINE $0000 4 CB1 interrupt enable
COMMENT_LINE $0000 5 timer 2 interrupt enable
COMMENT_LINE $0000 6 timer 1 interrupt enable
COMMENT_LINE $0000 7 IER set/clear control
COMMENT_LINE $0000 Rot_VL_dft      EQU     $F637   ;
COMMENT_LINE $0000 Rot_VL_ab       EQU     $F610   ;
COMMENT_LINE $0000 Rot_VL          EQU     $F616   ;
COMMENT_LINE $0000 Rot_VL_Mode_a   EQU     $F61F   ;
COMMENT_LINE $0000 Rot_VL_Mode     EQU     $F62B   ;
COMMENT_LINE $0000 Rot_VL_dft      EQU     $F637   ;
COMMENT_LINE $0000 with every call WaitRecal, it is used below as an
COMMENT_LINE $0000 offset for intensity levels of the "you" sign
COMMENT_LINE $0000 GCS Copyright
COMMENT $0000 it seems communication VLinkCable is done via
COMMENT_LINE $000B Start music pointer
COMMENT $000B Start music pointer
COMMENT_LINE $000D end of header
COMMENT $000D end of header
COMMENT_LINE $000E start of cartridge code!
COMMENT $000E start of cartridge code!
FORCE_SYMBOL $000E start
COMMENT_LINE $0017 this routine syncs 3 bytes *2 (both structures) (actually the number of bytes between primary_structure and secondary_structure)
COMMENT_LINE $0017 while doing the syncing the link is continually tested if it still in working order
COMMENT_LINE $0017 this routine also sets the status flag of the link connection
COMMENT_LINE $0017 negative = link not established, 0 = I am primary, 1 = I am secondary
COMMENT $0017 setup DP
FORCE_NO_SYMBOL $0017
COMMENT $001B reading and writing from the view of primary vectrex
FORCE_SYMBOL $001B primary_structure
COMMENT $001E read data to this address [data original from secondary vectrex]
FORCE_SYMBOL $001E secondary_structure
COMMENT $0022 default status: link is broken (needed for a "hard" exit in the subroutines)
FORCE_NO_SYMBOL $0022
COMMENT $0024 store the status of the connection
FORCE_SYMBOL $0024 statusFlag
COMMENT $0027 sends a "ff" to the other vectrex and receives one "byte" - also tests the link
FORCE_SYMBOL $0027 JoytickFFCommunication_A
COMMENT $002A remember value got from joystick port 2
COMMENT $002C 1011 1111 test byte to look if we are primary or secondary
FORCE_NO_SYMBOL $002C
COMMENT_LINE $002E upper bit 3 is "cross"-connected to either bit 2 or 4, the later triggers a CA1
COMMENT_LINE $002E examining the result tells us if we are secondary or primary
COMMENT $002E tell the other vectrex
FORCE_SYMBOL $002E write_A_toJoy2
COMMENT $0031 0001 1000 ; SHIFT mode = 110 - SHIFT out under control of system clock
FORCE_NO_SYMBOL $0031
COMMENT $0033 (bit 6+7 = 00) timer one shot mode ramp not controlled by bit 7 of VIA B
FORCE_SYMBOL $0033 VIA_aux_cntl
COMMENT $0035 get last read value from joystick port
COMMENT $0037 (equal to CA1 interrupt)
FORCE_NO_SYMBOL $0037
COMMENT $0039 if bit 7 is set, branch [other vectrex was already found]
COMMENT $003B wait a "long time" for other vectrex
FORCE_NO_SYMBOL $003B
COMMENT $003E if return happens we found a vectrex,
FORCE_SYMBOL $003E wait_CA1_Timer_D
COMMENT_LINE $0041 if there is NO return, than the subroutine
COMMENT_LINE $0041 went straight ahead to "our" caller and the next instruction is never reached!
COMMENT_LINE $0041 send ff and read one "byte"
COMMENT $0041 if vectrex is not found, the subroutine returns directly
FORCE_SYMBOL $0041 JoytickFFCommunication_A
COMMENT $0044 only bits of port 2
FORCE_NO_SYMBOL $0044
COMMENT $0046 upper halfbyte ($f0) without CA1 ($80)
FORCE_NO_SYMBOL $0046
COMMENT_LINE $0048 this is the "examining" of the "#$BF" that was send from the other side...
COMMENT_LINE $0048 if we recieved x000 xxxx (from the sent 1011 xxxx), than we are primary
COMMENT_LINE $0048 if not, than we are secondary
COMMENT $004C $1000 1111, triger CA1 on other vectrex, 000 data, 1111 "buttons" of joy 1 (ignore)
FORCE_NO_SYMBOL $004C
COMMENT_LINE $004E we are primary!
COMMENT_LINE $004E which puts the other vectrex as secondary
COMMENT_LINE $004E receive bit 7 and 6 [rr00 0000] (and send nothing)
COMMENT $004E the other vectrex receives a 000 as data, which will be "ignored"
FORCE_SYMBOL $004E write_A_toJoy2
FORCE_SYMBOL $0051 wait_CA1_Timer_01ff
FORCE_SYMBOL $0054 JoytickFFCommunication_A
COMMENT_LINE $0057 only bit 5 and 6 contain data
COMMENT $0057 from data
FORCE_NO_SYMBOL $0057
COMMENT $0059 0xx0 0000 -> xx00 0000, correct bit position
COMMENT $005A store received upper two bits in y
FORCE_NO_SYMBOL $005A
COMMENT_LINE $005C load data to transport
COMMENT $005C to data
FORCE_NO_SYMBOL $005C
COMMENT $005E put bits to 5 and 6 xx00 0000 -> 0xx0 0000
COMMENT $005F only bit 5 and 6 contain data
FORCE_NO_SYMBOL $005F
COMMENT $0061 = bit 7 (CA1 of other vectrex)
FORCE_NO_SYMBOL $0061
COMMENT_LINE $0063 receive bit 5 and 4 [00rr 0000]
COMMENT $0063 send bit 7 and 6 [ww00 0000]
FORCE_SYMBOL $0063 write_A_toJoy2
FORCE_SYMBOL $0066 wait_CA1_Timer_01ff
FORCE_SYMBOL $0069 JoytickFFCommunication_A
COMMENT $006C only bit 5 and 6 contain data
FORCE_NO_SYMBOL $006C
COMMENT $006E 0xx0 0000 -> 00xx 0000, correct bit position
COMMENT $006F and combine the two bits with already received data
FORCE_NO_SYMBOL $006F
COMMENT $0071 write data
FORCE_NO_SYMBOL $0071
COMMENT $0073 get next data to be sent
FORCE_NO_SYMBOL $0073
COMMENT $0075 put bits to 5 and 6 00xx 0000 -> 0xx0 0000
COMMENT $0076 only bit 5 and 6 contain data
FORCE_NO_SYMBOL $0076
COMMENT $0078 = bit 7 (CA1 of other vectrex)
FORCE_NO_SYMBOL $0078
COMMENT_LINE $007A receive bit 3 and 2 [0000 rr00]
COMMENT $007A send bit 5 and 4 [00ww 0000]
FORCE_SYMBOL $007A write_A_toJoy2
FORCE_SYMBOL $007D wait_CA1_Timer_01ff
FORCE_SYMBOL $0080 JoytickFFCommunication_A
COMMENT $0083 only bit 5 and 6 contain data
FORCE_NO_SYMBOL $0083
COMMENT $0087 0xx0 0000 -> 0000 xx00, correct bit position
COMMENT $0088 and combine the two bits with already received data
FORCE_NO_SYMBOL $0088
COMMENT $008A write data
FORCE_NO_SYMBOL $008A
COMMENT $008C get next data to be sent
FORCE_NO_SYMBOL $008C
COMMENT $0090 put bits to 5 and 6 0000 xx00 -> 0xx0 0000
COMMENT $0091 only bit 5 and 6 contain data
FORCE_NO_SYMBOL $0091
COMMENT $0093 = bit 7 (CA1 of other vectrex)
FORCE_NO_SYMBOL $0093
COMMENT_LINE $0095 receive bit 1 and 0 [0000 00rr]
COMMENT $0095 send bit 3 and 2 [0000 ww00]
FORCE_SYMBOL $0095 write_A_toJoy2
FORCE_SYMBOL $0098 wait_CA1_Timer_01ff
FORCE_SYMBOL $009B JoytickFFCommunication_A
COMMENT $009E only bit 5 and 6 contain data
FORCE_NO_SYMBOL $009E
COMMENT $00A4 0xx0 0000 -> 0000 00xx, correct bit position
COMMENT $00A5 and combine the two bits with already received data
FORCE_NO_SYMBOL $00A5
COMMENT $00A7 write data, inc y
COMMENT $00A9 get next data to be sent, inc x
COMMENT $00AF put bits to 5 and 6 0000 00xx -> 0xx0 0000
COMMENT $00B0 only bit 5 and 6 contain data
FORCE_NO_SYMBOL $00B0
COMMENT $00B2 = bit 7 (CA1 of other vectrex)
FORCE_NO_SYMBOL $00B2
COMMENT_LINE $00B4 (also receive bit 7 and 6 [rr00 0000] - if any avalable)
COMMENT $00B4 send bit 1 and 0 [0000 00ww]
FORCE_SYMBOL $00B4 write_A_toJoy2
COMMENT_LINE $00B7 (3 bytes)
COMMENT $00B7 did we finish sending all data?
FORCE_SYMBOL $00B7 secondary_structure
COMMENT $00BA no, than go on sending
COMMENT $00BC dont know, indicator second primary?
FORCE_SYMBOL $00BC statusFlag
COMMENT $00BF one last sync for good will?
FORCE_SYMBOL $00BF wait_CA1_Timer_01ff
FORCE_SYMBOL $00C2 JoytickFFCommunication_A
COMMENT $00C5 restore some sensible timer settings?
FORCE_NO_SYMBOL $00C5
COMMENT $00C8 VIA timer lo -> hi
FORCE_SYMBOL $00C8 VIA_t1_cnt_lo
COMMENT $00CA clean up aux VIA register
FORCE_NO_SYMBOL $00CA
COMMENT_LINE $00CC (bit 6+7 = 10) timer one shot mode ramp controlled by bit 7 of VIA B
COMMENT $00CC 1001 1000 SHIFT mode = 110 - SHIFT out under control of system clock
FORCE_SYMBOL $00CC VIA_aux_cntl
COMMENT $00CE done
COMMENT_LINE $00CF a) read and write addresses are switched
COMMENT_LINE $00CF b) for data transport bit 4 and 5 are used instead of 5 and 6
COMMENT_LINE $00CF send bit 7 and 6 [ww00 0000]
COMMENT_LINE $00CF receive bit 7 and 6 [rr00 0000]
COMMENT_LINE $00CF load data to transport
COMMENT $00CF secondary communication has two quirks
FORCE_NO_SYMBOL $00CF
COMMENT $00D1 put bits to 4 and 5 xx00 0000 -> 00xx 0000
COMMENT $00D3 only bit 4 and 5 contain data
FORCE_NO_SYMBOL $00D3
COMMENT $00D5 = bit 7 (CA1 of other vectrex)
FORCE_NO_SYMBOL $00D5
FORCE_SYMBOL $00D7 write_A_toJoy2
FORCE_SYMBOL $00DA wait_CA1_Timer_01ff
FORCE_SYMBOL $00DD JoytickFFCommunication_A
COMMENT $00E0 only bit 4 and 5 contain data
FORCE_NO_SYMBOL $00E0
COMMENT $00E3 00xx 0000 -> xx00 0000, correct bit position
COMMENT $00E4 store received upper two bits in x
FORCE_NO_SYMBOL $00E4
COMMENT_LINE $00E6 receive bit 5 and 4 [00rr 0000]
COMMENT_LINE $00E6 get next data to be sent
COMMENT $00E6 send bit 5 and 4 [00ww 0000]
FORCE_NO_SYMBOL $00E6
COMMENT $00E8 only bit 4 and 5 contain data
FORCE_NO_SYMBOL $00E8
COMMENT $00EA = bit 7 (CA1 of other vectrex)
FORCE_NO_SYMBOL $00EA
FORCE_SYMBOL $00EC write_A_toJoy2
FORCE_SYMBOL $00EF wait_CA1_Timer_01ff
FORCE_SYMBOL $00F2 JoytickFFCommunication_A
COMMENT $00F5 only bit 4 and 5 contain data
FORCE_NO_SYMBOL $00F5
COMMENT $00F7 and combine the two bits with already received data
FORCE_NO_SYMBOL $00F7
COMMENT $00F9 write data
FORCE_NO_SYMBOL $00F9
COMMENT_LINE $00FB receive bit 3 and 2 [0000 rr00]
COMMENT_LINE $00FB get next data to be sent
COMMENT $00FB send bit 3 and 2 [0000 ww00]
FORCE_NO_SYMBOL $00FB
COMMENT $00FE put bits to 4 and 5 0000 xx00 -> 00xx 0000
COMMENT $00FF only bit 4 and 5 contain data
FORCE_NO_SYMBOL $00FF
COMMENT $0101 = bit 7 (CA1 of other vectrex)
FORCE_NO_SYMBOL $0101
FORCE_SYMBOL $0103 write_A_toJoy2
FORCE_SYMBOL $0106 wait_CA1_Timer_01ff
FORCE_SYMBOL $0109 JoytickFFCommunication_A
COMMENT $010C only bit 4 and 5 contain data
FORCE_NO_SYMBOL $010C
COMMENT $010F 00xx 0000 -> 0000 xx00, correct bit position
COMMENT $0110 and combine the two bits with already received data
FORCE_NO_SYMBOL $0110
COMMENT $0112 write data
FORCE_NO_SYMBOL $0112
COMMENT_LINE $0114 receive bit 1 and 0 [0000 00rr]
COMMENT_LINE $0114 get next data to be sent, and inc y
COMMENT $0114 send bit 1 and 0 [0000 00ww]
COMMENT $0119 put bits to 4 and 5 0000 00xx -> 00xx 0000
COMMENT $011A only bit 4 and 5 contain data
FORCE_NO_SYMBOL $011A
COMMENT $011C = bit 7 (CA1 of other vectrex)
FORCE_NO_SYMBOL $011C
FORCE_SYMBOL $011E write_A_toJoy2
FORCE_SYMBOL $0121 wait_CA1_Timer_01ff
FORCE_SYMBOL $0124 JoytickFFCommunication_A
COMMENT $0127 only bit 4 and 5 contain data
FORCE_NO_SYMBOL $0127
COMMENT $012C 0000 00xx -> 0000 xx00, correct bit position
COMMENT $012D and combine the two bits with already received data
FORCE_NO_SYMBOL $012D
COMMENT $012F write data, inc x
COMMENT_LINE $0131 (3 bytes)
COMMENT $0131 did we finish sending all data?
FORCE_SYMBOL $0131 secondary_structure
COMMENT $0136 = bit 7 (CA1 of other vectrex)
FORCE_NO_SYMBOL $0136
COMMENT $0138 one last sync for good will?
FORCE_SYMBOL $0138 write_A_toJoy2
FORCE_SYMBOL $013B JoytickFFCommunication_A
COMMENT $013E dont know, indicator second primary?
FORCE_SYMBOL $013E statusFlag
COMMENT $0141 restore some sensible timer settings?
FORCE_NO_SYMBOL $0141
COMMENT $0144 VIA timer1 lo -> hi
FORCE_SYMBOL $0144 VIA_t1_cnt_lo
COMMENT_LINE $0146 VIA timer 2 lo -> hi ???
COMMENT $0146 what is that for?
FORCE_SYMBOL $0146 VIA_t2_lo
COMMENT_LINE $0148 (bit 6+7 = 10) timer one shot mode ramp controlled by bit 7 of VIA B
COMMENT_LINE $0148 clean up aux VIA register
COMMENT $0148 1001 1000 SHIFT mode = 110 - SHIFT out under control of system clock
FORCE_NO_SYMBOL $0148
FORCE_SYMBOL $014A VIA_aux_cntl
COMMENT_LINE $014D with timeout after 0x01ff cylces
COMMENT $014D wait for interrupt CA1
FORCE_NO_SYMBOL $014D
COMMENT_LINE $0150 with timeout given in D (Timer 16 bit)
COMMENT_LINE $0150 init timer
COMMENT_LINE $0150 store given parameter to A to timer 1 low [latch (reg 6 is written]
COMMENT_LINE $0150 B to timer 1 high [latch reg 6 is transfered to reg 4]
COMMENT_LINE $0150 B is also transfere3d to reg 7 high latch
COMMENT_LINE $0150 resets interrupt flag
COMMENT_LINE $0150 store timer values
COMMENT $0150 wait for interrupt CA1
FORCE_SYMBOL $0150 VIA_t1_cnt_lo
COMMENT $0152 interrupt test flags
FORCE_NO_SYMBOL $0152
COMMENT $0155 test interrupt flag register ($d) for #$40 (Timer 1)
FORCE_SYMBOL $0155 VIA_int_flags
COMMENT $0157 if = -> branch, timeout was reached
COMMENT $0159 test interrupt flag register ($d) for #$02 (CA1)
FORCE_SYMBOL $0159 VIA_int_flags
COMMENT_LINE $015B connecting another vectrex one can thus
COMMENT_LINE $015B generate an interupt from that other vectrex via joystick port
COMMENT_LINE $015B if CA1 interrupt not detected  - go on trying
COMMENT $015B CA1 is connected to Joystick Port 2 Button 4
COMMENT_LINE $015D clear 0x02 to VIA interrupt flag register by writing 1
COMMENT $015D CA1 interrupt was detected
FORCE_SYMBOL $015D VIA_int_flags
COMMENT $015F go back
COMMENT_LINE $0160 clean up aux VIA register
COMMENT $0160 timeout happened
FORCE_NO_SYMBOL $0160
COMMENT_LINE $0162 (bit 6+7 = 10) timer one shot mode ramp controlled by bit 7 of VIA B
COMMENT $0162 1001 1000 SHIFT mode = 110 - SHIFT out under control of system clock
FORCE_SYMBOL $0162 VIA_aux_cntl
COMMENT $0164 is this a double RTS? go back 2 subroutine calls?
COMMENT_LINE $0166 write value to joystick port 2 (buttons)
COMMENT_LINE $0166 Port A of PSG is kept in OUTPUT mode
COMMENT_LINE $0166 store given value on stack
COMMENT $0166 value given in A
COMMENT_LINE $0168 Register 7 of PSG
COMMENT $0168 Latch Reg $07 of PSG
FORCE_NO_SYMBOL $0168
COMMENT $016A VIA A = 0x07 (DAC)
FORCE_SYMBOL $016A VIA_port_a
FORCE_NO_SYMBOL $016C
COMMENT $016F VIA Port B = 99, mux disabled, RAMP disabled, BC1/BDIR = 11 (Latch address)
FORCE_SYMBOL $016F VIA_port_b
COMMENT $0171 VIA Port B = 81, mux disabled, RAMP disabled, BC1/BDIR = 00 (PSG inactive)
FORCE_SYMBOL $0171 VIA_port_b
COMMENT_LINE $0173 $7f to VIA A (DAC) $7f = 0111 1111, disable all noise and tone in psg,
COMMENT $0173 write value of $7f to reg $07 (latched)
FORCE_NO_SYMBOL $0173
COMMENT_LINE $0175 $7f to VIA A (DAC)
COMMENT $0175 ENABLE OUTPUT on port A of PSG (port B irrelevant since it is a 8912)
FORCE_SYMBOL $0175 VIA_port_a
FORCE_NO_SYMBOL $0177
COMMENT $017A VIA Port B = 91, mux disabled, RAMP disabled, BC1/BDIR = 10 (Write to PSG)
FORCE_SYMBOL $017A VIA_port_b
COMMENT $017C VIA Port B = 81, mux disabled, RAMP disabled, BC1/BDIR = 00 (PSG inactive)
FORCE_SYMBOL $017C VIA_port_b
COMMENT $017E Latch Reg $E of PSG (Port A)
FORCE_NO_SYMBOL $017E
COMMENT $0180 $0e to VIA A (DAC)
FORCE_SYMBOL $0180 VIA_port_a
FORCE_NO_SYMBOL $0182
COMMENT $0185 VIA Port B = 99, mux disabled, RAMP disabled, BC1/BDIR = 11 (Latch address)
FORCE_SYMBOL $0185 VIA_port_b
COMMENT $0187 VIA Port B = 81, mux disabled, RAMP disabled, BC1/BDIR = 00 (PSG inactive)
FORCE_SYMBOL $0187 VIA_port_b
COMMENT_LINE $0189 read value from stack
COMMENT $0189 write A to port
COMMENT $018B output value to via VIA port A to Port A of PSG (Joystick buttons)
FORCE_SYMBOL $018B VIA_port_a
FORCE_NO_SYMBOL $018D
COMMENT $0190 VIA Port B = 91, mux disabled, RAMP disabled, BC1/BDIR = 10 (Write to PSG)
FORCE_SYMBOL $0190 VIA_port_b
COMMENT $0192 VIA Port B = 81, mux disabled, RAMP disabled, BC1/BDIR = 00 (PSG inactive)
FORCE_SYMBOL $0192 VIA_port_b
COMMENT_LINE $0195 setup joyport communication
COMMENT_LINE $0195 sends $ff to Joystick 2
COMMENT_LINE $0195 $ff inherently has bit 7 set, which also triggers CA1 on other vectrex
COMMENT_LINE $0195 and reads afterwards joystick port 2
COMMENT_LINE $0195 value of read is kept in A
COMMENT_LINE $0195 PSG port A is kept in INPUT mode
COMMENT_LINE $0195 Latch Reg $07 of PSG
COMMENT_LINE $0195 Register 7 of PSG
FORCE_NO_SYMBOL $0195
COMMENT $0197 VIA A = 0x07 (DAC)
FORCE_SYMBOL $0197 VIA_port_a
FORCE_NO_SYMBOL $0199
COMMENT $019C VIA Port B = 99, mux disabled, RAMP disabled, BC1/BDIR = 11 (Latch address)
FORCE_SYMBOL $019C VIA_port_b
COMMENT $019E VIA Port B = 81, mux disabled, RAMP disabled, BC1/BDIR = 00 (PSG inactive)
FORCE_SYMBOL $019E VIA_port_b
COMMENT_LINE $01A0 $3f to VIA A (DAC) $3f = 0011 1111, disable all noise and tone in psg,
COMMENT $01A0 write value of $3f to reg $07 (latched)
FORCE_NO_SYMBOL $01A0
COMMENT $01A2 enable INPUT on port A of PSG (port B irrelevant since it is a 8912)
FORCE_SYMBOL $01A2 VIA_port_a
FORCE_NO_SYMBOL $01A4
COMMENT $01A7 VIA Port B = 91, mux disabled, RAMP disabled, BC1/BDIR = 10 (Write to PSG)
FORCE_SYMBOL $01A7 VIA_port_b
COMMENT $01A9 VIA Port B = 81, mux disabled, RAMP disabled, BC1/BDIR = 00 (PSG inactive)
FORCE_SYMBOL $01A9 VIA_port_b
COMMENT $01AB Latch Reg $E of PSG (Port A)
FORCE_NO_SYMBOL $01AB
COMMENT $01AD $0e to VIA A (DAC)
FORCE_SYMBOL $01AD VIA_port_a
FORCE_NO_SYMBOL $01AF
COMMENT $01B2 VIA Port B = 99, mux disabled, RAMP disabled, BC1/BDIR = 11 (Latch address)
FORCE_SYMBOL $01B2 VIA_port_b
COMMENT $01B4 VIA Port B = 81, mux disabled, RAMP disabled, BC1/BDIR = 00 (PSG inactive)
FORCE_SYMBOL $01B4 VIA_port_b
COMMENT $01B6 write value of $ff to reg $0e (latched)
FORCE_NO_SYMBOL $01B6
COMMENT $01B8 write $ff to VIA A (DAC)
FORCE_SYMBOL $01B8 VIA_port_a
FORCE_NO_SYMBOL $01BA
COMMENT $01BD VIA Port B = 91, mux disabled, RAMP disabled, BC1/BDIR = 10 (Write to PSG)
FORCE_SYMBOL $01BD VIA_port_b
COMMENT $01BF VIA Port B = 81, mux disabled, RAMP disabled, BC1/BDIR = 00 (PSG inactive)
FORCE_SYMBOL $01BF VIA_port_b
FORCE_NO_SYMBOL $01C1
COMMENT $01C4 configure VIA A as input (all zeroes 0)
FORCE_SYMBOL $01C4 VIA_DDR_a
COMMENT $01C6 VIA Port B = 89, mux disabled, RAMP disabled, BC1/BDIR = 01 (Read from PSG)
FORCE_SYMBOL $01C6 VIA_port_b
FORCE_NO_SYMBOL $01C8
COMMENT $01CA read value to a from VIA A, which in turn reads Port A of PSG
FORCE_SYMBOL $01CA VIA_port_a
COMMENT $01CC VIA Port B = 81, mux disabled, RAMP disabled, BC1/BDIR = 00 (PSG inactive)
FORCE_SYMBOL $01CC VIA_port_b
FORCE_NO_SYMBOL $01CE
COMMENT $01D0 configure VIA A as output (all zeroes 1)
FORCE_SYMBOL $01D0 VIA_DDR_a
COMMENT $01D3 set up direct page to d0 for the complete "game"
FORCE_NO_SYMBOL $01D3
COMMENT $01D7 load a space and store it to...
FORCE_NO_SYMBOL $01D7
COMMENT $01D9 not used? CBF0 is part of the BIOS highscore setting
FORCE_SYMBOL $01D9 _CBF0
COMMENT $01DC init main subroutine to "init"
COMMENT $01DE the last thing done in the mainloop "last round" was a draw
COMMENT $01DF this must be finished here with a mov 0 to SHIFT (switch the beam off)
FORCE_SYMBOL $01DF VIA_shift_reg
COMMENT $01E2 recalibrate
FORCE_SYMBOL $01E2 Wait_Recal
COMMENT $01E5 query input devices (port 0)
FORCE_SYMBOL $01E5 queryInputPort0
COMMENT $01E8 sync 3 bytes TO other player and 3 bytes from other player, also sets link status
FORCE_SYMBOL $01E8 syncVectrex_3bytes
COMMENT $01EB go to the current main routine (one of: "no link" (or "init"), "primary", "secondary")
FORCE_SYMBOL $01EB jumper
COMMENT $01EF and repeat that forever
COMMENT_LINE $01F1 each time the link cable is "faulty" (connection is lost)
COMMENT_LINE $01F1 this routine is called (or upon startup)
COMMENT_LINE $01F1 this sets the main "subroutine" to "init"
COMMENT $01F1 in the first update round (or link is broken), initialize
FORCE_SYMBOL $01F1 init_vars_main
COMMENT $01F4 the "main" subroutine is init the player vars (which also is "no link")
FORCE_SYMBOL $01F4 jumper
COMMENT_LINE $01F8 this routine sets up player vars (position, intensity...)
COMMENT_LINE $01F8 checks the current link status
COMMENT_LINE $01F8 and sets the main "subroutine" (jumper) according to the link status
COMMENT_LINE $01F8 each player structure consists of 3 bytes
COMMENT_LINE $01F8 ypos, xpos, intensity
COMMENT_LINE $01F8 the first three "word" moves, fill both player structures
COMMENT $01F8 position of primary player (y,x)
FORCE_NO_SYMBOL $01F8
FORCE_SYMBOL $01FB primary_pos
COMMENT $01FE primary intensity and secondary y
FORCE_NO_SYMBOL $01FE
FORCE_SYMBOL $0201 primary_intensity
COMMENT $0204 secondary x and secondary intensity
FORCE_NO_SYMBOL $0204
FORCE_SYMBOL $0207 secondary_x
COMMENT_LINE $020A check current connection state
FORCE_SYMBOL $020A statusFlag
COMMENT $020D if negative no link was found
COMMENT $020F if positive (1) jump, we are secondary
COMMENT $0211 we are primary, load our main routine and store it
FORCE_SYMBOL $0211 primary_main
COMMENT $0214 to the indirect jump table
FORCE_SYMBOL $0214 jumper
COMMENT $0218 we are secondary, load our main routine and store it
FORCE_SYMBOL $0218 secondary_main
COMMENT $021B to the indirect jump table
FORCE_SYMBOL $021B jumper
COMMENT_LINE $021F "main" loop entry if link is broken,
COMMENT_LINE $021F this is accessed "directly" from "init_vars_main"
COMMENT_LINE $021F not thru a jumper
COMMENT_LINE $021F this is an "endpoint" of the jumper call to init_vars_main and is
COMMENT_LINE $021F exited with a jump to a subroutine, which returns correctly to the main loop (saving a few cycles)
COMMENT $021F setup DP
FORCE_NO_SYMBOL $021F
COMMENT $0223 reset vector beam
FORCE_SYMBOL $0223 Reset0Ref
COMMENT $0226 set intensity
FORCE_NO_SYMBOL $0226
COMMENT $0228 to $3f
FORCE_SYMBOL $0228 Intensity_a
COMMENT $022B move to a position
FORCE_NO_SYMBOL $022B
FORCE_SYMBOL $022E Moveto_d_7F
COMMENT $0231 set a low scaling factor
FORCE_NO_SYMBOL $0231
COMMENT $0233 (timer 1 is scaling)
FORCE_SYMBOL $0233 VIA_t1_cnt_lo
COMMENT $0235 load the vector representation of "no link" to U
FORCE_SYMBOL $0235 no_link_string
COMMENT $0238 and draw that -> and exit subroutine to main
FORCE_SYMBOL $0238 draw_vector_list
COMMENT_LINE $023B drawing the "you" at the right position
COMMENT_LINE $023B players are actually drawn with the "same" routine (no differentiation between primary and secondary)
COMMENT $023B ensure link is still valid
FORCE_SYMBOL $023B statusFlag
COMMENT $023E if not, jump to init (must be 0 for primary)
COMMENT $0240 setup DP
FORCE_NO_SYMBOL $0240
COMMENT $0244 reset vector beam
FORCE_SYMBOL $0244 Reset0Ref
COMMENT $0247 intensity of "you" string offset table
FORCE_SYMBOL $0247 intensity_blink
COMMENT $024A load waitRecal counter as an offset
FORCE_SYMBOL $024A intensityIndexNibble
COMMENT $024D divide by two
COMMENT $024E and only use the lower nibble
FORCE_NO_SYMBOL $024E
COMMENT $0250 as an offset index to the "blink" intensities
COMMENT $0252 set intensity
FORCE_SYMBOL $0252 Intensity_a
COMMENT $0255 x = current used player structure
FORCE_SYMBOL $0255 primary_structure
COMMENT $0258 get current input readings (joystick and buttons), and set D to POS of player
COMMENT $025A move "cursor" to that position
FORCE_SYMBOL $025A Moveto_d_7F
COMMENT $025D set a low scaling factor
FORCE_NO_SYMBOL $025D
COMMENT $025F (timer 1 is scaling)
FORCE_SYMBOL $025F VIA_t1_cnt_lo
COMMENT $0261 load pointer of vectorlist "you" to U
FORCE_SYMBOL $0261 you
COMMENT $0264 and output it at the current position
FORCE_SYMBOL $0264 draw_vector_list
COMMENT $0267 draw the player "signs"
COMMENT_LINE $0269 drawing the "you" at the right position
COMMENT_LINE $0269 players are actually drawn with the "same" routine (no differentiation between primary and secondary)
COMMENT $0269 ensure link is still valid
FORCE_SYMBOL $0269 statusFlag
COMMENT $026C must be 1 for secondary
FORCE_NO_SYMBOL $026C
COMMENT $026E if not, jump to init
COMMENT $0270 setup DP
FORCE_NO_SYMBOL $0270
COMMENT $0274 reset vector beam
FORCE_SYMBOL $0274 Reset0Ref
COMMENT $0277 intensity of "you" string offset table
FORCE_SYMBOL $0277 intensity_blink
COMMENT $027A load waitRecal counter as an offset
FORCE_SYMBOL $027A intensityIndexNibble
COMMENT $027D divide by two
COMMENT $027E and only use the lower nibble
FORCE_NO_SYMBOL $027E
COMMENT $0280 as an offset index to the "blink" intensities
COMMENT $0282 set intensity
FORCE_SYMBOL $0282 Intensity_a
COMMENT $0285 x = current used player structure
FORCE_SYMBOL $0285 secondary_structure
COMMENT $0288 get current input readings (joystick and buttons), and set D to POS of player
COMMENT $028A move "cursor" to that position
FORCE_SYMBOL $028A Moveto_d_7F
COMMENT $028D set a low scaling factor
FORCE_NO_SYMBOL $028D
COMMENT $028F (timer 1 is scaling)
FORCE_SYMBOL $028F VIA_t1_cnt_lo
COMMENT $0291 load pointer of vectorlist "you" to U
FORCE_SYMBOL $0291 you
COMMENT $0294 and output it at the current position
FORCE_SYMBOL $0294 draw_vector_list
COMMENT $0297 draw the player "signs"
COMMENT_LINE $0299 in x is the player structure given
COMMENT_LINE $0299 apply the current input to the given player structure
COMMENT_LINE $0299 digital joystick movements (filled before) are represented
COMMENT_LINE $0299 by +1, 0, -1 (for vertical and horizontal joystick positions)
COMMENT_LINE $0299 button states are respected and applied (intensity change of pressed or released)
COMMENT_LINE $0299 exits with D filled with position of player
COMMENT_LINE $0299 first
COMMENT_LINE $0299 check the button state of port 0
COMMENT_LINE $0299 if any button is pressed, intensity in the player structure is decreased (not below 0)
COMMENT_LINE $0299 if no button is pressed it is increased (not above intensity $4f)
COMMENT $0299 load current button state
FORCE_SYMBOL $0299 Vec_Btn_State
COMMENT $029C test for any button of port 0 (mask: 0000 1111)
FORCE_NO_SYMBOL $029C
COMMENT_LINE $02A0 decrease intensity if no button was pressed
COMMENT $02A0 load current intensity
FORCE_SYMBOL $02A0 S_INTENSITY
COMMENT $02A2 check if already zero, if yes, just go on
COMMENT $02A4 if not - decrease it
COMMENT $02A5 and store it in the player structure
FORCE_SYMBOL $02A5 S_INTENSITY
COMMENT $02A7 go on
COMMENT $02A9 load current intensity
FORCE_SYMBOL $02A9 S_INTENSITY
COMMENT $02AB check if maxed
FORCE_NO_SYMBOL $02AB
COMMENT $02AD if yes - go on
COMMENT $02AF if not increase
COMMENT $02B0 and store it
FORCE_SYMBOL $02B0 S_INTENSITY
COMMENT $02B2 load the last got joystick vertical/horizontal values to D[Y,X] (0,-1 or 1))
FORCE_SYMBOL $02B2 joy_y
COMMENT $02B5 double Y (contains now -2, 0 or +2)
COMMENT $02B6 add to that value the current Y pos from player structure
FORCE_NO_SYMBOL $02B6
COMMENT $02B8 do the same with x: double X (contains now -2, 0 or +2)
COMMENT $02B9 add to that value the current X pos from player structure
FORCE_SYMBOL $02B9 S_XPOS
COMMENT $02BB and store the result back to the player structure
FORCE_NO_SYMBOL $02BB
COMMENT $02BD leaving with d set to the position Y, X
COMMENT $02BE reset vector beam
FORCE_SYMBOL $02BE Reset0Ref
COMMENT $02C1 get intensity of primary
FORCE_SYMBOL $02C1 primary_intensity
COMMENT $02C4 set that intensity
FORCE_SYMBOL $02C4 Intensity_a
COMMENT $02C7 load the primary position
FORCE_SYMBOL $02C7 primary_pos
COMMENT $02CA move there
FORCE_SYMBOL $02CA Moveto_d_7F
COMMENT $02CD load a "medium" scale value
FORCE_NO_SYMBOL $02CD
COMMENT $02CF and set it (timer 1 is scaling)
FORCE_SYMBOL $02CF VIA_t1_cnt_lo
COMMENT $02D1 for primary load the trianlge vectorlist
FORCE_SYMBOL $02D1 triangle
COMMENT $02D4 and draw it
FORCE_SYMBOL $02D4 draw_vector_list
COMMENT $02D7 repeat the above for secondary player, - reset vector beam
FORCE_SYMBOL $02D7 Reset0Ref
COMMENT $02DA get intensity of secondary
FORCE_SYMBOL $02DA secondary_intensity
COMMENT $02DD set that intensity
FORCE_SYMBOL $02DD Intensity_a
COMMENT $02E0 load the secondary position
FORCE_SYMBOL $02E0 secondary_pos
COMMENT $02E3 move there
FORCE_SYMBOL $02E3 Moveto_d_7F
COMMENT $02E6 load a "medium" scale value
FORCE_NO_SYMBOL $02E6
COMMENT $02E8 and set it (timer 1 is scaling)
FORCE_SYMBOL $02E8 VIA_t1_cnt_lo
COMMENT $02EA for secondary load the diamond vectorlist
FORCE_SYMBOL $02EA diamond
COMMENT $02ED and draw it
FORCE_SYMBOL $02ED draw_vector_list
COMMENT $02F0 done
COMMENT_LINE $02F1 expects pointer to a vector list in U
COMMENT_LINE $02F1 format of vector list is: %Y %X %M (delta Y, delta X, mode)
COMMENT_LINE $02F1 mode: $80 = end
COMMENT_LINE $02F1 anything else = pattern
COMMENT $02F1 load Y delta to A
COMMENT $02F3 store to DAC
FORCE_SYMBOL $02F3 VIA_port_a
COMMENT $02F5 clr port B (mux enabled, mux sel = y) -> thus integrator Y will update with Y delta
FORCE_SYMBOL $02F5 VIA_port_b
COMMENT $02F7 get X delta to A and pattern to B
COMMENT $02F9 disable mux
FORCE_SYMBOL $02F9 VIA_port_b
COMMENT $02FB set X delta to A
FORCE_SYMBOL $02FB VIA_port_a
COMMENT_LINE $02FE I think Alex is doing a trick here
COMMENT_LINE $02FE to prevent the "dotting" of vectors
COMMENT_LINE $02FE when being displayed
COMMENT_LINE $02FE usually the light is switched ON too soon, this might prevent that (a little)
COMMENT $02FE shorten the pattern by 3 upper bits (6 cycles are still "blank") [1 shift needs 2 cpu cycles]
FORCE_NO_SYMBOL $02FE
COMMENT_LINE $0300 as long, as bit 0 is 1 at the end of the complete shift cycle, the line will be displayed
COMMENT_LINE $0300 correctly, I wonder what appears on screen if bit 0 of the pattern is 0, than probably
COMMENT_LINE $0300 only the beginning and the end of the line is shown
COMMENT $0300 put that configured pattern to shift, shifting starts
FORCE_SYMBOL $0300 VIA_shift_reg
COMMENT $0302 start the timer (this instruction takes exactly 6 cycles - this is the above done offset!)
FORCE_SYMBOL $0302 VIA_t1_cnt_hi
COMMENT $0304 load the un altered pattern to b
COMMENT $0306 and patch that also (upper 4 bits only)
FORCE_NO_SYMBOL $0306
COMMENT_LINE $0308 I don't know what patching the "switch of" shift really accomplishes
COMMENT_LINE $0308 since RAMP will be disabled by the timer, and shift will still be on for to long...
COMMENT $0308 test bit for timer 1
FORCE_NO_SYMBOL $0308
COMMENT $030A test if timer has run out
FORCE_SYMBOL $030A VIA_int_flags
COMMENT $030C if timer is still counting down - continue
COMMENT $030E store the "other" side of the patched pattern to shiftreg
FORCE_SYMBOL $030E VIA_shift_reg
COMMENT $0310 load net pattern byte
COMMENT $0312 if == $80 we finished with our vector list
FORCE_NO_SYMBOL $0312
COMMENT $0314 if not - display next vector
COMMENT_LINE $03AB query joystick buttons
COMMENT_LINE $03AB joytick pot readings are also switched by the (de)muliplexer (analog section)
COMMENT_LINE $03AB with joystick pots the switching is not done in regard of the output (in opposite to "input" switching of integrator logic)
COMMENT_LINE $03AB but with regard to input
COMMENT_LINE $03AB thus, the SEL part of the mux now selects which joystick pot is selected and send to the compare logic.
COMMENT_LINE $03AB mux sel:
COMMENT_LINE $03AB xxxx x00x: port 0 horizontal
COMMENT_LINE $03AB xxxx x01x: port 0 vertical
COMMENT_LINE $03AB xxxx x10x: port 1 horizontal
COMMENT_LINE $03AB xxxx x11x: port 1 vertical
COMMENT_LINE $03AB the result of the pot reading is compared to the
COMMENT_LINE $03AB value present in the dac and according to the comparisson the compare flag of VIA (bit 5 of port b) is set.
COMMENT_LINE $03AB (compare bit is = if contents of dac was "smaller" (signed) than the "pot" read)
COMMENT $03AB setup DP
FORCE_NO_SYMBOL $03AB
COMMENT $03AF read joystick buttons and set the result to BIOS RAM location (Vec_Btn_State)
FORCE_SYMBOL $03AF Read_Btns
COMMENT_LINE $03B2 reset integrator offsets
COMMENT $03B2 mux disabled, mux sel = 01 (vertical pot port 0)
FORCE_NO_SYMBOL $03B2
FORCE_SYMBOL $03B4 VIA_port_b
COMMENT $03B6 dac = 0
FORCE_SYMBOL $03B6 VIA_port_a
COMMENT $03B8 mux enabled, mux sel = 01
FORCE_SYMBOL $03B8 VIA_port_b
COMMENT $03BA a wait loop 32 times a loop (waiting for the pots to "read" values, and feed to compare logic)
FORCE_NO_SYMBOL $03BA
COMMENT $03BC ...
COMMENT $03BD wait...
COMMENT $03BF disable mux
FORCE_SYMBOL $03BF VIA_port_b
COMMENT $03C1 load b with comparator bit (0010 0000)
FORCE_NO_SYMBOL $03C1
COMMENT $03C3 load a with test value (positive y)
FORCE_NO_SYMBOL $03C3
COMMENT $03C5 test value to DAC
FORCE_SYMBOL $03C5 VIA_port_a
COMMENT $03C7 default result value y was pushed UP
FORCE_NO_SYMBOL $03C7
COMMENT $03C9 test comparator
FORCE_SYMBOL $03C9 VIA_port_b
COMMENT $03CB if comparator cleared - joystick was moved up
COMMENT $03CD "load" with negative value
FORCE_SYMBOL $03CD VIA_port_a
COMMENT $03CF also switch the possible result in A
COMMENT $03D0 test comparator again
FORCE_SYMBOL $03D0 VIA_port_b
COMMENT $03D2 if cleared the joystick was moved down
COMMENT $03D4 if still not cleared, we clear a as the final vertical test result (no move at all)
COMMENT $03D5 remember the result in "our" joystick data
FORCE_SYMBOL $03D5 joy_y
COMMENT_LINE $03D8 now the same for horizontal
COMMENT $03D8 mux disabled, mux sel = 00 (horizontal pot port 0)
FORCE_NO_SYMBOL $03D8
FORCE_SYMBOL $03DA VIA_port_b
COMMENT $03DC dac = 0
FORCE_SYMBOL $03DC VIA_port_a
COMMENT $03DE mux enabled, mux sel = 01
FORCE_SYMBOL $03DE VIA_port_b
COMMENT $03E0 a wait loop 32 times a loop (waiting for the pots to "read" values, and feed to compare logic)
FORCE_NO_SYMBOL $03E0
COMMENT $03E2 ...
COMMENT $03E3 wait...
COMMENT $03E5 disable mux
FORCE_SYMBOL $03E5 VIA_port_b
COMMENT $03E7 load b with comparator bit (0010 0000)
FORCE_NO_SYMBOL $03E7
COMMENT $03E9 load a with test value (positive x)
FORCE_NO_SYMBOL $03E9
COMMENT $03EB test value to DAC
FORCE_SYMBOL $03EB VIA_port_a
COMMENT $03ED default result value x was pushed right
FORCE_NO_SYMBOL $03ED
COMMENT $03EF test comparator
FORCE_SYMBOL $03EF VIA_port_b
COMMENT $03F1 if comparator cleared - joystick was moved right
COMMENT $03F3 "load" with negative value
FORCE_SYMBOL $03F3 VIA_port_a
COMMENT $03F5 also switch the possible result in A
COMMENT $03F6 test comparator again
FORCE_SYMBOL $03F6 VIA_port_b
COMMENT $03F8 if cleared the joystick was moved left
COMMENT $03FA if still not cleared, we clear a as the final vertical test result (no move at all)
COMMENT $03FB remember the result in "our" joystick data
FORCE_SYMBOL $03FB joy_x
COMMENT $03FE done
COMMENT_LINE $03FF the "you" string is shown with different intensity levels
COMMENT_LINE $03FF this is an offset table to the intensities used (16) -> blinking
RANGE $0017-$040D DP $D0
RANGE $0000-$000B CHAR_DATA 11
RANGE $000B-$000D DW_DATA 1
RANGE $000D-$000E DB_DATA 1
RANGE $000E-$0011 CODE
RANGE $0011-$0017 DB_DATA 6
RANGE $0017-$0317 CODE
RANGE $0317-$031A DB_DATA 3
RANGE $031A-$031D DB_DATA 3
RANGE $031D-$0320 DB_DATA 3
RANGE $0320-$0323 DB_DATA 3
RANGE $0323-$0324 DB_DATA 1
RANGE $0324-$0327 DB_DATA 3
RANGE $0327-$032A DB_DATA 3
RANGE $032A-$032D DB_DATA 3
RANGE $032D-$0330 DB_DATA 3
RANGE $0330-$0333 DB_DATA 3
RANGE $0333-$0334 DB_DATA 1
RANGE $0334-$0337 DB_DATA 3
RANGE $0337-$033A DB_DATA 3
RANGE $033A-$033D DB_DATA 3
RANGE $033D-$0340 DB_DATA 3
RANGE $0340-$0343 DB_DATA 3
RANGE $0343-$0346 DB_DATA 3
RANGE $0346-$0349 DB_DATA 3
RANGE $0349-$034C DB_DATA 3
RANGE $034C-$034F DB_DATA 3
RANGE $034F-$0352 DB_DATA 3
RANGE $0352-$0355 DB_DATA 3
RANGE $0355-$0358 DB_DATA 3
RANGE $0358-$035B DB_DATA 3
RANGE $035B-$035E DB_DATA 3
RANGE $035E-$0361 DB_DATA 3
RANGE $0361-$0364 DB_DATA 3
RANGE $0364-$0367 DB_DATA 3
RANGE $0367-$0368 DB_DATA 1
RANGE $0368-$036B DB_DATA 3
RANGE $036B-$036E DB_DATA 3
RANGE $036E-$0371 DB_DATA 3
RANGE $0371-$0374 DB_DATA 3
RANGE $0374-$0377 DB_DATA 3
RANGE $0377-$037A DB_DATA 3
RANGE $037A-$037D DB_DATA 3
RANGE $037D-$0380 DB_DATA 3
RANGE $0380-$0383 DB_DATA 3
RANGE $0383-$0386 DB_DATA 3
RANGE $0386-$0389 DB_DATA 3
RANGE $0389-$038C DB_DATA 3
RANGE $038C-$038F DB_DATA 3
RANGE $038F-$0392 DB_DATA 3
RANGE $0392-$0395 DB_DATA 3
RANGE $0395-$0398 DB_DATA 3
RANGE $0398-$039B DB_DATA 3
RANGE $039B-$039E DB_DATA 3
RANGE $039E-$03A1 DB_DATA 3
RANGE $03A1-$03A4 DB_DATA 3
RANGE $03A4-$03A7 DB_DATA 3
RANGE $03A7-$03AA DB_DATA 3
RANGE $03AA-$03AB DB_DATA 1
RANGE $03AB-$03FF CODE
RANGE $03FF-$0401 DB_DATA 2
RANGE $0401-$0403 DB_DATA 2
RANGE $0403-$0405 DB_DATA 2
RANGE $0405-$0407 DB_DATA 2
RANGE $0407-$0409 DB_DATA 2
RANGE $0409-$040B DB_DATA 2
RANGE $040B-$040D DB_DATA 2
RANGE $040D-$040F DB_DATA 2

