BANK 0
LABEL $F18B reinit
LABEL $F192 waitrecal
LABEL $F1BA read_switches2
LABEL $F289 do_sound
LABEL $F2A9 intensity_to_7F
LABEL $F2AB intensity_to_a
LABEL $F2FC move_pen7F_to_d
LABEL $F354 reset0ref
LABEL $F533 init_music_buf
LABEL $F56D delay_b_3
LABEL $F584 get_absolute_value_of_ab
LABEL $0EEE AM_music
LABEL $0021 start
LABEL $01A2 am_clear_game_RAM
LABEL $009B display_main_menu
LABEL $003A main_loop
LABEL $0ECB check_for_end_of_sound
LABEL $0040 P0040
LABEL $0050 P0050
EQU $56 SM_ERASE_STR
EQU $62 SM_MENU_STR
EQU $6D SM_NEXT_STR
EQU $78 SM_LAST_STR
LABEL $0083 SM_PLAY_STR
LABEL $008E SM_CREATE_STR
LABEL $0169 MM_SKETCH_STR
LABEL $0ACF print_with_pick_check
LABEL $00B5 disp_mm_connect_str
LABEL $0102 disp_only_mm_sketch_str
LABEL $0176 MM_CONNECT_STR
LABEL $00CC disp_mm_animate_str
LABEL $0127 disp_only_mm_connect_str
LABEL $0184 MM_ANIMATE_STR
LABEL $00E3 P00E3
LABEL $00E4 disp_only_mm_animate_str
LABEL $00F9 P00F9
LABEL $00FF P00FF
LABEL $01D6 start_of_animate
LABEL $0117 P0117
LABEL $011D P011D
LABEL $0BCF start_of_sketch_connect
LABEL $013C P013C
LABEL $0142 P0142
LABEL $0151 HDR_CREATE_STR
LABEL $015E HDR_EDIT_STR
LABEL $0192 box
LABEL $01A5 P01A5
LABEL $01AD draw_previous_frame
LABEL $01B3 P01B3
LABEL $053C draw_all_visible_lines
LABEL $0507 draw_points_without_pick
LABEL $01CC select_a_frame
LABEL $056F init_animate_variables
LABEL $01E2 return_to_frame1
LABEL $0224 animate_handler
LABEL $01F2 advance_to_next_frame
LABEL $020F P020F
LABEL $01FE P01FE
LABEL $021D P021D
LABEL $02C7 edit_handler
LABEL $0306 display_frame_num
LABEL $048C find_lightpen_pick
LABEL $0B19 am_print_string
LABEL $0269 P0269
LABEL $055B draw_line_between_2_points
LABEL $0260 P0260
LABEL $042D process_button1_and_2
LABEL $027A disp_sm_erase_str
LABEL $057C add_a_new_line
LABEL $03C2 check_for_move_request
LABEL $0290 disp_sm_next_str
LABEL $02AA disp_sm_menu_str
LABEL $0ED8 set_up_a_misc_sound1
LABEL $02C0 P02C0
LABEL $02CF P02CF
LABEL $02EF P02EF
LABEL $02F7 P02F7
LABEL $032C disp_sm_menu_str2
LABEL $0346 disp_sm_create_str
LABEL $0345 P0345
LABEL $035F disp_sm_next_str2
LABEL $0384 disp_sm_last_str
LABEL $03A8 disp_sm_play_str
LABEL $0EDB set_up_a_misc_sound2
LABEL $03C1 P03C1
LABEL $05D3 init_play_variables
LABEL $059C play_handler
LABEL $03CD process_move
LABEL $0405 continue_moving_point
LABEL $03DB start_moving_point
LABEL $08ED set_cursor_structure
LABEL $040B update_moving_point
LABEL $0901 update_cursor_position
LABEL $0EB2 am_move_to_d
LABEL $07D6 draw_with_pick_check
LABEL $0437 P0437
LABEL $0448 P0448
LABEL $0460 scan_screen_for_lightpen
LABEL $0450 P0450
LABEL $0469 P0469
LABEL $0721 search_screen_for_lightpen
LABEL $0471 P0471
LABEL $0481 P0481
LABEL $049A P049A
LABEL $04A9 check_next_endpoint
LABEL $04D0 P04D0
LABEL $052F cross
LABEL $0A50 dot_pattern
LABEL $0502 P0502
LABEL $050A P050A
LABEL $0513 P0513
LABEL $0545 P0545
LABEL $054A P054A
LABEL $0557 P0557
LABEL $0840 draw_vector_with_pick_check
LABEL $0574 P0574
LABEL $057F P057F
LABEL $0585 P0585
LABEL $0584 P0584
LABEL $0598 P0598
LABEL $05AA P05AA
LABEL $064A get_ptrs_to_playback_frames
LABEL $06A9 fill_playback_buffer
LABEL $05E8 check_playback_speed_buttons
LABEL $05D2 P05D2
LABEL $061D update_playback_variables
LABEL $05F3 decrease_playback_speed
LABEL $0609 increase_playback_speed
LABEL $05FB P05FB
LABEL $060F P060F
LABEL $0632 playback_speed_info
LABEL $067F update_play_index_to_next_frame
LABEL $0669 frame_buf_pointers
LABEL $0699 backward_order
LABEL $0690 start_backwards
LABEL $06A2 start_forward
LABEL $06B9 P06B9
LABEL $06DB P06DB
LABEL $06DC merge_coordinates
LABEL $0701 P0701
LABEL $0712 P0712
LABEL $0714 P0714
LABEL $0716 P0716
LABEL $0718 P0718
LABEL $071A P071A
LABEL $071C P071C
LABEL $071E P071E
LABEL $0720 P0720
LABEL $072C P072C
LABEL $0736 draw_scan_line
LABEL $0754 P0754
LABEL $076D find_point_of_intersection
LABEL $07CE ISR_handler
LABEL $079E P079E
LABEL $07AA disable_interrupts
LABEL $07B7 process_ISR
LABEL $07DE P07DE
LABEL $07F3 P07F3
LABEL $0805 P0805
LABEL $080E P080E
LABEL $0814 P0814
LABEL $082A P082A
LABEL $0831 P0831
LABEL $0879 calculate_vector_endpoint
LABEL $08E7 am_scale_factors
LABEL $086D P086D
LABEL $08BA P08BA
LABEL $0897 P0897
LABEL $089E P089E
LABEL $08AD P08AD
LABEL $0A54 whole_search_pattern
LABEL $0984 find_lightpen
LABEL $0983 P0983
LABEL $092B P092B
LABEL $0A5E lower_search_pattern
LABEL $0949 P0949
LABEL $0940 P0940
LABEL $0A68 upper_search_pattern
LABEL $096A P096A
LABEL $0A7C left_search_pattern
LABEL $097F P097F
LABEL $0A72 right_search_pattern
LABEL $09A3 search_4_lightpen
LABEL $09A8 continue_lightpen_search
LABEL $0A86 small_search_pattern_vl
LABEL $09B7 P09B7
LABEL $0A98 large_search_pattern_vl
LABEL $0AC4 search_pattern_scale_factors
LABEL $09CE draw_search_pattern
LABEL $0A13 display_search_pattern
LABEL $09DC lightpen_found
LABEL $0AAA cursor_deltas
LABEL $0ABA delta_multipliers
LABEL $0A05 generate_new_cursor_coordinate
LABEL $0A0B P0A0B
LABEL $0A12 P0A12
LABEL $0A20 P0A20
LABEL $0A35 P0A35
LABEL $0A47 P0A47
LABEL $0AE4 P0AE4
LABEL $0AEC P0AEC
LABEL $0AED hilite_string
LABEL $0B3C P0B3C
LABEL $0B62 P0B62
LABEL $0B5E P0B5E
LABEL $0BAD P0BAD
LABEL $0B8D P0B8D
LABEL $0BB4 SM_DOT_STR
LABEL $0BBE SM_LINE_STR
LABEL $0BC9 initial_cursor_state
LABEL $0E1F init_sketch_connect_variables
LABEL $0BE1 sketch_connect_handler
LABEL $0BF1 P0BF1
LABEL $0D27 display_sc_menu
LABEL $0E38 sketch_connect_draw_vector_list
LABEL $0C95 fan_handler
LABEL $0C0F sc_start_draw
LABEL $0C09 P0C09
LABEL $0C12 sc_start_fan
LABEL $0C46 sc_start_rubber_band_line
LABEL $0C5B sc_draw_handler
LABEL $0C1A P0C1A
LABEL $0CDA rubber_band_line_handler
LABEL $0C57 P0C57
LABEL $0C72 P0C72
LABEL $0DFA get_new_endpoint
LABEL $0C7C fix_endpoint
LABEL $0C85 P0C85
LABEL $0CB7 continue_drawing_fan
LABEL $0CC1 P0CC1
LABEL $0CCA P0CCA
LABEL $0CF4 continue_rb_line
LABEL $0CFE P0CFE
LABEL $0D0B P0D0B
LABEL $0D0C HDR_CONNECT_STR
LABEL $0D1A HDR_SKETCH_STR
LABEL $0D48 P0D48
LABEL $0D43 P0D43
LABEL $0D4E P0D4E
LABEL $0D7C P0D7C
LABEL $0D98 P0D98
LABEL $0DB0 P0DB0
LABEL $0DB2 gen_vec_endpoint_recal
COMMENT_LABEL $0DB2 generate_vector_endpoint_and_recalibrate
LABEL $0DD6 P0DD6
LABEL $0DCC P0DCC
LABEL $0DF0 P0DF0
LABEL $0E02 P0E02
LABEL $0E14 P0E14
LABEL $0E24 P0E24
LABEL $0E40 P0E40
LABEL $0E54 draw_relative_points
LABEL $0E4A move_to_abs_ref_point
LABEL $0E59 P0E59
LABEL $0E5E P0E5E
LABEL $0E68 sc_draw_to_point
LABEL $0E75 sc_move_to_point
LABEL $0E8F am_draw_with_pattern
LABEL $0EA9 P0EA9
LABEL $0EC6 P0EC6
LABEL $0ED4 P0ED4
COMMENT_LINE $0000 can be assembled correctly now
COMMENT_LINE $0000 compatibilty added by Malban
COMMENT_LINE $0000 assenmble with comand line:
COMMENT_LINE $0000 .\ass\as09.exe -w200 -h0 -l -mcti art.asm >error
COMMENT_LINE $0000 used the 6809 assembler:
COMMENT_LINE $0000 as09 [1.11].
COMMENT_LINE $0000 Copyright 1990-1994, Frank A. Vorstenbosch, Kingswood Software.
COMMENT_LINE $0000 Available at:
COMMENT_LINE $0000 http://www.falstaff.demon.co.uk/cross.html
COMMENT_LINE $0000 This work was originally done by Fred Taft (fred@hp-pcd.cv.hp.com).
COMMENT_LINE $0000 Please forward any comments, corrections or additions back to Fred.
COMMENT_LINE $0000 Art Master
COMMENT_LINE $0000 bios routines
COMMENT_LINE $0000 bios data
COMMENT $000D * height
COMMENT $000E * width
COMMENT $000F * rel y
COMMENT $0010 * rel x
COMMENT $0015 * height
COMMENT $0016 * width
COMMENT $0017 * rel y
COMMENT $0018 * rel x
COMMENT_LINE $0021 Art Master
COMMENT_LINE $0021 This is the entry point for the Art Master game.
COMMENT_LINE $0021 It initializes the RAM area used by the game, initializes
COMMENT_LINE $0021 the music buffer, sets up the indirect jump location
COMMENT_LINE $0021 in C8A7, and lastly, passes control to the main loop.
COMMENT_LINE $003A main_loop()
COMMENT_LINE $003A This main loop is responsible for reading the buttons
COMMENT_LINE $003A on the primary console, continuing any sounds which
COMMENT_LINE $003A are in progress, and then calling whichever handling
COMMENT_LINE $003A routine has been = up in the indirect jump location.
COMMENT_LINE $003A After this, it recalibrates the integraters, and then
COMMENT_LINE $003A repeats the above.
COMMENT $0043 * Keep track of the fact that
COMMENT $0046 * a string was picked last pass
COMMENT $0049 * thru the main loop.
COMMENT_LINE $009B The next 3 blocks of code cause the three main
COMMENT_LINE $009B menu items (sketch, connect and animate) to be
COMMENT_LINE $009B displayed, until one of them is picked by the
COMMENT_LINE $009B lightpen (a pick is indicated by C89E != 0).
COMMENT_LINE $009B When a pick occurs, the counter in C888
COMMENT_LINE $009B is set, and the jump location (C8A7) is = so that
COMMENT_LINE $009B only the picked option is displayed.
COMMENT_LINE $00E4 Continue to display the ANIMATE main menu item,
COMMENT_LINE $00E4 until either the loop counter (C888) decrements
COMMENT_LINE $00E4 to zero (at which point the ANIMATE activity starts),
COMMENT_LINE $00E4 or the string is no longer picked (then display the
COMMENT_LINE $00E4 main menu again).
COMMENT_LINE $0102 Continue to display the SKETCH main menu item,
COMMENT_LINE $0102 until either the loop counter (C888) decrements
COMMENT_LINE $0102 to zero (at which point the SKETCH activity starts),
COMMENT_LINE $0102 or the string is no longer picked (then display the
COMMENT_LINE $0102 main menu again).
COMMENT $011D * Flag this is sketch mode
COMMENT_LINE $0127 Continue to display the CONNECT main menu item,
COMMENT_LINE $0127 until either the loop counter (C888) decrements
COMMENT_LINE $0127 to zero (at which point the CONNECT activity starts),
COMMENT_LINE $0127 or the string is no longer picked (then display the
COMMENT_LINE $0127 main menu again).
COMMENT $0144 * CONNECT option
COMMENT $0147 * Do dots first
COMMENT_LINE $0192 This is the vector list which describes the box
COMMENT_LINE $0192 which is sometimes drawn around a selected point.
COMMENT_LINE $0192 The list has the following format:
COMMENT_LINE $0192 line pattern, rel y, rel x
COMMENT_LINE $0192 A line pattern of 1 signals the end.
COMMENT_LINE $01A2 am_clear_game_RAM()
COMMENT_LINE $01A2 Clear to zero, the block of RAM which is used
COMMENT_LINE $01A2 by the Art Master game: C880 - CB7F
COMMENT_LINE $01AD draw_previous_frame()
COMMENT_LINE $01AD This routine gets information for the previous frame
COMMENT_LINE $01AD during ANIMATE mode.  It will then use the new
COMMENT_LINE $01AD frame number to index into the structure starting
COMMENT_LINE $01AD at C977 (the vectors for this frame), using the
COMMENT_LINE $01AD following formula:
COMMENT_LINE $01AD C917 = (previous_frame_num* 64) + C977
COMMENT_LINE $01AD Afterwards, it will draw the vectors associated with
COMMENT_LINE $01AD this frame, using a small intensity, thus allowing the
COMMENT_LINE $01AD user to see the previous frame he made.
COMMENT_LINE $01CC select_a_frame (frame_num)
COMMENT_LINE $01CC This procedure selects a particular frame
COMMENT_LINE $01CC as the active frame, and returns a pointer
COMMENT_LINE $01CC to the vector list associated with that frame
COMMENT_LINE $01CC in the 'x' register.  At entry, the 'b' register
COMMENT_LINE $01CC specifies which frame is to be selected.
COMMENT $01CD * " "
COMMENT_LINE $01D6 This is the starting point for the
COMMENT_LINE $01D6 ANIMATE main menu option.
COMMENT_LINE $01F2 advance_to_next_frame()
COMMENT_LINE $01F2 This procedure first checks to see if we will be
COMMENT_LINE $01F2 entering a virgin frame (C8A5 == C8A6), and if we
COMMENT_LINE $01F2 are, then it copies the data in the current frames
COMMENT_LINE $01F2 vector list area into the area associated with the
COMMENT_LINE $01F2 next frame.  In any case, the frame counter is
COMMENT_LINE $01F2 incremented, and if this is a virgin frame, then
COMMENT_LINE $01F2 C8A6 is updated to reflect the fact that we have
COMMENT_LINE $01F2 now advanced into a new frame.
COMMENT $01F2 * If C8A5 == C8A6, then init
COMMENT $01F5 * the new vector list area.
COMMENT $01FE * Copy vector list info from
COMMENT $0200 * current frame to new frame.
COMMENT $020F * Increment the frame counter, and
COMMENT $0212 * update C8A6 if this is a virgin
COMMENT $0215 * frame being entered.
COMMENT_LINE $0224 animate_handler()
COMMENT_LINE $0224 This procedure is responsible for overseeing the
COMMENT_LINE $0224 work done by the ANIMATE command.  It is invoked
COMMENT_LINE $0224 through the indirect jump location.
COMMENT $022A * Reset pointer to the
COMMENT $022D * first frame.
COMMENT $0245 * If a vector was picked, then
COMMENT $0248 * highlight it, by redrawing
COMMENT $024C * it several times.
COMMENT $0259 * If button 4 (delete) is
COMMENT $025C * pressed, then remove the
COMMENT $025E * indexes for this line from
COMMENT $0260 * the line array.
COMMENT $026D * If button 2 was pressed,
COMMENT $026F * then add the indexes for
COMMENT $0272 * the line endpoints to the
COMMENT $0274 * line array (C8A9-C90E).
COMMENT_LINE $027A disp_sm_erase_str()
COMMENT_LINE $027A Display the ERASE sub-menu string, while the
COMMENT_LINE $027A ANIMATE option is in CREATE mode.  If the
COMMENT_LINE $027A string is picked (C89E != 0) while button 3
COMMENT_LINE $027A is pressed (C814 != 0), then jump to the routine
COMMENT_LINE $027A which re_initializes the animate buffers and
COMMENT_LINE $027A variables; this erases the all current frames.
COMMENT_LINE $0290 disp_sm_next_str()
COMMENT_LINE $0290 Display the NEXT sub-menu string, while the
COMMENT_LINE $0290 ANIMATE option is in CREATE mode.  If the string
COMMENT_LINE $0290 is picked (C89E != 0) while button 3 is pressed
COMMENT_LINE $0290 (C814 != 0), then advance to the next ANIMATE frame.
COMMENT_LINE $02AA disp_sm_menu_str()
COMMENT_LINE $02AA Display the MENU sub-menu string, while the
COMMENT_LINE $02AA ANIMATE option is in CREATE mode.  If the string
COMMENT_LINE $02AA is picked (C89E != 0) while button 3 is pressed
COMMENT_LINE $02AA (C814 != 0), then exit from ANIMATE mode, and return
COMMENT_LINE $02AA to the main menu.
COMMENT $02C1 * height of FR string
COMMENT $02C2 * width of FR string
COMMENT $02C3 * rel y of FR string
COMMENT $02C4 * rel x of FR string
COMMENT $02C5 * pointer to start of FR string
COMMENT_LINE $02C7 edit_handler()
COMMENT_LINE $02C7 This procedure is responsible for processing the
COMMENT_LINE $02C7 buttons during the EDIT portion of ANIMATE mode.
COMMENT_LINE $02C7 It also displays the EDIT header, and the sub-menu
COMMENT_LINE $02C7 items (if they have not bee disabled).  This is
COMMENT_LINE $02C7 invoked only through the indirect jump location.
COMMENT $02C7 * See if a background image
COMMENT $02CA * needs to be displayed.
COMMENT $02E7 * Check button 4 (background)
COMMENT $02EC * Toggle state of background flag
COMMENT $02EF * Check button 1 (foreground)
COMMENT $02F4 * Toggle state of foreground flag
COMMENT $02FA * Display EDIT screen header
COMMENT $0300 * See if sub-menu should be displayed
COMMENT_LINE $0306 display_frame_num()
COMMENT_LINE $0306 Display the frame number string:
COMMENT_LINE $0306 "FR #",$80
COMMENT $0306 * "F"
COMMENT $0308 * "R"
COMMENT $030D * " "
COMMENT $031A * "1"
COMMENT_LINE $032C disp_sm_menu_str2()
COMMENT_LINE $032C Display the MENU sub-menu string, while the
COMMENT_LINE $032C ANIMATE option is in EDIT mode.  If the string
COMMENT_LINE $032C is picked (C89E != 0) while button 3 is pressed
COMMENT_LINE $032C (C814 != 0), then exit from ANIMATE mode, and return
COMMENT_LINE $032C to the main menu.
COMMENT_LINE $0346 disp_sm_create_str()
COMMENT_LINE $0346 Display the CREATE sub-menu string, while the
COMMENT_LINE $0346 ANIMATE option is in EDIT mode.  If the string
COMMENT_LINE $0346 is picked (C89E != 0) while button 3 is pressed
COMMENT_LINE $0346 (C814 != 0), then exit from EDIT mode, and return
COMMENT_LINE $0346 to CREATE mode.
COMMENT_LINE $035F disp_sm_next_str2()
COMMENT_LINE $035F Display the NEXT sub-menu string, while the
COMMENT_LINE $035F ANIMATE option is in EDIT mode.  If the string
COMMENT_LINE $035F is picked (C89E != 0) while button 3 is pressed
COMMENT_LINE $035F (C814 != 0), then advance to the next frame, and
COMMENT_LINE $035F make a sound also.
COMMENT $035F * Only display this label if we
COMMENT $0362 * are not already at last frame
COMMENT $0376 * Increment the frame counter
COMMENT_LINE $0384 disp_sm_last_str()
COMMENT_LINE $0384 Display the LAST sub-menu string, while the
COMMENT_LINE $0384 ANIMATE option is in EDIT mode.  If the string
COMMENT_LINE $0384 is picked (C89E != 0) while button 3 is pressed
COMMENT_LINE $0384 (C814 != 0), then display the previous frame, and
COMMENT_LINE $0384 make a sound also.
COMMENT $0384 * Only display this label if not
COMMENT $0387 * already at first frame.
COMMENT $039E * Decrement frame counter
COMMENT_LINE $03A8 disp_sm_play_str()
COMMENT_LINE $03A8 Display the PLAY sub-menu string, while the
COMMENT_LINE $03A8 ANIMATE option is in EDIT mode.  If the string
COMMENT_LINE $03A8 is picked (C89E != 0) while button 3 is pressed
COMMENT_LINE $03A8 (C814 != 0), then prepare to start playing through
COMMENT_LINE $03A8 the current = of defined frames.
COMMENT_LINE $03C2 check_for_move_request()
COMMENT_LINE $03C2 This routine is responsible for checking the state
COMMENT_LINE $03C2 of button 3 (move a point) during ANIMATE mode.  This
COMMENT_LINE $03C2 is called by the CREATE and EDIT handlers, for each
COMMENT_LINE $03C2 pass through the handler loop.
COMMENT_LINE $03C2 C912 indicates if a move request is currently active.
COMMENT_LINE $03C2 C90F contains index of currently picked point.
COMMENT_LINE $03C2 C917 points to the beginning of the vector list.
COMMENT $03C2 * Check for button 3 transition
COMMENT $03C5 * Button 3 = move a point.
COMMENT $03CD * See if button 3 is now pressed
COMMENT $03D2 * Make sure a point is picked
COMMENT $03DD * Flag that move is active
COMMENT $03E3 * Set up new cursor movement
COMMENT $03E6 * limits.
COMMENT $03F0 * Save index of moving point
COMMENT $03F6 * Get point's coordinates
COMMENT $03FB * Move cursor to this point
COMMENT $040B * Replace the location of
COMMENT $040E * the picked point
COMMENT $0411 * in the vector list.
COMMENT $0424 * Draw the lightpen box
COMMENT $0427 * around the picked point
COMMENT_LINE $042D process_button1_and_2()
COMMENT_LINE $042D This procedure checks to see if buttons 1 or 2 are
COMMENT_LINE $042D during animate mode.  If neither button is pressed,
COMMENT_LINE $042D then this routine returns without doing anything.
COMMENT_LINE $042D However, if either button is pressed, then this routine
COMMENT_LINE $042D attempts to 'locate' the lightpen.  If C90F != $FF,
COMMENT_LINE $042D then this implies that the lightpen is already at a
COMMENT_LINE $042D known place (on an existing point); if C90F == $FF,
COMMENT_LINE $042D then a series of horizontal scan lines will be drawn,
COMMENT_LINE $042D until the lightpen is located, or the whole screen is
COMMENT_LINE $042D scanned.
COMMENT_LINE $042D At entry:
COMMENT_LINE $042D (C8A3)-1 contains index of next available spot
COMMENT_LINE $042D in the vector list.
COMMENT_LINE $042D At exit time:
COMMENT_LINE $042D 'a' register =  0 => lightpen not located.
COMMENT_LINE $042D 'a' register = FF => lightpen located, and
COMMENT_LINE $042D C910 is = to index of current point, and
COMMENT_LINE $042D C911 is = to index of previous point.
COMMENT $042D * Check if either button 1 or
COMMENT $0430 * button 2 is pressed.
COMMENT $0435 * Lightpen not located
COMMENT $0437 * See if the lightpen is on an
COMMENT $043A * existing point.
COMMENT $043C * YES it is, so save the index
COMMENT $043F * this point, and the previous
COMMENT $0442 * point the lightpen picked.
COMMENT $044E * Lightpen not located.
COMMENT $0450 * Lightpen located, so save new
COMMENT $0453 * cursor position index, and the
COMMENT $0456 * previous lightpen position.
COMMENT $045D * Lightpen located
COMMENT_LINE $0460 scan_screen_for_lightpen()
COMMENT_LINE $0460 If the current frame is not filled, then this routine
COMMENT_LINE $0460 will perform a full screen scan, in an attempt to
COMMENT_LINE $0460 locate the lightpen.  If the lightpen is located, then
COMMENT_LINE $0460 its position is saved in the next location in the vector
COMMENT_LINE $0460 list for all 9 frames.
COMMENT_LINE $0460 At entry:
COMMENT_LINE $0460 C917 points to the start of the vector list.
COMMENT_LINE $0460 C8A3 contains index into next available place
COMMENT_LINE $0460 in the vector list.
COMMENT_LINE $0460 At exit:
COMMENT_LINE $0460 'a' =    0 if lightpen was not located.
COMMENT_LINE $0460 'a' = $FF if lightpen was located.
COMMENT $0460 * See if this frame is already full
COMMENT $046F * Lightpen not found
COMMENT $0471 * Lightpen was found
COMMENT $0478 * Save lightpen location.
COMMENT $047A * Increment vector list index.
COMMENT $0481 * Add this point to each of the
COMMENT $0484 * 8 other frames.
COMMENT $0489 * Lightpen was found
COMMENT_LINE $048C find_lightpen_pick()
COMMENT_LINE $048C This routine draws a dot at each endpoint for every
COMMENT_LINE $048C vector currently defined in the frame vector list.
COMMENT_LINE $048C if a lightpen pick is detected when a dot is drawn,
COMMENT_LINE $048C box will be drawn around that endpoint.  The cross
COMMENT_LINE $048C will be drawn at the last known cursor position.
COMMENT_LINE $048C At entry:
COMMENT_LINE $048C C8A3 contains index of next available spot in
COMMENT_LINE $048C the vector list.
COMMENT_LINE $048C C910 contains index of last known cursor position.
COMMENT_LINE $048C At exit:
COMMENT_LINE $048C C90F contains index of picked point; $FF if
COMMENT_LINE $048C no point was picked.
COMMENT_LINE $048C Work variables:
COMMENT_LINE $048C C915 flags if a point was already picked.
COMMENT_LINE $048C C880 contains index into the vector list for the
COMMENT_LINE $048C next endpoint to check.
COMMENT_LINE $048C C881 contains index of picked point.
COMMENT $048C * Clear 'point picked' flag
COMMENT $0492 * Init vector list index to 0
COMMENT $0497 * Init picked point index to 0
COMMENT $049D * See if we're at end of list
COMMENT $04A5 * Return index of picked point
COMMENT $04B2 * Get the index for the next point
COMMENT $04B5 * to be checked, and see if it equals
COMMENT $04B7 * the index of the cursor position.
COMMENT $04BD * If so, then draw the cross at this
COMMENT $04BF * location.
COMMENT $04D3 * Draw dot at this endpoint, and see
COMMENT $04D4 * if it was picked by the lightpen
COMMENT $04E4 * Check for a lightpen pick
COMMENT $04E7 * Ignore, if previous pick occurred
COMMENT $04EC * Ignore, if a move is active
COMMENT $04F1 * Draw a box around this endpoint
COMMENT $04FC * Save index of picked point.
COMMENT $04FF * Flag that a pick occurred.
COMMENT $0505 * Loop to next point
COMMENT_LINE $0507 draw_points_without_pick()
COMMENT_LINE $0507 This routine goes through the vector list for the
COMMENT_LINE $0507 current frame, and draws a dot at each endpoint.
COMMENT_LINE $0507 Lightpen picks are ignored.
COMMENT $050A * Keep processing, until we reach
COMMENT $050D * the end of the vector list.
COMMENT $051F * Move to next endpoint, and
COMMENT $0522 * draw a dot there.
COMMENT_LINE $052F This is a = of move and draw instructions,
COMMENT_LINE $052F which result in a cross being displayed.
COMMENT $052F * move
COMMENT $0532 * draw
COMMENT $0535 * move
COMMENT $0538 * draw
COMMENT $053B * end of list
COMMENT_LINE $053C draw_all_visible_lines()
COMMENT_LINE $053C This routine draws all of the visible lines in
COMMENT_LINE $053C the current animate frame.  While these lines are
COMMENT_LINE $053C being drawn, any lightpen picks are saved for later
COMMENT_LINE $053C use.
COMMENT_LINE $053C C8A9 is start of array containing indexes of
COMMENT_LINE $053C endpoints for each visible line.
COMMENT_LINE $053C At exit:
COMMENT_LINE $053C C915 points to the index pair, in the line array
COMMENT_LINE $053C (C8A9), of the vector which was picked; $FFFF
COMMENT_LINE $053C if none were picked.
COMMENT $053C * Load addr of line index array
COMMENT $0542 * Init picked vector pointer
COMMENT $0551 * Check to see if a pick occurred,
COMMENT $0552 * and save a pointer to the endpt
COMMENT $0554 * index pair in C915, if so.
COMMENT_LINE $055B draw_line_between_2_points()
COMMENT_LINE $055B Draw a line between the 2 endpoints whose index are
COMMENT_LINE $055B pointed to by the 'u' registe.  These 2 indexes are then
COMMENT_LINE $055B then used to index into the vector list array.  While
COMMENT_LINE $055B drawing the line, check for a lightpen pick.
COMMENT_LINE $055B At entry:
COMMENT_LINE $055B 'u' points to the index pairs describing the
COMMENT_LINE $055B starting and ending points for this line.
COMMENT_LINE $055B The indexes are in the following format:
COMMENT_LINE $055B (ending pt index, starting pt index)
COMMENT_LINE $055B At exit:
COMMENT_LINE $055B 'a' = 0 => vector was not picked.
COMMENT_LINE $055B otherwise, the vector was picked.
COMMENT $055E * Load 'y' with coordinates for
COMMENT $0561 * line's endpoint.
COMMENT $0566 * Load 'x' with coordinates for
COMMENT $0569 * line's starting point.
COMMENT_LINE $056F init_animate_variables()
COMMENT_LINE $056F This procedure initializes the block of memory
COMMENT_LINE $056F in the range C8A9-C90E to $FF.  It is called
COMMENT_LINE $056F when ANIMATE mode is first entered.  This block
COMMENT_LINE $056F of memory contains the line endpoint index pairs
COMMENT_LINE $056F for all visible lines.
COMMENT_LINE $057C add_a_new_line()
COMMENT_LINE $057C This routine adds the index pairs describing the
COMMENT_LINE $057C starting and ending points for a line, to the line
COMMENT_LINE $057C endpoint array, at C8A9-C90C.  If either of the
COMMENT_LINE $057C indexes is $FF, or if the indexes are the same, then
COMMENT_LINE $057C this point is not added to the array.  The indexes are
COMMENT_LINE $057C added to the next available location.
COMMENT_LINE $057C At entry:
COMMENT_LINE $057C a = ending point index
COMMENT_LINE $057C b = starting point index
COMMENT $057F * Don't bother, if array
COMMENT $0582 * is full.
COMMENT $0585 * Verify that this is a
COMMENT $0586 * valid set of endpoint
COMMENT $0588 * indexes.
COMMENT $0591 * See if spot is empty
COMMENT $0598 * Spot is taken, go onto
COMMENT $059A * next entry location.
COMMENT_LINE $059C play_handler()
COMMENT_LINE $059C This is the start of the PLAY command handler.
COMMENT_LINE $059C It will cause all currently defined ANIMATE
COMMENT_LINE $059C frames to be played in succession.
COMMENT $059C * See if the current frame's
COMMENT $059F * display duration has been
COMMENT $05A2 * reached.
COMMENT $05A4 * Reset duration counter, & goto
COMMENT $05A7 * next frame.
COMMENT $05AA * Display playback buf.
COMMENT $05BC * Increment duration counter
COMMENT $05C5 * If button 1 or 2 is pressed,
COMMENT $05C8 * then enter the EDIT portion
COMMENT $05CA * of the ANIMATE code.
COMMENT_LINE $05D3 init_play_variables()
COMMENT_LINE $05D3 This routine is invoked when the user initiates
COMMENT_LINE $05D3 an animate 'PLAY' request.  It will initialize
COMMENT_LINE $05D3 some of the globals used by the PLAY routines.
COMMENT $05D3 * Clear frame duration counter.
COMMENT $05D8 * Set default playback speed.
COMMENT $05DE * Set up to display 1st frame.
COMMENT $05E1 * Direction flag:0=>frwd,1=>bckwd
COMMENT_LINE $05E8 check_playback_speed_buttons()
COMMENT_LINE $05E8 This routine monitors buttons 3 (slow) and
COMMENT_LINE $05E8 4 (fast) during the PLAY mode portion of the
COMMENT_LINE $05E8 animate option.  The current playback speed is
COMMENT_LINE $05E8 kept in C929; 0 = fastest, 7 = slowest.
COMMENT_LINE $05F3 decrease_playback_speed()
COMMENT_LINE $05F3 Decrease the playback speed (by incrementing C929)
COMMENT $0601 * Increase duration counter for
COMMENT $0602 * this frame.
COMMENT_LINE $0609 increase_playback_speed()
COMMENT_LINE $0609 Increase the playback speed (by decrementing C929)
COMMENT $0615 * Decrease duration counter
COMMENT $0616 * for this frame.
COMMENT_LINE $061D update_playback_variables()
COMMENT_LINE $061D This routine uses the current playback speed, in C929,
COMMENT_LINE $061D to index into the structure at 0632 (playback_speed_info).
COMMENT_LINE $061D From this structure, two values are obtained: a 1 byte bit
COMMENT_LINE $061D pattern, and a two byte jump address.  These two
COMMENT_LINE $061D values are used by the playback routines.
COMMENT_LINE $0632 Table with the following format:
COMMENT_LINE $0632 1 byte value
COMMENT_LINE $0632 2 byte subroutine address.
COMMENT_LINE $0632 The information here is used during the PLAY
COMMENT_LINE $0632 mode of ANIMATE.  The playback speed (in C929)
COMMENT_LINE $0632 is used to index into this structure.  An index
COMMENT_LINE $0632 of 7 is for slowest playback, and an index of 0
COMMENT_LINE $0632 is for fastest playback.
COMMENT_LINE $064A get_ptrs_to_playback_frames()
COMMENT_LINE $064A This routine is used during the playback mode portion
COMMENT_LINE $064A of animate.  If loads C924 with a pointer to the
COMMENT_LINE $064A frame buffer for the current buffer, and C926 with a
COMMENT_LINE $064A a pointer to the frame buffer for the next buffer to
COMMENT_LINE $064A be displayed.  It will then increment the buffer index,
COMMENT_LINE $064A in C920.
COMMENT_LINE $064A At entry:
COMMENT_LINE $064A C920 contains the index of the current frame.
COMMENT_LINE $064A At exit:
COMMENT_LINE $064A C920 is incremented to index next frame.
COMMENT_LINE $064A C924 points to frame buffer for current frame.
COMMENT_LINE $064A C926 points to frame buffer for next frame.
COMMENT $064A * Load index of current frame.
COMMENT $065A * Load C924 with ptr to frame buf
COMMENT $065C * for the current frame.
COMMENT $0663 * Load C926 with ptr to frame buf
COMMENT $0665 * for the next frame.
COMMENT_LINE $0669 This is an array of word pointers.  These point
COMMENT_LINE $0669 to the beginning of the buffer area associated
COMMENT_LINE $0669 with each of the animate frames.  Each frame is
COMMENT_LINE $0669 64 bytes long.
COMMENT_LINE $067F update_play_index_to_next_frame()
COMMENT_LINE $067F This routine updates the frame index (C920),
COMMENT_LINE $067F to index the next frame to be displayed.  If we
COMMENT_LINE $067F are currently displaying in the forward direction,
COMMENT_LINE $067F then this will be incremented.  If we are currently
COMMENT_LINE $067F displaying in the backward direction, then this will
COMMENT_LINE $067F be decremented.  If we reach the first/last frame,
COMMENT_LINE $067F then the direction will be changed.
COMMENT $067F * Check 4 frwd/bkwd display order.
COMMENT $0684 * Increment, if not at last frame.
COMMENT $0690 * Set direction flag to 'backwards'.
COMMENT $0695 * Decrement to previous frame.
COMMENT $0699 * Decrement, if not at first frame.
COMMENT $06A2 * Set direction flag to 'forwards'.
COMMENT $06A5 * Increment to next frame.
COMMENT_LINE $06A9 fill_playback_buffer()
COMMENT_LINE $06A9 This routine fills the playback buffer (C933-????)
COMMENT_LINE $06A9 with the (y,x) coordinate pairs for the currently
COMMENT_LINE $06A9 visible frame.  It does this by taking each coordinate
COMMENT_LINE $06A9 in the current frame, and the corresponding coordinate
COMMENT_LINE $06A9 in the next frame, and doing some sort of extrapolation
COMMENT_LINE $06A9 on them, to end up with the final endpoint.
COMMENT_LINE $06A9 At entry:
COMMENT_LINE $06A9 C924 points to frame buffer for current frame.
COMMENT_LINE $06A9 C926 points to frame buffer for next frame.
COMMENT_LINE $06A9 C933 is start of playback buffer.
COMMENT_LINE $06A9 C8A3 specifies number of defined points in a frame.
COMMENT $06A9 * Pointer to current frame.
COMMENT $06AC * Ptr to next (transition) frame.
COMMENT $06B0 * Addr of playback buffer.
COMMENT $06B3 * # of points in frame buffer.
COMMENT $06BE * Load both 'y' coordinates.
COMMENT $06C8 * Save final 'y' coordinate.
COMMENT $06CA * Load both 'x' coordinates.
COMMENT $06D4 * Save final 'x' coordinate.
COMMENT_LINE $06DC merge_coordinates()
COMMENT_LINE $06DC This routine takes a pair of coordinates (2 'x' or
COMMENT_LINE $06DC 2 'y') and extrapolates a new value.  This new coordinate
COMMENT_LINE $06DC is what is displayed by the playback routine.
COMMENT_LINE $06DC At entry:
COMMENT_LINE $06DC C82E has coordinate for current frame.
COMMENT_LINE $06DC C82F has coordinate for next frame.
COMMENT_LINE $06DC At exit:
COMMENT_LINE $06DC 'b' contains modified coordinate.
COMMENT $06DC * Get coord for current frame.
COMMENT $06E2 * Get coord for next frame.
COMMENT_LINE $0721 search_screen_for_lightpen()
COMMENT_LINE $0721 This routine attempts to locate the location of the
COMMENT_LINE $0721 lightpen, by drawing a series of horizontal scan lines.
COMMENT_LINE $0721 Starting from the bottom of the display, a series of
COMMENT_LINE $0721 lines are drawn, until either a lightpen pick occurs,
COMMENT_LINE $0721 or the last scan line is drawn.  If a lightpen pick
COMMENT_LINE $0721 occurs, then that particular scan line will again be
COMMENT_LINE $0721 drawn, only this time, interrupts will be enabled, so
COMMENT_LINE $0721 that the exact location of the pick can be determined.
COMMENT_LINE $0721 At exit:
COMMENT_LINE $0721 'a' =    0 if lightpen was not located.
COMMENT_LINE $0721 'a' = $FF if lightpen was located.
COMMENT_LINE $0721 Work variables:
COMMENT_LINE $0721 C881 contains the number of scan lines left to draw.
COMMENT_LINE $0721 C882-C883 contain starting point for next scan line.
COMMENT $0723 * Init # of scan lines to draw
COMMENT $0729 * Init start pt for first scan line
COMMENT $0734 * If we make it to here, then the
COMMENT $0735 * lightpen was not found.
COMMENT $0739 * Move to start of scan line
COMMENT $0750 * Use solid line pattern.
COMMENT $075A * Check for a lightpen pick
COMMENT $0760 * No lightpen pick, so continue
COMMENT $0763 * to draw the next scan line.
COMMENT $0766 * Draw on everyother horz line.
COMMENT_LINE $076D find_point_of_intersection()
COMMENT_LINE $076D This routine is responsible for locating the exact
COMMENT_LINE $076D location of the lightpen, after a pick has occurred
COMMENT_LINE $076D while a scan line was being drawn.  It does this in
COMMENT_LINE $076D the following manner:
COMMENT_LINE $076D The pen is moved back to the start of the previous
COMMENT_LINE $076D scan line, and lightpen interrupts are enabled.
COMMENT_LINE $076D Next, the scan line is redrawn; while this is going
COMMENT_LINE $076D on, a timing (counter) loop is executed.  If the
COMMENT_LINE $076D timing loop completes, then it implies that the
COMMENT_LINE $076D lightpen was not located; interrupts will be disabled,
COMMENT_LINE $076D and control will return to the procedure which had
COMMENT_LINE $076D originally invoked the scan line routine.
COMMENT_LINE $076D However, if the lightpen interrupts, then the timing
COMMENT_LINE $076D loop is interrupted, and the ISR handling routine is
COMMENT_LINE $076D called.  This handler will calculate the exact location
COMMENT_LINE $076D of the lightpen, using the value in the counter.  If
COMMENT_LINE $076D an interrupt occurs, control will never return to
COMMENT_LINE $076D this routine; control returns directly to the routine
COMMENT_LINE $076D which had invoked the scan line routine.  The location
COMMENT_LINE $076D of the 'pick' is returned in the 'x' register.
COMMENT $0770 * Move to start of scan line
COMMENT $0776 * Enable IRQ on 6809
COMMENT $0778 * Enable CA1 on PIA
COMMENT $077C * Set up IRQ handler
COMMENT $0787 * Redraw the scan line
COMMENT $079E * Wait for interrupt; counter loop
COMMENT $07A8 * Lightpen not found
COMMENT_LINE $07AA disable_interrupts()
COMMENT_LINE $07AA This routine is responsible for disabling lightpen
COMMENT_LINE $07AA interrupts.
COMMENT $07AB * Disable CA1 on PIA
COMMENT $07B1 * Disable IRQ on 6809
COMMENT_LINE $07B7 process_ISR()
COMMENT_LINE $07B7 This procedure performs most of the work involved,
COMMENT_LINE $07B7 whenever the lightpen generates an interrupt.  It
COMMENT_LINE $07B7 uses the counter value, in the 'b' register, to
COMMENT_LINE $07B7 calculate the x coordinate of the lightpen.  The
COMMENT_LINE $07B7 intersection point is returned in the 'x' register.
COMMENT_LINE $07B7 This routine returns to the routine which invoked
COMMENT_LINE $07B7 the scan line search routine.
COMMENT $07BB * Calculate x coordinate
COMMENT $07C3 * Retrieve y coordinate
COMMENT $07CB * Lightpen found
COMMENT_LINE $07CE ISR_handler()
COMMENT_LINE $07CE This is the entry point called by the OS, whenever the
COMMENT_LINE $07CE lightpen generates an IRQ interrupt.  This procedure
COMMENT_LINE $07CE discards the 12 bytes of saved state information
COMMENT_LINE $07CE placed on the stack by the 6809, including the return
COMMENT_LINE $07CE address for the interrupted routine.  Then it calls the
COMMENT_LINE $07CE process_ISR() routine, to process the IRQ request.
COMMENT_LINE $07D6 draw_with_pick_check(vector_list, scale)
COMMENT_LINE $07D6 This procedure will perform a series of move and
COMMENT_LINE $07D6 draw requests, as specified in the passed in vector
COMMENT_LINE $07D6 list.  The vector list must have the following format:
COMMENT_LINE $07D6 mode, rel y, rel x
COMMENT_LINE $07D6 |      |       |
COMMENT_LINE $07D6 |      |       relative x position
COMMENT_LINE $07D6 |      relative y positon
COMMENT_LINE $07D6 FF - draw
COMMENT_LINE $07D6 0 - move
COMMENT_LINE $07D6 1 - end o list
COMMENT_LINE $07D6 NOTE: the mode also acts as the line pattern.
COMMENT_LINE $07D6 At entry: 'x' contains pointer to the vector list.
COMMENT_LINE $07D6 'b' contains the scale factor to be used.
COMMENT_LINE $07D6 At exit:  'a' contains the index of the point being
COMMENT_LINE $07D6 drawn when the lightpen detected a pick.
COMMENT_LINE $07D6 $FF if no pick occurred.
COMMENT $07D6 * Temporary storage of current pt #
COMMENT $07DA * Temporary storage of last pt picked
COMMENT $07E0 * Set rel y position.
COMMENT $07E4 * Get the mode.
COMMENT $07E6 * Increment ptr to next entry.
COMMENT $07EA * Set rel x position.
COMMENT $07EC * Set line pattern.
COMMENT $07FB * Check for a lightpen pick
COMMENT $0803 * Save the current pt #.
COMMENT $0805 * Increment the current pt #
COMMENT $080B * Return index if any pt picked.
COMMENT_LINE $080E This routine appears to not be used anywhere!!
COMMENT_LINE $0840 draw_vector_with_pick_check()
COMMENT_LINE $0840 This routine draws a vector, starting at (y,x) endpoint
COMMENT_LINE $0840 pointed to by the 'x' register, to the (y,x) endpoint
COMMENT_LINE $0840 pointed to by the 'y' register.  A value is returned
COMMENT_LINE $0840 which indicates whether or not a lightpen pick occurred
COMMENT_LINE $0840 while the vector was being drawn.
COMMENT_LINE $0840 At entry:
COMMENT_LINE $0840 'x' points to (y,x) pair for starting point.
COMMENT_LINE $0840 'y' points to (y,x) pair for ending point.
COMMENT_LINE $0840 At exit:
COMMENT_LINE $0840 'a' = 0 => no pick
COMMENT_LINE $0840 otherwise a pick occurred.
COMMENT $084D * Move to starting point
COMMENT_LINE $0879 calculate_vector_endpoint()
COMMENT_LINE $0879 This routine takes an absolute starting point, and an
COMMENT_LINE $0879 absolute ending point, and calculates the relative
COMMENT_LINE $0879 (y,x) pair for the vector between these two points.
COMMENT_LINE $0879 It also returns an index into the scale factor array,
COMMENT_LINE $0879 indicating which scale factor should be used when
COMMENT_LINE $0879 drawing the vector.
COMMENT_LINE $0879 At entry:
COMMENT_LINE $0879 'y' points to (y,x) endpoint.
COMMENT_LINE $0879 'x' points to (y,x) starting point.
COMMENT_LINE $0879 At exit:
COMMENT_LINE $0879 C881-C882 contain relative (y,x) endpoint.
COMMENT_LINE $0879 'b' contains the index of the scale factor to use.
COMMENT $0879 * Determine delta y.
COMMENT $0881 * Determine delta x.
COMMENT_LINE $08ED set_cursor_structure (cursor_ptr, data_ptr)
COMMENT_LINE $08ED This routine appears to copy the data pointer to
COMMENT_LINE $08ED by the 'x' register into the cursor structure, which
COMMENT_LINE $08ED is pointed to by the 'u' register.
COMMENT_LINE $08ED The cursor struct is 12 bytes long, and is laid out
COMMENT_LINE $08ED as follows:
COMMENT_LINE $08ED ************************
COMMENT_LINE $08ED * cursor rel y pos    *
COMMENT_LINE $08ED ************************
COMMENT_LINE $08ED * cursor rel x pos    *
COMMENT_LINE $08ED ************************
COMMENT_LINE $08ED * found this pass flag*
COMMENT_LINE $08ED ************************\
COMMENT_LINE $08ED * cursor y delta      * \
COMMENT_LINE $08ED ************************  > Used when moving cursor
COMMENT_LINE $08ED * cursor x delta      * /  to follow light pen
COMMENT_LINE $08ED ***********************
COMMENT_LINE $08ED * found last pass flag*
COMMENT_LINE $08ED ************************
COMMENT_LINE $08ED * max y position      *
COMMENT_LINE $08ED ************************
COMMENT_LINE $08ED * min x position      *
COMMENT_LINE $08ED ************************
COMMENT_LINE $08ED * min y position      *
COMMENT_LINE $08ED ************************
COMMENT_LINE $08ED * max x position      *
COMMENT_LINE $08ED ************************
COMMENT_LINE $08ED * ptr to line pattern *
COMMENT_LINE $08ED ** array used when   **
COMMENT_LINE $08ED * drawing search webs *
COMMENT_LINE $08ED ************************
COMMENT_LINE $0901 update_cursor_position()
COMMENT_LINE $0901 This routine attempts to move the cursor so that
COMMENT_LINE $0901 it 'stays' with  the lightpen.  First, it sees if
COMMENT_LINE $0901 the lightpen is still within 'sight' of the cursor.
COMMENT_LINE $0901 This is done by draw a series of 'spider web' patterns,
COMMENT_LINE $0901 until the lightpen is found, or the max web is drawn.
COMMENT_LINE $0901 Then it takes the deltas calculated by the search routine,
COMMENT_LINE $0901 adds them to the current cursor position, performs some
COMMENT_LINE $0901 bounds checks, and updates the line patterns used when
COMMENT_LINE $0901 drawing the search webs.
COMMENT $0901 * Try to find lightpen.
COMMENT $0904 * Proceed only if the lightpen
COMMENT $0906 * is currently at the cursor.
COMMENT $090A * Get y position, & extend to 16 bits
COMMENT $090F * Get new y delta
COMMENT $0912 * Add together
COMMENT $0916 * Compare new coordinate to max y
COMMENT $0918 * value.  Use max y value, if new
COMMENT $0919 * coordinate is too big.
COMMENT $0923 * Use lower search pattern
COMMENT $092B * Compare new coordinate to min y
COMMENT $092D * value.  Use min y value if new
COMMENT $092E * cordinate is too small.
COMMENT $0938 * Use upper search pattern
COMMENT $0940 * Save new y coordinate in the
COMMENT $0942 * cursor structure.
COMMENT $0947 * Use whole search pattern.
COMMENT $0949 * Load current x coordinate, and
COMMENT $094B * extend it to 16 bits.
COMMENT $0951 * Add the new x delta.
COMMENT $0955 * Compare new x coordinate to max x
COMMENT $0957 * value.  Use max value if new coord
COMMENT $0958 * is too big.
COMMENT $0962 * Use left search pattern
COMMENT $096A * Compare new coordinate to min x
COMMENT $096C * value.  Use min value, if new
COMMENT $096D * coordinate is too small.
COMMENT $0977 * Use right search pattern
COMMENT $097F * Save new x coordinate
COMMENT_LINE $0984 find_lightpen()
COMMENT_LINE $0984 This routine is used by a portion of the animate code
COMMENT_LINE $0984 to locate the lightpen, so that the cursor may track
COMMENT_LINE $0984 it.  It does this in the following manner:
COMMENT_LINE $0984 Firstly, it moves to the last known location of
COMMENT_LINE $0984 the cursor, and draws a dot.  It a lightpen pick
COMMENT_LINE $0984 occurs, then no further searching is needed; the
COMMENT_LINE $0984 lightpen has not moved.  However, if the lightpen
COMMENT_LINE $0984 has moved, then we must perform a more extensive
COMMENT_LINE $0984 search.  However, if the lightpen was not found
COMMENT_LINE $0984 the last time we searched for it, then we won't
COMMENT_LINE $0984 bother searching for it now; we don't want to
COMMENT_LINE $0984 continually clutter the screen with our search
COMMENT_LINE $0984 patterns!
COMMENT_LINE $0984 Secondly, we will draw a series of ever increasing
COMMENT_LINE $0984 8 sided spider webs.  If, while drawing one of these
COMMENT_LINE $0984 search patterns, a lightpen pick is detected, then
COMMENT_LINE $0984 we will determine which vector of the pattern was
COMMENT_LINE $0984 picked, and we will calculate a cursor movement
COMMENT_LINE $0984 delta dependent upon the scale factor used and the
COMMENT_LINE $0984 vector picked.
COMMENT_LINE $0984 Depending upon the vector picked, the base delta
COMMENT_LINE $0984 value will be either -1, <<0, or +1.  This will then
COMMENT_LINE $0984 be multiplied by a scale value, which is obtained
COMMENT_LINE $0984 by using the scale factor index to index into a
COMMENT_LINE $0984 multiplier array.  The new deltas are saved in the
COMMENT_LINE $0984 cursor structure.
COMMENT $0984 * Clear "found this pass" flag
COMMENT $098C * Move to last known location
COMMENT $0991 * Draw a dot; check for pick
COMMENT $099C * Lightpen was found
COMMENT $09A3 * Don't bother searching if lightpen
COMMENT $09A5 * wasn't found
COMMENT $09A7 * last pass.
COMMENT $09A8 * Draw the spider web, with an
COMMENT $09AB * increasing scale
COMMENT $09AE * factor, until either the light
COMMENT $09B0 * pen is found, or the last scale
COMMENT $09B2 * factor is reached.
COMMENT $09C9 * Flag that cursor is 'lost'
COMMENT $09CB * to the lightpen.
COMMENT $09CE * Get line pattern array pointer
COMMENT $09D4 * Check for a pick.
COMMENT $09D8 * Increment the scale factor.
COMMENT $09DF * Decrement the index of the picked
COMMENT $09E0 * point, & convert to word index.
COMMENT $09E1 * Load x & y delta values, and save
COMMENT $09E3 * in the cursor structure.
COMMENT $09E8 * Use the scale factor index to get
COMMENT $09EA * the correct delta multiplier.
COMMENT $09EE * Generate new y delta.
COMMENT $09F7 *  Generate new x delta.
COMMENT $09FE * Flag that the cursor is picked
COMMENT_LINE $0A05 generate_new_cursor_coordinate()
COMMENT_LINE $0A05 This routine calulates the new cursor delta,
COMMENT_LINE $0A05 by multiplying a delta value (-1, <<0, +1) by
COMMENT_LINE $0A05 a scale multiplier.
COMMENT_LINE $0A05 At entry:
COMMENT_LINE $0A05 'b' = coordinate delta.
COMMENT_LINE $0A05 'a' = scale multiplier.
COMMENT_LINE $0A13 display_search_pattern()
COMMENT_LINE $0A13 This routine draws the series of vectors, specified in
COMMENT_LINE $0A13 the structure pointed to by they 'x' register.  The 'y'
COMMENT_LINE $0A13 'y' register points to an array of line patterns
COMMENT_LINE $0A13 associated with each vector.  The scale factor to be used
COMMENT_LINE $0A13 is specified in 'b'.  A pattern of '1' terminates this
COMMENT_LINE $0A13 routine.  If a pick is detected, then the index of the
COMMENT_LINE $0A13 vector being drawn is returned in the 'a' register;
COMMENT_LINE $0A13 if no pick occurred, then $FF is returned.  This is used
COMMENT_LINE $0A13 when drawing the spider web search patterns.
COMMENT_LINE $0A13 At entry:
COMMENT_LINE $0A13 'b' = scale factor
COMMENT_LINE $0A13 'x' = vector list ptr (rel y, rel x)
COMMENT_LINE $0A13 'y' = line pattern array ptr
COMMENT_LINE $0A13 At exit:
COMMENT_LINE $0A13 'a' = $FF => no pick occurred.
COMMENT_LINE $0A13 otherwise, indicates which vector was picked.
COMMENT $0A18 * Keeps track of current vector index
COMMENT $0A1C * Keeps index of picked vector
COMMENT $0A3D * Check for a lightpen pick
COMMENT $0A45 * Save index of picked vector.
COMMENT $0A47 * Increment index.
COMMENT $0A4D * Return index of picked vector.
COMMENT_LINE $0A54 The following 5 arrays contain the line patterns
COMMENT_LINE $0A54 used when drawing the spider web search pattern.
COMMENT_LINE $0A54 Depending upon which = of line patterns are used,
COMMENT_LINE $0A54 either the whole pattern, the left side, or right side,
COMMENT_LINE $0A54 or upper portion, or lower portion will be drawn.
COMMENT_LINE $0AAA These are (y,x) delta pairs, which are added
COMMENT_LINE $0AAA to the cursor position, to line the cursor up
COMMENT_LINE $0AAA with the lightpen.  The pair used depends upon
COMMENT_LINE $0AAA which vector of the search pattern was picked.
COMMENT_LINE $0ABA This is an array of multiplier values, used when
COMMENT_LINE $0ABA updating the cursors position so that is tracks
COMMENT_LINE $0ABA the lightpen.  The scale factor index used to
COMMENT_LINE $0ABA draw the search pattern is also used to index into
COMMENT_LINE $0ABA this byte array.  As the scale factor increases, so
COMMENT_LINE $0ABA does the multiplier value.
COMMENT_LINE $0AC4 This array contains the scale factors to be used
COMMENT_LINE $0AC4 when drawing the search patterns.
COMMENT_LINE $0ACF print_with_pick_check(string_ptr)
COMMENT_LINE $0ACF This procedure checks to see if a pick occurred
COMMENT_LINE $0ACF on the previous pass through the main loop (C81E != 0).
COMMENT_LINE $0ACF If a pick did not occur, then the passed in string
COMMENT_LINE $0ACF is displayed.  However, if a pick did occur on the
COMMENT_LINE $0ACF previous pass, then a check is made to see if this
COMMENT_LINE $0ACF is the string which was picked (the string address
COMMENT_LINE $0ACF is compared against that which was saved in C81C).
COMMENT_LINE $0ACF If this is not the string which was last picked, then
COMMENT_LINE $0ACF this string will not be displayed.  If this was the
COMMENT_LINE $0ACF string which was picked, then we will display it.
COMMENT_LINE $0ACF If we do display the string, then afterwards, we will
COMMENT_LINE $0ACF check to see if a pick occurred, and if so, then we
COMMENT_LINE $0ACF will hi-light the string, and save its address in C81C.
COMMENT_LINE $0ACF This routine is useful for display menus with multiple
COMMENT_LINE $0ACF choices.  When one choice is selected, the others will
COMMENT_LINE $0ACF not be displayed.  Once a string is no longer selected,
COMMENT_LINE $0ACF then all of the choices will once again be displayed.
COMMENT_LINE $0ACF At entry: 'u' must point to the string block.
COMMENT_LINE $0AED hilite_string()
COMMENT_LINE $0AED This routine is used by print_with_pick_check() to
COMMENT_LINE $0AED hi-lite a string once it is picked, and to = several
COMMENT_LINE $0AED globals, so that other routine will know a pick occurred.
COMMENT_LINE $0AED The address of the string block is in C880.  A copy of
COMMENT_LINE $0AED this address will then be saved in C81C, and C89E and
COMMENT_LINE $0AED C81B will be = to one (to flag that a pick occurred).
COMMENT_LINE $0B19 am_print_string()
COMMENT_LINE $0B19 Prints a string of character, terminated by $80.
COMMENT_LINE $0B19 At entry, the 'u' register must point to a block
COMMENT_LINE $0B19 having the following format:
COMMENT_LINE $0B19 1 byte height of string
COMMENT_LINE $0B19 1 byte width of string
COMMENT_LINE $0B19 1 byte rel y location
COMMENT_LINE $0B19 1 byte rel x location
COMMENT_LINE $0B19 2 byte pointer to start of string
COMMENT_LINE $0B19 At exit: C89E will be = if a pick occurred.
COMMENT $0B66 * Record any picks.
COMMENT_LINE $0BC9 This describes the initial cursor state.
COMMENT_LINE $0BCF start_of_sketch_connect()
COMMENT_LINE $0BCF This is the starting point for the SKETCH and
COMMENT_LINE $0BCF the CONNECT main menu items.
COMMENT_LINE $0BE1 sketch_connect_handler()
COMMENT_LINE $0BE1 This is the real main loop routine for the sketch
COMMENT_LINE $0BE1 and connect operatons.  It takes care of reading
COMMENT_LINE $0BE1 the buttons, and calling any button handlers, as
COMMENT_LINE $0BE1 needed.  It is invoked only through the indirect
COMMENT_LINE $0BE1 jump location, by the main loop.
COMMENT $0BE4 * Check button 4, iff in connect mode
COMMENT $0BE9 * Check button 4;(dot/lines)
COMMENT $0BEE * Complement dot/connect flag
COMMENT $0BFA * Check button 1;(draw)
COMMENT $0BFF * Check button 4, iff in sketch mode
COMMENT $0C04 * Check button 4;(fan)
COMMENT $0C09 * Check button 2;(rubber band line)
COMMENT_LINE $0C0F sc_start_draw()
COMMENT_LINE $0C0F sc_start_fan()
COMMENT_LINE $0C0F These two entry points are responsible for initializing
COMMENT_LINE $0C0F things when either button 1 (draw) or button 4 (fan)
COMMENT_LINE $0C0F are pressed during SKETCH or CONNECT modes.  They will
COMMENT_LINE $0C0F = up a new indirect jump handler, save the current
COMMENT_LINE $0C0F cursor position, and initialize some variables.
COMMENT $0C12 * Don't bother, if the vector
COMMENT $0C15 * list is already full.
COMMENT $0C1A * Save new indirect jump handler.
COMMENT $0C1F * Load 'x' with pointer to next
COMMENT $0C22 * free spot in the vector list
COMMENT $0C23 * buffer.
COMMENT $0C27 * Fill this spot, using the current
COMMENT $0C2A * cursor position.
COMMENT $0C2C * Increment the vector counter.
COMMENT $0C2F * # of pts to draw relative 2 starting
COMMENT $0C31 * pt, be4 forcing new absolute ref pt.
COMMENT $0C34 * Save current cursor position.
COMMENT $0C3F * Stores reset value for counter.
COMMENT $0C42 * Active counter; endpoint is fixed
COMMENT $0C45 * when this goes to 0.
COMMENT_LINE $0C46 sc_start_rubber_band_line()
COMMENT_LINE $0C46 This entry point is responsible for setting up the
COMMENT_LINE $0C46 indirect jump location, and initializing variables
COMMENT_LINE $0C46 when button 2 (rubber band line) is pressed during
COMMENT_LINE $0C46 either SKETCH or CONNECT mode.
COMMENT $0C46 * Save current cursor position.
COMMENT $0C4F * Don't bother if the vector list
COMMENT $0C52 * is already full.
COMMENT $0C57 * Save new indirect jump handler.
COMMENT_LINE $0C5B sc_draw_handler()
COMMENT_LINE $0C5B This is the routine which draws lines/dots when
COMMENT_LINE $0C5B button 1 is depressed.  It is invoked only through
COMMENT_LINE $0C5B the indirect jump location.  It is used only when
COMMENT_LINE $0C5B either SKETCH or CONNECT modes are active.
COMMENT $0C61 * Check if button 1 is still pressed.
COMMENT $0C72 * Don't continue, if the cursor has
COMMENT $0C75 * not moved since last point.
COMMENT $0C7C * Wait for counter (C895) to decrement
COMMENT $0C7F * to zero, before fixing endpoint.
COMMENT $0C88 * Move the starting point for next
COMMENT $0C8B * vector to previous vectors endpt.
COMMENT $0C91 * Reset 'fix endpoint' counter.
COMMENT_LINE $0C95 fan_handler()
COMMENT_LINE $0C95 As long as the user has button 4 pressed, a fan
COMMENT_LINE $0C95 pattern will be drawn.  Once button 4 is released,
COMMENT_LINE $0C95 control will return to the sketch/connect handler.
COMMENT $0C95 * Flag that 'fan' is being done.
COMMENT $0CA3 * Check if button 4 is still pressed
COMMENT $0CB7 * Don't add a new line, unless
COMMENT $0CBA * the cursor position has changed.
COMMENT $0CC1 * Don't fix next fan endpt, until
COMMENT $0CC4 * 'fix point' counter has decremented
COMMENT $0CC6 * to zero.
COMMENT $0CCD * Set starting point for next vector
COMMENT $0CD0 * equal to last vectors endpoint.
COMMENT $0CD6 * Reset 'fix endpoint' counter.
COMMENT_LINE $0CDA rubber_band_line_handler()
COMMENT_LINE $0CDA This is the handler routine while the user is
COMMENT_LINE $0CDA drawing a rubber band line during sketch or connect
COMMENT_LINE $0CDA modes.  The rubber band line will continue until the
COMMENT_LINE $0CDA user stops pressing button 2.  This routine is only
COMMENT_LINE $0CDA invoked through the indirect jump location.
COMMENT $0CE0 * See if button 2 still depressed
COMMENT $0CE7 * Clear the relative point counter.
COMMENT $0CF4 * Draw the rubber band line from the
COMMENT $0CF7 * originat point to the current cursor
COMMENT $0CF9 * position, unless in DOT mode.
COMMENT_LINE $0D27 display_sc_menu()
COMMENT_LINE $0D27 This procedure displays either the SKETCH or CONNECT
COMMENT_LINE $0D27 header (as an unpickable string), and then also displays
COMMENT_LINE $0D27 the ERASE, MENU and DOT/LINE sub-items (as pickable strings)
COMMENT_LINE $0D27 It then checks to see if any of these items were picked,
COMMENT_LINE $0D27 and handles them is they were. Also displays the cursor.
COMMENT $0D2D * See if in sketch or connect mode
COMMENT $0D32 * CONNECT mode
COMMENT $0D38 * Display DOT or LINE item
COMMENT $0D48 * SKETCH mode
COMMENT $0D4E * Draw cursor at current
COMMENT $0D50 * position.
COMMENT $0D64 * If cursor is picked, then
COMMENT $0D67 * draw it brighter.
COMMENT $0D7F * Print ERASE item
COMMENT $0D85 * Check if button 3
COMMENT $0D88 * is pressed and item is
COMMENT $0D8A * picked.
COMMENT $0D98 * Print MENU item
COMMENT $0D9E * Check if button 3 is
COMMENT $0DA1 * pressed and item is picked
COMMENT $0DB1 * "9"
COMMENT_LINE $0DB2 gen_vec_endpoint_recal ;generate_vector_endpoint_and_recalibrate()
COMMENT_LINE $0DB2 This routine generates an endpoint for a vector.
COMMENT_LINE $0DB2 If the relative point counter (C8A4) has decremented
COMMENT_LINE $0DB2 to zero, then we will add an absolute reference point
COMMENT_LINE $0DB2 to the vector list, to prevent our vectors from getting
COMMENT_LINE $0DB2 too far out of whack; this is done after every 5 points.
COMMENT_LINE $0DB2 At entry:
COMMENT_LINE $0DB2 C8A4 contains the relative point counter.
COMMENT_LINE $0DB2 'a' has index of next available spot in vector list.
COMMENT_LINE $0DB2 C89B contains starting point for this vector.
COMMENT_LINE $0DB2 C82F contains starting point for the fan.
COMMENT_LINE $0DB2 C82E flags DRAW .vs. FAN mode.
COMMENT_LINE $0DB2 C8A3 has index of next available spot in vector list.
COMMENT_LINE $0DB2 At exit:
COMMENT_LINE $0DB2 C881-C882 contains new vector endpoint.
COMMENT_LINE $0DB2 'u' points to next available spot in vector list.
COMMENT $0DB2 * If the relative pt counter has gone
COMMENT $0DB5 * to zero, then force another absolute
COMMENT $0DB7 * ref point.
COMMENT $0DBF * Flag an absolute reference point.
COMMENT $0DC1 * Get starting pt for this vector; if
COMMENT $0DC4 * DRAW mode, then use last cursor
COMMENT $0DC7 * position; else, use cursor position
COMMENT $0DC9 * for beginning of fan.
COMMENT $0DCC * Save abs ref point.
COMMENT $0DCE * Increment vector counter.
COMMENT $0DD1 * Reset the relative point counter.
COMMENT $0DD9 * Load 'u' with pointer to current
COMMENT $0DDC * work spot in the vector list.
COMMENT $0DE1 * Calculate endpt for this vector.
COMMENT $0DF3 * Increment vector list counter.
COMMENT $0DF6 * Decrement relative point counter.
COMMENT_LINE $0DFA get_new_endpoint()
COMMENT_LINE $0DFA This routine checks to see how many vectors or dots
COMMENT_LINE $0DFA we have available for use.  The current number of
COMMENT_LINE $0DFA vectors or dots drawn is stored in C8A3.  If we
COMMENT_LINE $0DFA have already reached the limit, then return without
COMMENT_LINE $0DFA doing anything.  Otherwise, if we are close to the
COMMENT_LINE $0DFA limit, then make a sound, and flag that we are close,
COMMENT_LINE $0DFA by setting C829; this flag will prevent us from making
COMMENT_LINE $0DFA the sound more than once.  Also, it will generate the
COMMENT_LINE $0DFA scale factor and coordinates for the current vector.
COMMENT_LINE $0DFA These pieces of information are then stored in the
COMMENT_LINE $0DFA vector list.
COMMENT $0DFA * See if we have surpassed limit
COMMENT $0E02 * Don't make sound more than once
COMMENT $0E07 * See if we're near limit
COMMENT $0E14 generate_vector_endpoint_and_recalibrate;
COMMENT $0E17 * Save scale factor.
COMMENT $0E1C * Save vector endpoints.
COMMENT_LINE $0E1F init_sketch_connect_variables()
COMMENT_LINE $0E1F This routine is invoked when the sketch/connect
COMMENT_LINE $0E1F handler is first called.  It is responsible for
COMMENT_LINE $0E1F initializing the vector list residing in RAM at
COMMENT_LINE $0E1F C8A9-CBA5 to $FF.  It also initializes some RAM
COMMENT_LINE $0E1F locations to 0.
COMMENT $0E2B * Vector counter.
COMMENT $0E2E * Relative point counter.
COMMENT $0E31 * Buffer almost full flag.
COMMENT $0E34 * Sound duration.
COMMENT_LINE $0E38 sketch_connect_draw_vector_list()
COMMENT_LINE $0E38 This routine goes through the vector list, performing
COMMENT_LINE $0E38 all of the move and draw requests currently therein.
COMMENT_LINE $0E38 It does this by drawing all of the points relative to
COMMENT_LINE $0E38 to the last absolute reference point, until a new
COMMENT_LINE $0E38 absolute reference point is encountered.  At this point
COMMENT_LINE $0E38 it will recalibrate things, and then move to the new
COMMENT_LINE $0E38 absolute reference point, and continue drawing.  This
COMMENT_LINE $0E38 will continue until the end of the vector list is
COMMENT_LINE $0E38 encountered.  The vector list has the following format:
COMMENT_LINE $0E38 scale, rel y, rel x
COMMENT_LINE $0E38 If 'scale' is $FF, then this is the end of the list.
COMMENT_LINE $0E38 If 'scale' is $00, then the corresponding (y,x) are
COMMENT_LINE $0E38 really a new absolute reference point, not relative
COMMENT_LINE $0E38 points.
COMMENT_LINE $0E38 If 'scale' is positive, then draw to new point.
COMMENT_LINE $0E38 If 'scale' is negative, then move to new point.
COMMENT $0E38 * Set up vector intensity.
COMMENT $0E3D * Start drawing vector list.
COMMENT $0E4A * Reset zero reference.
COMMENT $0E4D * Move to abs ref point.
COMMENT_LINE $0E54 draw_relative_points()
COMMENT_LINE $0E54 This routine draw all of the vector in the vector
COMMENT_LINE $0E54 list, which are relative to the current absolute
COMMENT_LINE $0E54 reference point.  When the end of the vector list
COMMENT_LINE $0E54 or a new absolute reference point is encountered,
COMMENT_LINE $0E54 this routine will return.
COMMENT_LINE $0E54 At entry:
COMMENT_LINE $0E54 'x' points to the vector list.
COMMENT_LINE $0E54 At exit:
COMMENT_LINE $0E54 'a' contains scale factor for terminating point.
COMMENT $0E54 * Load scale factor; return if it
COMMENT $0E56 * flags a new abs reference point.
COMMENT $0E59 * Check 4 the end of the vector list.
COMMENT $0E5E * Check for LINE or DOT mode.
COMMENT $0E68 * Check for move/draw operation.
COMMENT $0E7F * Clear vector pattern.
COMMENT_LINE $0E8F am_draw_with_pattern (point, scale_index, pattern)
COMMENT_LINE $0E8F This moves the cursor to a particular point,
COMMENT_LINE $0E8F using one of several scale factors, and a line
COMMENT_LINE $0E8F pattern specified in C880.
COMMENT_LINE $0E8F At entry:   'x' points to vector list of rel y, relx.
COMMENT_LINE $0E8F 'a' has index into scale factor array.
COMMENT_LINE $0E8F C880 has line pattern.
COMMENT $0E92 * Load the scale factor
COMMENT $0E96 * Load vector endpoints
COMMENT $0E9C * Load line pattern from C880
COMMENT $0EAF * Clear the line pattern
COMMENT_LINE $0EB2 am_move_to_d()
COMMENT_LINE $0EB2 This routine does a quick move to the point
COMMENT_LINE $0EB2 specified in the 'd' register (a = rel y,
COMMENT_LINE $0EB2 b = rel x).  A scale factor of $7F is used.
COMMENT $0EBE * "@"
COMMENT_LINE $0ECB check_for_end_of_sound()
COMMENT_LINE $0ECB This routine checks to see if the current
COMMENT_LINE $0ECB miscellaneous sound has completed, by checking
COMMENT_LINE $0ECB the value in C856.  When it reaches zero, the
COMMENT_LINE $0ECB sound is done.
COMMENT_LINE $0ED8 set_up_a_misc_sound1()
COMMENT_LINE $0ED8 set_up_a_misc_sound2(sound)
COMMENT_LINE $0ED8 Both of these routines cause a sound to be
COMMENT_LINE $0ED8 made.  If set_up_a_misc_sound1() is used,
COMMENT_LINE $0ED8 then the sound to be made is defined by
COMMENT_LINE $0ED8 writing the value $0050 to reg 0 & reg 1
COMMENT_LINE $0ED8 on the sound chip.  If set_up_a_misc_sound2()
COMMENT_LINE $0ED8 is used, then the value passed in in the 'd'
COMMENT_LINE $0ED8 register defines the sound.  The duration of
COMMENT_LINE $0ED8 the sound is stored in C856.
COMMENT $0EDE * ">"
COMMENT $0F13 * "?"
COMMENT $0F15 * ";"
COMMENT $0F17 * ";"
COMMENT $0F19 * ";"
COMMENT $0F1B * ";"
COMMENT $0F1D * ";"
COMMENT $0F1F * ";"
COMMENT $0F21 * ";"
COMMENT $0F23 * ";"
COMMENT $0F25 * ";"
COMMENT $0F27 * ";"
COMMENT $0F29 * ";"
COMMENT $0F2B * ";"
COMMENT $0F2D * ";"
COMMENT $0F2F * ";"
COMMENT $0F31 * ";"
COMMENT $0F33 * ";"
COMMENT $0F35 * ";"
COMMENT $0F37 * ";"
COMMENT $0F39 * ";"
COMMENT $0F3B * ";"
COMMENT $0F3D * ";"
COMMENT $0F3F * ";"
COMMENT $0F41 * ";"
COMMENT $0F43 * ";"
COMMENT $0F45 * ";"
COMMENT $0F47 * ";"
COMMENT $0F49 * ";"
COMMENT $0F4B * ";"
COMMENT $0F4D * ";"
COMMENT $0F4F * ";"
COMMENT $0F51 * ";"
COMMENT $0F53 * ";"
COMMENT $0F55 * ";"
COMMENT $0F57 * ";"
COMMENT $0F59 * ";"
COMMENT $0F5B * ";"
COMMENT $0F5D * ";"
COMMENT $0F5F * ";"
COMMENT $0F61 * ";"
COMMENT $0F63 * ";"
COMMENT $0F65 * ";"
COMMENT $0F67 * ";"
COMMENT $0F69 * ";"
COMMENT $0F6B * ";"
COMMENT $0F6D * ";"
COMMENT $0F6F * ";"
COMMENT $0F71 * ";"
COMMENT $0F73 * ";"
COMMENT $0F75 * ";"
COMMENT $0F77 * ";"
COMMENT $0F79 * ";"
COMMENT $0F7B * ";"
COMMENT $0F7D * ";"
COMMENT $0F7E * "3"
COMMENT $0F80 * "i"
COMMENT $0F83 * "i"
COMMENT $0F85 * ";"
COMMENT $0F87 * ";"
COMMENT $0F89 * ";"
COMMENT $0F8B * ";"
COMMENT $0F8D * ";"
COMMENT $0F8F * ";"
COMMENT $0F91 * ";"
COMMENT $0F93 * ";"
COMMENT $0F95 * ";"
COMMENT $0F97 * ";"
COMMENT $0F99 * ";"
COMMENT $0F9B * ";"
COMMENT $0F9D * ";"
COMMENT $0F9F * ";"
COMMENT $0FA1 * ";"
COMMENT $0FA3 * ";"
COMMENT $0FA5 * ";"
COMMENT $0FA7 * ";"
COMMENT $0FA9 * ";"
COMMENT $0FAB * ";"
COMMENT $0FAD * ";"
COMMENT $0FAF * ";"
COMMENT $0FB1 * ";"
COMMENT $0FB3 * ";"
COMMENT $0FB5 * ";"
COMMENT $0FB7 * ";"
COMMENT $0FB9 * ";"
COMMENT $0FBB * ";"
COMMENT $0FBD * ";"
COMMENT $0FBF * ";"
COMMENT $0FC1 * ";"
COMMENT $0FC3 * ";"
COMMENT $0FC5 * ";"
COMMENT $0FC7 * ";"
COMMENT $0FC9 * ";"
COMMENT $0FCB * ";"
COMMENT $0FCD * ";"
COMMENT $0FCF * ";"
COMMENT $0FD1 * ";"
COMMENT $0FD3 * ";"
COMMENT $0FD5 * ";"
COMMENT $0FD7 * ";"
COMMENT $0FD9 * ";"
COMMENT $0FDB * ";"
COMMENT $0FDD * ";"
COMMENT $0FDF * ";"
COMMENT $0FE1 * ";"
COMMENT $0FE3 * ";"
COMMENT $0FE5 * ";"
COMMENT $0FE7 * ";"
COMMENT $0FE9 * ";"
COMMENT $0FEB * ";"
COMMENT $0FED * ";"
COMMENT $0FEF * ";"
COMMENT $0FF1 * ";"
COMMENT $0FF3 * ";"
COMMENT $0FF5 * ";"
COMMENT $0FF7 * ";"
COMMENT $0FF9 * ";"
COMMENT $0FFB * ";"
COMMENT $0FFD * ";"
COMMENT $0FFF * ";"
RANGE $0000-$000B DB_DATA
RANGE $000B-$000D DW_DATA
RANGE $000D-$0021 DB_DATA
RANGE $0021-$0056 CODE
RANGE $0056-$005A DB_DATA
RANGE $005A-$005C DW_DATA
RANGE $005C-$0066 DB_DATA
RANGE $0066-$0068 DW_DATA
RANGE $0068-$0071 DB_DATA
RANGE $0071-$0073 DW_DATA
RANGE $0073-$007C DB_DATA
RANGE $007C-$007E DW_DATA
RANGE $007E-$0087 DB_DATA
RANGE $0087-$0089 DW_DATA
RANGE $0089-$0092 DB_DATA
RANGE $0092-$0094 DW_DATA
RANGE $0094-$009B DB_DATA
RANGE $009B-$0151 CODE
RANGE $0151-$0155 DB_DATA
RANGE $0155-$0157 DW_DATA
RANGE $0157-$0162 DB_DATA
RANGE $0162-$0164 DW_DATA
RANGE $0164-$016D DB_DATA
RANGE $016D-$016F DW_DATA
RANGE $016F-$017A DB_DATA
RANGE $017A-$017C DW_DATA
RANGE $017C-$0188 DB_DATA
RANGE $0188-$018A DW_DATA
RANGE $018A-$01A2 DB_DATA
RANGE $01A2-$02C1 CODE
RANGE $02C1-$02C5 DB_DATA
RANGE $02C5-$02C7 DW_DATA
RANGE $02C7-$052F CODE
RANGE $052F-$053C DB_DATA
RANGE $053C-$0632 CODE
RANGE $0632-$0633 DB_DATA
RANGE $0633-$0635 DW_DATA
RANGE $0635-$0636 DB_DATA
RANGE $0636-$0638 DW_DATA
RANGE $0638-$0639 DB_DATA
RANGE $0639-$063B DW_DATA
RANGE $063B-$063C DB_DATA
RANGE $063C-$063E DW_DATA
RANGE $063E-$063F DB_DATA
RANGE $063F-$0641 DW_DATA
RANGE $0641-$0642 DB_DATA
RANGE $0642-$0644 DW_DATA
RANGE $0644-$0645 DB_DATA
RANGE $0645-$0647 DW_DATA
RANGE $0647-$0648 DB_DATA
RANGE $0648-$064A DW_DATA
RANGE $064A-$0669 CODE
RANGE $0669-$067F DW_DATA
RANGE $067F-$07D5 CODE
RANGE $07D5-$07D6 DB_DATA
RANGE $07D6-$08E7 CODE
RANGE $08E7-$08ED DB_DATA
RANGE $08ED-$0A50 CODE
RANGE $0A50-$0ACF DB_DATA
RANGE $0ACF-$0BB4 CODE
RANGE $0BB4-$0BCF DB_DATA
RANGE $0BCF-$0D0C CODE
RANGE $0D0C-$0D27 DB_DATA
RANGE $0D27-$0DB1 CODE
RANGE $0DB1-$0DB2 DB_DATA
RANGE $0DB2-$0EEE CODE
RANGE $0EEE-$0EF2 DW_DATA
RANGE $0EF2-$1000 DB_DATA

